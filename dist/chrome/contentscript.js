(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/_is-buffer@1.1.6@is-buffer/index.js":[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/app/scripts/contentscript.js":[function(_dereq_,module,exports){
(function (Buffer){
'use strict';


var path = _dereq_('path');
var pump = _dereq_('pump');
var LocalMessageDuplexStream = _dereq_('post-message-stream');
var PongStream = _dereq_('ping-pong-stream/pong');
var ObjectMultiplex = _dereq_('obj-multiplex');
var extension = _dereq_('extensionizer');
var PortStream = _dereq_('./lib/port-stream.js');

var inpageContent = Buffer("KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9ImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoIkNhbm5vdCBmaW5kIG1vZHVsZSAnIitpKyInIik7dGhyb3cgYS5jb2RlPSJNT0RVTEVfTk9UX0ZPVU5EIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9ImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9faXMtYnVmZmVyQDEuMS42QGlzLWJ1ZmZlci9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovKiEKICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlcgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwoKLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZwovLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikgewogIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpCn0KCmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHsKICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKQp9CgovLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LgpmdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikgewogIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKQp9Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svYXBwL3NjcmlwdHMvaW5wYWdlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsKXsKJ3VzZSBzdHJpY3QnOwoKLypnbG9iYWwgV2ViMyovCmNsZWFuQ29udGV4dEZvckltcG9ydHMoKTsKX2RlcmVxXygnd2ViMy9kaXN0L3dlYjMubWluLmpzJyk7CnZhciBsb2cgPSBfZGVyZXFfKCdsb2dsZXZlbCcpOwp2YXIgTG9jYWxNZXNzYWdlRHVwbGV4U3RyZWFtID0gX2RlcmVxXygncG9zdC1tZXNzYWdlLXN0cmVhbScpOwp2YXIgc2V0dXBEYXBwQXV0b1JlbG9hZCA9IF9kZXJlcV8oJy4vbGliL2F1dG8tcmVsb2FkLmpzJyk7CnZhciBNZXRhbWFza0lucGFnZVByb3ZpZGVyID0gX2RlcmVxXygnLi9saWIvaW5wYWdlLXByb3ZpZGVyLmpzJyk7CnJlc3RvcmVDb250ZXh0QWZ0ZXJJbXBvcnRzKCk7Cgpsb2cuc2V0RGVmYXVsdExldmVsKHRydWUgPyAnZGVidWcnIDogJ3dhcm4nKTsKCi8vCi8vIHNldHVwIHBsdWdpbiBjb21tdW5pY2F0aW9uCi8vCgovLyBzZXR1cCBiYWNrZ3JvdW5kIGNvbm5lY3Rpb24KdmFyIG1ldGFtYXNrU3RyZWFtID0gbmV3IExvY2FsTWVzc2FnZUR1cGxleFN0cmVhbSh7CiAgbmFtZTogJ2lucGFnZScsCiAgdGFyZ2V0OiAnY29udGVudHNjcmlwdCcKfSk7CgovLyBjb21wb3NlIHRoZSBpbnBhZ2UgcHJvdmlkZXIKdmFyIGlucGFnZVByb3ZpZGVyID0gbmV3IE1ldGFtYXNrSW5wYWdlUHJvdmlkZXIobWV0YW1hc2tTdHJlYW0pOwoKLy8KLy8gc2V0dXAgd2ViMwovLwoKaWYgKHR5cGVvZiB3aW5kb3cud2ViMyAhPT0gJ3VuZGVmaW5lZCcpIHsKICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFNYXNrIGRldGVjdGVkIGFub3RoZXIgd2ViMy5cbiAgICAgTWV0YU1hc2sgd2lsbCBub3Qgd29yayByZWxpYWJseSB3aXRoIGFub3RoZXIgd2ViMyBleHRlbnNpb24uXG4gICAgIFRoaXMgdXN1YWxseSBoYXBwZW5zIGlmIHlvdSBoYXZlIHR3byBNZXRhTWFza3MgaW5zdGFsbGVkLFxuICAgICBvciBNZXRhTWFzayBhbmQgYW5vdGhlciB3ZWIzIGV4dGVuc2lvbi4gUGxlYXNlIHJlbW92ZSBvbmVcbiAgICAgYW5kIHRyeSBhZ2Fpbi4nKTsKfQp2YXIgd2ViMyA9IG5ldyBXZWIzKGlucGFnZVByb3ZpZGVyKTsKd2ViMy5zZXRQcm92aWRlciA9IGZ1bmN0aW9uICgpIHsKICBsb2cuZGVidWcoJ01ldGFNYXNrIC0gb3ZlcnJvZGUgd2ViMy5zZXRQcm92aWRlcicpOwp9Owpsb2cuZGVidWcoJ01ldGFNYXNrIC0gaW5qZWN0ZWQgd2ViMycpOwovLyBleHBvcnQgZ2xvYmFsIHdlYjMsIHdpdGggdXNhZ2UtZGV0ZWN0aW9uCnNldHVwRGFwcEF1dG9SZWxvYWQod2ViMywgaW5wYWdlUHJvdmlkZXIucHVibGljQ29uZmlnU3RvcmUpOwoKLy8gc2V0IHdlYjMgZGVmYXVsdEFjY291bnQKaW5wYWdlUHJvdmlkZXIucHVibGljQ29uZmlnU3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkgewogIHdlYjMuZXRoLmRlZmF1bHRBY2NvdW50ID0gc3RhdGUuc2VsZWN0ZWRBZGRyZXNzOwp9KTsKCi8vIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGFyZW4ndCBhZmZlY3RlZCBieSBvdmVybGFwcGluZyBuYW1lc3BhY2VzCi8vIGFuZCB0aGF0IHdlIGRvbnQgYWZmZWN0IHRoZSBhcHAgd2l0aCBvdXIgbmFtZXNwYWNlCi8vIG1vc3RseSBhIGZpeCBmb3Igd2ViMydzIEJpZ051bWJlciBpZiBBTUQncyAiZGVmaW5lIiBpcyBkZWZpbmVkLi4uCnZhciBfX2RlZmluZTsKCi8qKgogKiBDYWNoZXMgcmVmZXJlbmNlIHRvIGdsb2JhbCBkZWZpbmUgb2JqZWN0IGFuZCBkZWxldGVzIGl0IHRvCiAqIGF2b2lkIGNvbmZsaWN0cyB3aXRoIG90aGVyIGdsb2JhbCBkZWZpbmUgb2JqZWN0cywgc3VjaCBhcwogKiBBTUQncyBkZWZpbmUgZnVuY3Rpb24KICovCmZ1bmN0aW9uIGNsZWFuQ29udGV4dEZvckltcG9ydHMoKSB7CiAgX19kZWZpbmUgPSBnbG9iYWwuZGVmaW5lOwogIHRyeSB7CiAgICBnbG9iYWwuZGVmaW5lID0gdW5kZWZpbmVkOwogIH0gY2F0Y2ggKF8pIHsKICAgIGNvbnNvbGUud2FybignTWV0YU1hc2sgLSBnbG9iYWwuZGVmaW5lIGNvdWxkIG5vdCBiZSBkZWxldGVkLicpOwogIH0KfQoKLyoqCiAqIFJlc3RvcmVzIGdsb2JhbCBkZWZpbmUgb2JqZWN0IGZyb20gY2FjaGVkIHJlZmVyZW5jZQogKi8KZnVuY3Rpb24gcmVzdG9yZUNvbnRleHRBZnRlckltcG9ydHMoKSB7CiAgdHJ5IHsKICAgIGdsb2JhbC5kZWZpbmUgPSBfX2RlZmluZTsKICB9IGNhdGNoIChfKSB7CiAgICBjb25zb2xlLndhcm4oJ01ldGFNYXNrIC0gZ2xvYmFsLmRlZmluZSBjb3VsZCBub3QgYmUgb3ZlcndyaXR0ZW4uJyk7CiAgfQp9CgoKfSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCgp9LHsiLi9saWIvYXV0by1yZWxvYWQuanMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9hcHAvc2NyaXB0cy9saWIvYXV0by1yZWxvYWQuanMiLCIuL2xpYi9pbnBhZ2UtcHJvdmlkZXIuanMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9hcHAvc2NyaXB0cy9saWIvaW5wYWdlLXByb3ZpZGVyLmpzIiwibG9nbGV2ZWwiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2xvZ2xldmVsQDEuNi4xQGxvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsInBvc3QtbWVzc2FnZS1zdHJlYW0iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3Bvc3QtbWVzc2FnZS1zdHJlYW1AMy4wLjBAcG9zdC1tZXNzYWdlLXN0cmVhbS9pbmRleC5qcyIsIndlYjMvZGlzdC93ZWIzLm1pbi5qcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fd2ViM0AwLjIwLjZAd2ViMy9kaXN0L3dlYjMubWluLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9hcHAvc2NyaXB0cy9saWIvYXV0by1yZWxvYWQuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChnbG9iYWwpewondXNlIHN0cmljdCc7Cgptb2R1bGUuZXhwb3J0cyA9IHNldHVwRGFwcEF1dG9SZWxvYWQ7CgpmdW5jdGlvbiBzZXR1cERhcHBBdXRvUmVsb2FkKHdlYjMsIG9ic2VydmFibGUpIHsKICAvLyBleHBvcnQgd2ViMyBhcyBhIGdsb2JhbCwgY2hlY2tpbmcgZm9yIHVzYWdlCiAgdmFyIGhhc0JlZW5XYXJuZWQgPSBmYWxzZTsKICB2YXIgcmVsb2FkSW5Qcm9ncmVzcyA9IGZhbHNlOwogIHZhciBsYXN0VGltZVVzZWQgPSB2b2lkIDA7CiAgdmFyIGxhc3RTZWVuTmV0d29yayA9IHZvaWQgMDsKCiAgZ2xvYmFsLndlYjMgPSBuZXcgUHJveHkod2ViMywgewogICAgZ2V0OiBmdW5jdGlvbiBnZXQoX3dlYjMsIGtleSkgewogICAgICAvLyBzaG93IHdhcm5pbmcgb25jZSBvbiB3ZWIzIGFjY2VzcwogICAgICBpZiAoIWhhc0JlZW5XYXJuZWQgJiYga2V5ICE9PSAnY3VycmVudFByb3ZpZGVyJykgewogICAgICAgIGNvbnNvbGUud2FybignTWV0YU1hc2s6IHdlYjMgd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSBuZWFyIGZ1dHVyZSBpbiBmYXZvciBvZiB0aGUgZXRoZXJldW1Qcm92aWRlciBcbmh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9mYXEvYmxvYi9tYXN0ZXIvZGV0ZWN0aW5nX21ldGFtYXNrLm1kI3dlYjMtZGVwcmVjYXRpb24nKTsKICAgICAgICBoYXNCZWVuV2FybmVkID0gdHJ1ZTsKICAgICAgfQogICAgICAvLyBnZXQgdGhlIHRpbWUgb2YgdXNlCiAgICAgIGxhc3RUaW1lVXNlZCA9IERhdGUubm93KCk7CiAgICAgIC8vIHJldHVybiB2YWx1ZSBub3JtYWxseQogICAgICByZXR1cm4gX3dlYjNba2V5XTsKICAgIH0sCiAgICBzZXQ6IGZ1bmN0aW9uIHNldChfd2ViMywga2V5LCB2YWx1ZSkgewogICAgICAvLyBzZXQgdmFsdWUgbm9ybWFsbHkKICAgICAgX3dlYjNba2V5XSA9IHZhbHVlOwogICAgfQogIH0pOwoKICBvYnNlcnZhYmxlLnN1YnNjcmliZShmdW5jdGlvbiAoc3RhdGUpIHsKICAgIC8vIGlmIHJlbG9hZCBpbiBwcm9ncmVzcywgbm8gbmVlZCB0byBjaGVjayByZWxvYWQgbG9naWMKICAgIGlmIChyZWxvYWRJblByb2dyZXNzKSByZXR1cm47CgogICAgdmFyIGN1cnJlbnROZXR3b3JrID0gc3RhdGUubmV0d29ya1ZlcnNpb247CgogICAgLy8gc2V0IHRoZSBpbml0aWFsIG5ldHdvcmsKICAgIGlmICghbGFzdFNlZW5OZXR3b3JrKSB7CiAgICAgIGxhc3RTZWVuTmV0d29yayA9IGN1cnJlbnROZXR3b3JrOwogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gc2tpcCByZWxvYWQgbG9naWMgaWYgd2ViMyBub3QgdXNlZAogICAgaWYgKCFsYXN0VGltZVVzZWQpIHJldHVybjsKCiAgICAvLyBpZiBuZXR3b3JrIGRpZCBub3QgY2hhbmdlLCBleGl0CiAgICBpZiAoY3VycmVudE5ldHdvcmsgPT09IGxhc3RTZWVuTmV0d29yaykgcmV0dXJuOwoKICAgIC8vIGluaXRpYXRlIHBhZ2UgcmVsb2FkCiAgICByZWxvYWRJblByb2dyZXNzID0gdHJ1ZTsKICAgIHZhciB0aW1lU2luY2VVc2UgPSBEYXRlLm5vdygpIC0gbGFzdFRpbWVVc2VkOwogICAgLy8gaWYgd2ViMyB3YXMgcmVjZW50bHkgdXNlZCB0aGVuIGRlbGF5IHRoZSByZWxvYWRpbmcgb2YgdGhlIHBhZ2UKICAgIGlmICh0aW1lU2luY2VVc2UgPiA1MDApIHsKICAgICAgdHJpZ2dlclJlc2V0KCk7CiAgICB9IGVsc2UgewogICAgICBzZXRUaW1lb3V0KHRyaWdnZXJSZXNldCwgNTAwKTsKICAgIH0KICB9KTsKfQoKLy8gcmVsb2FkIHRoZSBwYWdlCmZ1bmN0aW9uIHRyaWdnZXJSZXNldCgpIHsKICBnbG9iYWwubG9jYXRpb24ucmVsb2FkKCk7Cn0KCgp9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9hcHAvc2NyaXB0cy9saWIvY3JlYXRlRXJyb3JNaWRkbGV3YXJlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5Jyk7Cgp2YXIgX2RlZmluZVByb3BlcnR5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5Mik7Cgp2YXIgX1JQQ19FUlJPUlM7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKdmFyIGxvZyA9IF9kZXJlcV8oJ2xvZ2xldmVsJyk7CgovKioKICogSlNPTi1SUEMgZXJyb3Igb2JqZWN0CiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IFJwY0Vycm9yCiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIC0gSW5kaWNhdGVzIHRoZSBlcnJvciB0eXBlIHRoYXQgb2NjdXJyZWQKICogQHByb3BlcnR5IHtPYmplY3R9IFtkYXRhXSAtIENvbnRhaW5zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yCiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWVzc2FnZV0gLSBTaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3IKICovCgovKioKICogTWlkZGxld2FyZSBjb25maWd1cmF0aW9uIG9iamVjdAogKgogKiBAdHlwZWRlZiB7T2JqZWN0fSBNaWRkbGV3YXJlQ29uZmlnCiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW292ZXJyaWRlXSAtIFVzZSBSUENfRVJST1JTIG1lc3NhZ2UgaW4gcGxhY2Ugb2YgcHJvdmlkZXIgbWVzc2FnZQogKi8KCi8qKgogKiBNYXAgb2Ygc3RhbmRhcmQgYW5kIG5vbi1zdGFuZGFyZCBSUEMgZXJyb3IgY29kZXMgdG8gbWVzc2FnZXMKICovCnZhciBSUENfRVJST1JTID0gKF9SUENfRVJST1JTID0gewogIDE6ICdBbiB1bmF1dGhvcml6ZWQgYWN0aW9uIHdhcyBhdHRlbXB0ZWQuJywKICAyOiAnQSBkaXNhbGxvd2VkIGFjdGlvbiB3YXMgYXR0ZW1wdGVkLicsCiAgMzogJ0FuIGV4ZWN1dGlvbiBlcnJvciBvY2N1cnJlZC4nCn0sICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKF9SUENfRVJST1JTLCAtMzI2MDAsICdUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIFJlcXVlc3Qgb2JqZWN0LicpLCAoMCwgX2RlZmluZVByb3BlcnR5My5kZWZhdWx0KShfUlBDX0VSUk9SUywgLTMyNjAxLCAnVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuJyksICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKF9SUENfRVJST1JTLCAtMzI2MDIsICdJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykuJyksICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKF9SUENfRVJST1JTLCAtMzI2MDMsICdJbnRlcm5hbCBKU09OLVJQQyBlcnJvci4nKSwgKDAsIF9kZWZpbmVQcm9wZXJ0eTMuZGVmYXVsdCkoX1JQQ19FUlJPUlMsIC0zMjcwMCwgJ0ludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci4gQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuJyksICgwLCBfZGVmaW5lUHJvcGVydHkzLmRlZmF1bHQpKF9SUENfRVJST1JTLCAnaW50ZXJuYWwnLCAnSW50ZXJuYWwgc2VydmVyIGVycm9yLicpLCAoMCwgX2RlZmluZVByb3BlcnR5My5kZWZhdWx0KShfUlBDX0VSUk9SUywgJ3Vua25vd24nLCAnVW5rbm93biBKU09OLVJQQyBlcnJvci4nKSwgX1JQQ19FUlJPUlMpOwoKLyoqCiAqIE1vZGlmaWVzIGEgSlNPTi1SUEMgZXJyb3Igb2JqZWN0IGluLXBsYWNlIHRvIGFkZCBhIGh1bWFuLXJlYWRhYmxlIG1lc3NhZ2UsCiAqIG9wdGlvbmFsbHkgb3ZlcnJpZGluZyBhbnkgcHJvdmlkZXItc3VwcGxpZWQgbWVzc2FnZQogKgogKiBAcGFyYW0ge1JwY0Vycm9yfSBlcnJvciAtIEpTT04tUlBDIGVycm9yIG9iamVjdAogKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJyaWRlIC0gVXNlIFJQQ19FUlJPUlMgbWVzc2FnZSBpbiBwbGFjZSBvZiBwcm92aWRlciBtZXNzYWdlCiAqLwpmdW5jdGlvbiBzYW5pdGl6ZVJQQ0Vycm9yKGVycm9yLCBvdmVycmlkZSkgewogIGlmIChlcnJvci5tZXNzYWdlICYmICFvdmVycmlkZSkgewogICAgcmV0dXJuIGVycm9yOwogIH0KICB2YXIgbWVzc2FnZSA9IGVycm9yLmNvZGUgPiAtMzEwOTkgJiYgZXJyb3IuY29kZSA8IC0zMjEwMCA/IFJQQ19FUlJPUlMuaW50ZXJuYWwgOiBSUENfRVJST1JTW2Vycm9yLmNvZGVdOwogIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFJQQ19FUlJPUlMudW5rbm93bjsKfQoKLyoqCiAqIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIHRoYXQgYm90aCBsb2dzIHN0YW5kYXJkIGFuZCBub24tc3RhbmRhcmQgZXJyb3IKICogbWVzc2FnZXMgYW5kIGVuZHMgbWlkZGxld2FyZSBzdGFjayB0cmF2ZXJzYWwgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQKICoKICogQHBhcmFtIHtNaWRkbGV3YXJlQ29uZmlnfSBbY29uZmlnPXtvdmVycmlkZTp0cnVlfV0gLSBNaWRkbGV3YXJlIGNvbmZpZ3VyYXRpb24KICogQHJldHVybnMge0Z1bmN0aW9ufSBqc29uLXJwYy1lbmdpbmUgbWlkZGxld2FyZSBmdW5jdGlvbgogKi8KZnVuY3Rpb24gY3JlYXRlRXJyb3JNaWRkbGV3YXJlKCkgewogIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwKICAgICAgX3JlZiRvdmVycmlkZSA9IF9yZWYub3ZlcnJpZGUsCiAgICAgIG92ZXJyaWRlID0gX3JlZiRvdmVycmlkZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkb3ZlcnJpZGU7CgogIHJldHVybiBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHsKICAgIG5leHQoZnVuY3Rpb24gKGRvbmUpIHsKICAgICAgdmFyIGVycm9yID0gcmVzLmVycm9yOwoKICAgICAgaWYgKCFlcnJvcikgewogICAgICAgIHJldHVybiBkb25lKCk7CiAgICAgIH0KICAgICAgc2FuaXRpemVSUENFcnJvcihlcnJvcik7CiAgICAgIGxvZy5lcnJvcignTWV0YU1hc2sgLSBSUEMgRXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlLCBlcnJvcik7CiAgICB9KTsKICB9Owp9Cgptb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yTWlkZGxld2FyZTsKCgp9LHsiYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJsb2dsZXZlbCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fbG9nbGV2ZWxAMS42LjFAbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9hcHAvc2NyaXB0cy9saWIvaW5wYWdlLXByb3ZpZGVyLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBwdW1wID0gX2RlcmVxXygncHVtcCcpOwp2YXIgUnBjRW5naW5lID0gX2RlcmVxXygnanNvbi1ycGMtZW5naW5lJyk7CnZhciBjcmVhdGVFcnJvck1pZGRsZXdhcmUgPSBfZGVyZXFfKCcuL2NyZWF0ZUVycm9yTWlkZGxld2FyZScpOwp2YXIgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUgPSBfZGVyZXFfKCdqc29uLXJwYy1lbmdpbmUvc3JjL2lkUmVtYXBNaWRkbGV3YXJlJyk7CnZhciBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlID0gX2RlcmVxXygnanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0nKTsKdmFyIExvY2FsU3RvcmFnZVN0b3JlID0gX2RlcmVxXygnb2JzLXN0b3JlJyk7CnZhciBhc1N0cmVhbSA9IF9kZXJlcV8oJ29icy1zdG9yZS9saWIvYXNTdHJlYW0nKTsKdmFyIE9iamVjdE11bHRpcGxleCA9IF9kZXJlcV8oJ29iai1tdWx0aXBsZXgnKTsKCm1vZHVsZS5leHBvcnRzID0gTWV0YW1hc2tJbnBhZ2VQcm92aWRlcjsKCmZ1bmN0aW9uIE1ldGFtYXNrSW5wYWdlUHJvdmlkZXIoY29ubmVjdGlvblN0cmVhbSkgewogIHZhciBzZWxmID0gdGhpczsKCiAgLy8gc2V0dXAgY29ubmVjdGlvblN0cmVhbSBtdWx0aXBsZXhpbmcKICB2YXIgbXV4ID0gc2VsZi5tdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7CiAgcHVtcChjb25uZWN0aW9uU3RyZWFtLCBtdXgsIGNvbm5lY3Rpb25TdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHsKICAgIHJldHVybiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZygnTWV0YU1hc2snLCBlcnIpOwogIH0pOwoKICAvLyBzdWJzY3JpYmUgdG8gbWV0YW1hc2sgcHVibGljIGNvbmZpZyAob25lLXdheSkKICBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlID0gbmV3IExvY2FsU3RvcmFnZVN0b3JlKHsgc3RvcmFnZUtleTogJ01ldGFNYXNrLUNvbmZpZycgfSk7CgogIHB1bXAobXV4LmNyZWF0ZVN0cmVhbSgncHVibGljQ29uZmlnJyksIGFzU3RyZWFtKHNlbGYucHVibGljQ29uZmlnU3RvcmUpLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFB1YmxpY0NvbmZpZ1N0b3JlJywgZXJyKTsKICB9KTsKCiAgLy8gaWdub3JlIHBoaXNoaW5nIHdhcm5pbmcgbWVzc2FnZSAoaGFuZGxlZCBlbHNld2hlcmUpCiAgbXV4Lmlnbm9yZVN0cmVhbSgncGhpc2hpbmcnKTsKCiAgLy8gY29ubmVjdCB0byBhc3luYyBwcm92aWRlcgogIHZhciBzdHJlYW1NaWRkbGV3YXJlID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpOwogIHB1bXAoc3RyZWFtTWlkZGxld2FyZS5zdHJlYW0sIG11eC5jcmVhdGVTdHJlYW0oJ3Byb3ZpZGVyJyksIHN0cmVhbU1pZGRsZXdhcmUuc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFJwY1Byb3ZpZGVyJywgZXJyKTsKICB9KTsKCiAgLy8gaGFuZGxlIHNlbmRBc3luYyByZXF1ZXN0cyB2aWEgZGFwcC1zaWRlIHJwYyBlbmdpbmUKICB2YXIgcnBjRW5naW5lID0gbmV3IFJwY0VuZ2luZSgpOwogIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkpOwogIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUVycm9yTWlkZGxld2FyZSgpKTsKICBycGNFbmdpbmUucHVzaChzdHJlYW1NaWRkbGV3YXJlKTsKICBzZWxmLnJwY0VuZ2luZSA9IHJwY0VuZ2luZTsKfQoKLy8gaGFuZGxlIHNlbmRBc3luYyByZXF1ZXN0cyB2aWEgYXN5bmNQcm92aWRlcgovLyBhbHNvIHJlbWFwIGlkcyBpbmJvdW5kIGFuZCBvdXRib3VuZApNZXRhbWFza0lucGFnZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2IpIHsKICB2YXIgc2VsZiA9IHRoaXM7CiAgc2VsZi5ycGNFbmdpbmUuaGFuZGxlKHBheWxvYWQsIGNiKTsKfTsKCk1ldGFtYXNrSW5wYWdlUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGF5bG9hZCkgewogIHZhciBzZWxmID0gdGhpczsKCiAgdmFyIHNlbGVjdGVkQWRkcmVzcyA9IHZvaWQgMDsKICB2YXIgcmVzdWx0ID0gbnVsbDsKICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7CgogICAgY2FzZSAnZXRoX2FjY291bnRzJzoKICAgICAgLy8gcmVhZCBmcm9tIGxvY2FsU3RvcmFnZQogICAgICBzZWxlY3RlZEFkZHJlc3MgPSBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlLmdldFN0YXRlKCkuc2VsZWN0ZWRBZGRyZXNzOwogICAgICByZXN1bHQgPSBzZWxlY3RlZEFkZHJlc3MgPyBbc2VsZWN0ZWRBZGRyZXNzXSA6IFtdOwogICAgICBicmVhazsKCiAgICBjYXNlICdldGhfY29pbmJhc2UnOgogICAgICAvLyByZWFkIGZyb20gbG9jYWxTdG9yYWdlCiAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IHNlbGYucHVibGljQ29uZmlnU3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7CiAgICAgIHJlc3VsdCA9IHNlbGVjdGVkQWRkcmVzcyB8fCBudWxsOwogICAgICBicmVhazsKCiAgICBjYXNlICdldGhfdW5pbnN0YWxsRmlsdGVyJzoKICAgICAgc2VsZi5zZW5kQXN5bmMocGF5bG9hZCwgbm9vcCk7CiAgICAgIHJlc3VsdCA9IHRydWU7CiAgICAgIGJyZWFrOwoKICAgIGNhc2UgJ25ldF92ZXJzaW9uJzoKICAgICAgdmFyIG5ldHdvcmtWZXJzaW9uID0gc2VsZi5wdWJsaWNDb25maWdTdG9yZS5nZXRTdGF0ZSgpLm5ldHdvcmtWZXJzaW9uOwogICAgICByZXN1bHQgPSBuZXR3b3JrVmVyc2lvbiB8fCBudWxsOwogICAgICBicmVhazsKCiAgICAvLyB0aHJvdyBub3Qtc3VwcG9ydGVkIEVycm9yCiAgICBkZWZhdWx0OgogICAgICB2YXIgbGluayA9ICdodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svZmFxL2Jsb2IvbWFzdGVyL0RFVkVMT1BFUlMubWQjZGl6enktYWxsLWFzeW5jLS0tdGhpbmstb2YtbWV0YW1hc2stYXMtYS1saWdodC1jbGllbnQnOwogICAgICB2YXIgbWVzc2FnZSA9ICdUaGUgTWV0YU1hc2sgV2ViMyBvYmplY3QgZG9lcyBub3Qgc3VwcG9ydCBzeW5jaHJvbm91cyBtZXRob2RzIGxpa2UgJyArIHBheWxvYWQubWV0aG9kICsgJyB3aXRob3V0IGEgY2FsbGJhY2sgcGFyYW1ldGVyLiBTZWUgJyArIGxpbmsgKyAnIGZvciBkZXRhaWxzLic7CiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTsKCiAgfQoKICAvLyByZXR1cm4gdGhlIHJlc3VsdAogIHJldHVybiB7CiAgICBpZDogcGF5bG9hZC5pZCwKICAgIGpzb25ycGM6IHBheWxvYWQuanNvbnJwYywKICAgIHJlc3VsdDogcmVzdWx0CiAgfTsKfTsKCk1ldGFtYXNrSW5wYWdlUHJvdmlkZXIucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkgewogIHJldHVybiB0cnVlOwp9OwoKTWV0YW1hc2tJbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuaXNNZXRhTWFzayA9IHRydWU7CgovLyB1dGlsCgpmdW5jdGlvbiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyhyZW1vdGVMYWJlbCwgZXJyKSB7CiAgdmFyIHdhcm5pbmdNc2cgPSAnTWV0YW1hc2tJbnBhZ2VQcm92aWRlciAtIGxvc3QgY29ubmVjdGlvbiB0byAnICsgcmVtb3RlTGFiZWw7CiAgaWYgKGVycikgd2FybmluZ01zZyArPSAnXG4nICsgZXJyLnN0YWNrOwogIGNvbnNvbGUud2Fybih3YXJuaW5nTXNnKTsKfQoKZnVuY3Rpb24gbm9vcCgpIHt9CgoKfSx7Ii4vY3JlYXRlRXJyb3JNaWRkbGV3YXJlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svYXBwL3NjcmlwdHMvbGliL2NyZWF0ZUVycm9yTWlkZGxld2FyZS5qcyIsImpzb24tcnBjLWVuZ2luZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fanNvbi1ycGMtZW5naW5lQDMuNy4zQGpzb24tcnBjLWVuZ2luZS9zcmMvaW5kZXguanMiLCJqc29uLXJwYy1lbmdpbmUvc3JjL2lkUmVtYXBNaWRkbGV3YXJlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19qc29uLXJwYy1lbmdpbmVAMy43LjNAanNvbi1ycGMtZW5naW5lL3NyYy9pZFJlbWFwTWlkZGxld2FyZS5qcyIsImpzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19qc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbUAxLjAuMUBqc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbS9pbmRleC5qcyIsIm9iai1tdWx0aXBsZXgiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX29iai1tdWx0aXBsZXhAMS4wLjBAb2JqLW11bHRpcGxleC9pbmRleC5qcyIsIm9icy1zdG9yZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fb2JzLXN0b3JlQDMuMC4wQG9icy1zdG9yZS9pbmRleC5qcyIsIm9icy1zdG9yZS9saWIvYXNTdHJlYW0iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX29icy1zdG9yZUAzLjAuMEBvYnMtc3RvcmUvbGliL2FzU3RyZWFtLmpzIiwicHVtcCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcHVtcEAzLjAuMEBwdW1wL2luZGV4LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2FzeW5jQDIuNi4xQGFzeW5jL2Rpc3QvYXN5bmMuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxzZXRJbW1lZGlhdGUpewooZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkgewogIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOgogIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOgogIChmYWN0b3J5KChnbG9iYWwuYXN5bmMgPSBnbG9iYWwuYXN5bmMgfHwge30pKSk7Cn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JzsKCmZ1bmN0aW9uIHNsaWNlKGFycmF5TGlrZSwgc3RhcnQpIHsKICAgIHN0YXJ0ID0gc3RhcnR8MDsKICAgIHZhciBuZXdMZW4gPSBNYXRoLm1heChhcnJheUxpa2UubGVuZ3RoIC0gc3RhcnQsIDApOwogICAgdmFyIG5ld0FyciA9IEFycmF5KG5ld0xlbik7CiAgICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IG5ld0xlbjsgaWR4KyspICB7CiAgICAgICAgbmV3QXJyW2lkeF0gPSBhcnJheUxpa2Vbc3RhcnQgKyBpZHhdOwogICAgfQogICAgcmV0dXJuIG5ld0FycjsKfQoKLyoqCiAqIENyZWF0ZXMgYSBjb250aW51YXRpb24gZnVuY3Rpb24gd2l0aCBzb21lIGFyZ3VtZW50cyBhbHJlYWR5IGFwcGxpZWQuCiAqCiAqIFVzZWZ1bCBhcyBhIHNob3J0aGFuZCB3aGVuIGNvbWJpbmVkIHdpdGggb3RoZXIgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4gQW55CiAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIGFyZSBhZGRlZCB0byB0aGUgYXJndW1lbnRzCiAqIG9yaWdpbmFsbHkgcGFzc2VkIHRvIGFwcGx5LgogKgogKiBAbmFtZSBhcHBseQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5IGFsbAogKiBhcmd1bWVudHMgdG8uIEludm9rZXMgd2l0aCAoYXJndW1lbnRzLi4uKS4KICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhdXRvbWF0aWNhbGx5IGFwcGx5CiAqIHdoZW4gdGhlIGNvbnRpbnVhdGlvbiBpcyBjYWxsZWQuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdGhlIHBhcnRpYWxseS1hcHBsaWVkIGZ1bmN0aW9uCiAqIEBleGFtcGxlCiAqCiAqIC8vIHVzaW5nIGFwcGx5CiAqIGFzeW5jLnBhcmFsbGVsKFsKICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMScsICd0ZXN0MScpLAogKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUyJywgJ3Rlc3QyJykKICogXSk7CiAqCiAqCiAqIC8vIHRoZSBzYW1lIHByb2Nlc3Mgd2l0aG91dCB1c2luZyBhcHBseQogKiBhc3luYy5wYXJhbGxlbChbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGZzLndyaXRlRmlsZSgndGVzdGZpbGUxJywgJ3Rlc3QxJywgY2FsbGJhY2spOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTInLCAndGVzdDInLCBjYWxsYmFjayk7CiAqICAgICB9CiAqIF0pOwogKgogKiAvLyBJdCdzIHBvc3NpYmxlIHRvIHBhc3MgYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgdGhlCiAqIC8vIGNvbnRpbnVhdGlvbjoKICoKICogbm9kZT4gdmFyIGZuID0gYXN5bmMuYXBwbHkoc3lzLnB1dHMsICdvbmUnKTsKICogbm9kZT4gZm4oJ3R3bycsICd0aHJlZScpOwogKiBvbmUKICogdHdvCiAqIHRocmVlCiAqLwp2YXIgYXBwbHkgPSBmdW5jdGlvbihmbi8qLCAuLi5hcmdzKi8pIHsKICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgIHJldHVybiBmdW5jdGlvbigvKmNhbGxBcmdzKi8pIHsKICAgICAgICB2YXIgY2FsbEFyZ3MgPSBzbGljZShhcmd1bWVudHMpOwogICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChjYWxsQXJncykpOwogICAgfTsKfTsKCnZhciBpbml0aWFsUGFyYW1zID0gZnVuY3Rpb24gKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uYXJncywgY2FsbGJhY2sqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTsKICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpOwogICAgICAgIGZuLmNhbGwodGhpcywgYXJncywgY2FsbGJhY2spOwogICAgfTsKfTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUKICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKQogKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDAuMS4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc09iamVjdCh7fSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc09iamVjdChbMSwgMiwgM10pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNPYmplY3QoXy5ub29wKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzT2JqZWN0KG51bGwpOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHsKICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTsKICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpOwp9Cgp2YXIgaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7CnZhciBoYXNOZXh0VGljayA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJzsKCmZ1bmN0aW9uIGZhbGxiYWNrKGZuKSB7CiAgICBzZXRUaW1lb3V0KGZuLCAwKTsKfQoKZnVuY3Rpb24gd3JhcChkZWZlcikgewogICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgZGVmZXIoZnVuY3Rpb24gKCkgewogICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTsKICAgICAgICB9KTsKICAgIH07Cn0KCnZhciBfZGVmZXI7CgppZiAoaGFzU2V0SW1tZWRpYXRlKSB7CiAgICBfZGVmZXIgPSBzZXRJbW1lZGlhdGU7Cn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHsKICAgIF9kZWZlciA9IHByb2Nlc3MubmV4dFRpY2s7Cn0gZWxzZSB7CiAgICBfZGVmZXIgPSBmYWxsYmFjazsKfQoKdmFyIHNldEltbWVkaWF0ZSQxID0gd3JhcChfZGVmZXIpOwoKLyoqCiAqIFRha2UgYSBzeW5jIGZ1bmN0aW9uIGFuZCBtYWtlIGl0IGFzeW5jLCBwYXNzaW5nIGl0cyByZXR1cm4gdmFsdWUgdG8gYQogKiBjYWxsYmFjay4gVGhpcyBpcyB1c2VmdWwgZm9yIHBsdWdnaW5nIHN5bmMgZnVuY3Rpb25zIGludG8gYSB3YXRlcmZhbGwsCiAqIHNlcmllcywgb3Igb3RoZXIgYXN5bmMgZnVuY3Rpb25zLiBBbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZ2VuZXJhdGVkCiAqIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIChleGNlcHQgZm9yIHRoZSBmaW5hbAogKiBjYWxsYmFjayBhcmd1bWVudCkuIEVycm9ycyB0aHJvd24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLgogKgogKiBJZiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGBhc3luY2lmeWAgcmV0dXJucyBhIFByb21pc2UsIHRoYXQgcHJvbWlzZXMncwogKiByZXNvbHZlZC9yZWplY3RlZCBzdGF0ZSB3aWxsIGJlIHVzZWQgdG8gY2FsbCB0aGUgY2FsbGJhY2ssIHJhdGhlciB0aGFuIHNpbXBseQogKiB0aGUgc3luY2hyb25vdXMgcmV0dXJuIHZhbHVlLgogKgogKiBUaGlzIGFsc28gbWVhbnMgeW91IGNhbiBhc3luY2lmeSBFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbnMuCiAqCiAqIEBuYW1lIGFzeW5jaWZ5CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBhbGlhcyB3cmFwU3luYwogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIC0gVGhlIHN5bmNocm9ub3VzIGZ1bmN0aW9uLCBvciBQcm9taXNlLXJldHVybmluZwogKiBmdW5jdGlvbiB0byBjb252ZXJ0IHRvIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufS4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IEFuIGFzeW5jaHJvbm91cyB3cmFwcGVyIG9mIHRoZSBgZnVuY2AuIFRvIGJlCiAqIGludm9rZWQgd2l0aCBgKGFyZ3MuLi4sIGNhbGxiYWNrKWAuCiAqIEBleGFtcGxlCiAqCiAqIC8vIHBhc3NpbmcgYSByZWd1bGFyIHN5bmNocm9ub3VzIGZ1bmN0aW9uCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsICJ1dGY4IiksCiAqICAgICBhc3luYy5hc3luY2lmeShKU09OLnBhcnNlKSwKICogICAgIGZ1bmN0aW9uIChkYXRhLCBuZXh0KSB7CiAqICAgICAgICAgLy8gZGF0YSBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIHRleHQuCiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGFyc2luZyBlcnJvciwgaXQgd291bGQgaGF2ZSBiZWVuIGNhdWdodC4KICogICAgIH0KICogXSwgY2FsbGJhY2spOwogKgogKiAvLyBwYXNzaW5nIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZQogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCAidXRmOCIpLAogKiAgICAgYXN5bmMuYXN5bmNpZnkoZnVuY3Rpb24gKGNvbnRlbnRzKSB7CiAqICAgICAgICAgcmV0dXJuIGRiLm1vZGVsLmNyZWF0ZShjb250ZW50cyk7CiAqICAgICB9KSwKICogICAgIGZ1bmN0aW9uIChtb2RlbCwgbmV4dCkgewogKiAgICAgICAgIC8vIGBtb2RlbGAgaXMgdGhlIGluc3RhbnRpYXRlZCBtb2RlbCBvYmplY3QuCiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yLCB0aGlzIGZ1bmN0aW9uIHdvdWxkIGJlIHNraXBwZWQuCiAqICAgICB9CiAqIF0sIGNhbGxiYWNrKTsKICoKICogLy8gZXMyMDE3IGV4YW1wbGUsIHRob3VnaCBgYXN5bmNpZnlgIGlzIG5vdCBuZWVkZWQgaWYgeW91ciBKUyBlbnZpcm9ubWVudAogKiAvLyBzdXBwb3J0cyBhc3luYyBmdW5jdGlvbnMgb3V0IG9mIHRoZSBib3gKICogdmFyIHEgPSBhc3luYy5xdWV1ZShhc3luYy5hc3luY2lmeShhc3luYyBmdW5jdGlvbihmaWxlKSB7CiAqICAgICB2YXIgaW50ZXJtZWRpYXRlU3RlcCA9IGF3YWl0IHByb2Nlc3NGaWxlKGZpbGUpOwogKiAgICAgcmV0dXJuIGF3YWl0IHNvbWVQcm9taXNlKGludGVybWVkaWF0ZVN0ZXApCiAqIH0pKTsKICoKICogcS5wdXNoKGZpbGVzKTsKICovCmZ1bmN0aW9uIGFzeW5jaWZ5KGZ1bmMpIHsKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIHZhciByZXN1bHQ7CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTsKICAgICAgICB9CiAgICAgICAgLy8gaWYgcmVzdWx0IGlzIFByb21pc2Ugb2JqZWN0CiAgICAgICAgaWYgKGlzT2JqZWN0KHJlc3VsdCkgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgbnVsbCwgdmFsdWUpOwogICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIubWVzc2FnZSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTsKICAgICAgICB9CiAgICB9KTsKfQoKZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVycm9yLCB2YWx1ZSkgewogICAgdHJ5IHsKICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpOwogICAgfSBjYXRjaCAoZSkgewogICAgICAgIHNldEltbWVkaWF0ZSQxKHJldGhyb3csIGUpOwogICAgfQp9CgpmdW5jdGlvbiByZXRocm93KGVycm9yKSB7CiAgICB0aHJvdyBlcnJvcjsKfQoKdmFyIHN1cHBvcnRzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJzsKCmZ1bmN0aW9uIGlzQXN5bmMoZm4pIHsKICAgIHJldHVybiBzdXBwb3J0c1N5bWJvbCAmJiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNGdW5jdGlvbic7Cn0KCmZ1bmN0aW9uIHdyYXBBc3luYyhhc3luY0ZuKSB7CiAgICByZXR1cm4gaXNBc3luYyhhc3luY0ZuKSA/IGFzeW5jaWZ5KGFzeW5jRm4pIDogYXN5bmNGbjsKfQoKZnVuY3Rpb24gYXBwbHlFYWNoJDEoZWFjaGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oZm5zLyosIC4uLmFyZ3MqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICB2YXIgZ28gPSBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uKGFyZ3MsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpczsKICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHsKICAgICAgICAgICAgICAgIHdyYXBBc3luYyhmbikuYXBwbHkodGhhdCwgYXJncy5jb25jYXQoY2IpKTsKICAgICAgICAgICAgfSwgY2FsbGJhY2spOwogICAgICAgIH0pOwogICAgICAgIGlmIChhcmdzLmxlbmd0aCkgewogICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7CiAgICAgICAgfQogICAgICAgIGVsc2UgewogICAgICAgICAgICByZXR1cm4gZ287CiAgICAgICAgfQogICAgfTsKfQoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi8KdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsOwoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi8KdmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7CgovKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi8KdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIFN5bWJvbCQxID0gcm9vdC5TeW1ib2w7CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7CgovKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi8KdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7CgovKioKICogVXNlZCB0byByZXNvbHZlIHRoZQogKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZykKICogb2YgdmFsdWVzLgogKi8KdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIHN5bVRvU3RyaW5nVGFnJDEgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkOwoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LgogKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC4KICovCmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkgewogIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLAogICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTsKCiAgdHJ5IHsKICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdW5kZWZpbmVkOwogICAgdmFyIHVubWFza2VkID0gdHJ1ZTsKICB9IGNhdGNoIChlKSB7fQoKICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7CiAgaWYgKHVubWFza2VkKSB7CiAgICBpZiAoaXNPd24pIHsKICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB0YWc7CiAgICB9IGVsc2UgewogICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07CiAgICB9CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlOwoKLyoqCiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUKICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpCiAqIG9mIHZhbHVlcy4KICovCnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyQxID0gb2JqZWN0UHJvdG8kMS50b1N0cmluZzsKCi8qKgogKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy4KICovCmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7CiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7Cn0KCi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi8KdmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXSc7CnZhciB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJzsKCi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqLwp2YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LgogKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLgogKi8KZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkgewogIGlmICh2YWx1ZSA9PSBudWxsKSB7CiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7CiAgfQogIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSkKICAgID8gZ2V0UmF3VGFnKHZhbHVlKQogICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7Cn0KCi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi8KdmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nOwp2YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7CnZhciBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nOwp2YXIgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMC4xLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0Z1bmN0aW9uKF8pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7CiAqIC8vID0+IGZhbHNlCiAqLwpmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7CiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHsKICAgIHJldHVybiBmYWxzZTsKICB9CiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yCiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuCiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpOwogIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7Cn0KCi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqLwp2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC4KICoKICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24KICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNMZW5ndGgoMyk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTsKICogLy8gPT4gZmFsc2UKICoKICogXy5pc0xlbmd0aChJbmZpbml0eSk7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNMZW5ndGgoJzMnKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7CiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJgogICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSOwp9CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQncwogKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yCiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDQuMC4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7Cn0KCi8vIEEgdGVtcG9yYXJ5IHZhbHVlIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGxvb3Agc2hvdWxkIGJlIGJyb2tlbi4KLy8gU2VlICMxMDY0LCAjMTI5Mwp2YXIgYnJlYWtMb29wID0ge307CgovKioKICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMi4zLjAKICogQGNhdGVnb3J5IFV0aWwKICogQGV4YW1wbGUKICoKICogXy50aW1lcygyLCBfLm5vb3ApOwogKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdCiAqLwpmdW5jdGlvbiBub29wKCkgewogIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuCn0KCmZ1bmN0aW9uIG9uY2UoZm4pIHsKICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgaWYgKGZuID09PSBudWxsKSByZXR1cm47CiAgICAgICAgdmFyIGNhbGxGbiA9IGZuOwogICAgICAgIGZuID0gbnVsbDsKICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH07Cn0KCnZhciBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yOwoKdmFyIGdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGNvbGwpIHsKICAgIHJldHVybiBpdGVyYXRvclN5bWJvbCAmJiBjb2xsW2l0ZXJhdG9yU3ltYm9sXSAmJiBjb2xsW2l0ZXJhdG9yU3ltYm9sXSgpOwp9OwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMKICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy4KICovCmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkgewogIHZhciBpbmRleCA9IC0xLAogICAgICByZXN1bHQgPSBBcnJheShuKTsKCiAgd2hpbGUgKCsraW5kZXggPCBuKSB7CiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgCiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgIm9iamVjdCIuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDQuMC4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzT2JqZWN0TGlrZSh7fSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApOwogKiAvLyA9PiBmYWxzZQogKgogKiBfLmlzT2JqZWN0TGlrZShudWxsKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkgewogIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JzsKfQoKLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqLwp2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwKICovCmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkgewogIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7Cn0KCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlOwoKLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovCnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMy5oYXNPd25Qcm9wZXJ0eTsKCi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqLwp2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQzLnByb3BlcnR5SXNFbnVtZXJhYmxlOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDAuMS4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsCiAqICBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pOwogKiAvLyA9PiBmYWxzZQogKi8KdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHsKICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJgogICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTsKfTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAwLjEuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0FycmF5KFsxLCAyLCAzXSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pOwogKiAvLyA9PiBmYWxzZQogKgogKiBfLmlzQXJyYXkoJ2FiYycpOwogKiAvLyA9PiBmYWxzZQogKgogKiBfLmlzQXJyYXkoXy5ub29wKTsKICogLy8gPT4gZmFsc2UKICovCnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTsKCi8qKgogKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDQuMTMuMAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTsKICogLy8gPT4gW2ZhbHNlLCBmYWxzZV0KICovCmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHsKICByZXR1cm4gZmFsc2U7Cn0KCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovCnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi8KdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTsKCi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovCnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzOwoKLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovCnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7CgovKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovCnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4zLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7CiAqIC8vID0+IGZhbHNlCiAqLwp2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7CgovKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi8KdmFyIE1BWF9TQUZFX0lOVEVHRVIkMSA9IDkwMDcxOTkyNTQ3NDA5OTE7CgovKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovCnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxkKikkLzsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC4KICovCmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkgewogIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiQxIDogbGVuZ3RoOwoKICByZXR1cm4gISFsZW5ndGggJiYKICAgICh0eXBlID09ICdudW1iZXInIHx8CiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiYKICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7Cn0KCi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi8KdmFyIGFyZ3NUYWckMSA9ICdbb2JqZWN0IEFyZ3VtZW50c10nOwp2YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nOwp2YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJzsKdmFyIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXSc7CnZhciBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXSc7CnZhciBmdW5jVGFnJDEgPSAnW29iamVjdCBGdW5jdGlvbl0nOwp2YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7CnZhciBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJzsKdmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nOwp2YXIgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7CnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJzsKdmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nOwp2YXIgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJzsKCnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7CnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7CnZhciBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc7CnZhciBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7CnZhciBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XSc7CnZhciBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJzsKdmFyIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nOwp2YXIgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XSc7CnZhciB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOwp2YXIgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJzsKdmFyIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7CgovKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovCnZhciB0eXBlZEFycmF5VGFncyA9IHt9Owp0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID0KdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPQp0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPQp0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9CnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlOwp0eXBlZEFycmF5VGFnc1thcmdzVGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0KdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPQp0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9CnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWckMV0gPQp0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9CnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0KdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPQp0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuCiAqLwpmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7CiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYKICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci4KICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHsKICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHsKICAgIHJldHVybiBmdW5jKHZhbHVlKTsKICB9Owp9CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqLwp2YXIgZnJlZUV4cG9ydHMkMSA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi8KdmFyIGZyZWVNb2R1bGUkMSA9IGZyZWVFeHBvcnRzJDEgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CgovKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqLwp2YXIgbW9kdWxlRXhwb3J0cyQxID0gZnJlZU1vZHVsZSQxICYmIGZyZWVNb2R1bGUkMS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyQxOwoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovCnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMkMSAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7CgovKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi8KdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkgewogIHRyeSB7CiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy4KICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSAmJiBmcmVlTW9kdWxlJDEucmVxdWlyZSgndXRpbCcpLnR5cGVzOwoKICAgIGlmICh0eXBlcykgewogICAgICByZXR1cm4gdHlwZXM7CiAgICB9CgogICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC4KICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTsKICB9IGNhdGNoIChlKSB7fQp9KCkpOwoKLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi8KdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAzLjAuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc1R5cGVkQXJyYXkoW10pOwogKiAvLyA9PiBmYWxzZQogKi8KdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5OwoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7CgovKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi8KdmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90byQyLmhhc093blByb3BlcnR5OwoKLyoqCiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuCiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4KICovCmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkgewogIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLAogICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksCiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLAogICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSwKICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLAogICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSwKICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDsKCiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7CiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwodmFsdWUsIGtleSkpICYmCiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoCiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLgogICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fAogICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLgogICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fAogICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy4KICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHwKICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuCiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aCkKICAgICAgICApKSkgewogICAgICByZXN1bHQucHVzaChrZXkpOwogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byQ1ID0gT2JqZWN0LnByb3RvdHlwZTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC4KICovCmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7CiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciwKICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG8kNTsKCiAgcmV0dXJuIHZhbHVlID09PSBwcm90bzsKfQoKLyoqCiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS4KICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uCiAqLwpmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkgewogIHJldHVybiBmdW5jdGlvbihhcmcpIHsKICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTsKICB9Owp9CgovKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovCnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTsKCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvJDQgPSBPYmplY3QucHJvdG90eXBlOwoKLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovCnZhciBoYXNPd25Qcm9wZXJ0eSQzID0gb2JqZWN0UHJvdG8kNC5oYXNPd25Qcm9wZXJ0eTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4KICovCmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkgewogIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkgewogICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTsKICB9CiAgdmFyIHJlc3VsdCA9IFtdOwogIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkgewogICAgaWYgKGhhc093blByb3BlcnR5JDMuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHsKICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqCiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLgogKgogKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZQogKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpCiAqIGZvciBtb3JlIGRldGFpbHMuCiAqCiAqIEBzdGF0aWMKICogQHNpbmNlIDAuMS4wCiAqIEBtZW1iZXJPZiBfCiAqIEBjYXRlZ29yeSBPYmplY3QKICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLgogKiBAZXhhbXBsZQogKgogKiBmdW5jdGlvbiBGb28oKSB7CiAqICAgdGhpcy5hID0gMTsKICogICB0aGlzLmIgPSAyOwogKiB9CiAqCiAqIEZvby5wcm90b3R5cGUuYyA9IDM7CiAqCiAqIF8ua2V5cyhuZXcgRm9vKTsKICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKQogKgogKiBfLmtleXMoJ2hpJyk7CiAqIC8vID0+IFsnMCcsICcxJ10KICovCmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7CiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpOwp9CgpmdW5jdGlvbiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpIHsKICAgIHZhciBpID0gLTE7CiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7CiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICByZXR1cm4gKytpIDwgbGVuID8ge3ZhbHVlOiBjb2xsW2ldLCBrZXk6IGl9IDogbnVsbDsKICAgIH0KfQoKZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHsKICAgIHZhciBpID0gLTE7CiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTsKICAgICAgICBpZiAoaXRlbS5kb25lKQogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICBpKys7CiAgICAgICAgcmV0dXJuIHt2YWx1ZTogaXRlbS52YWx1ZSwga2V5OiBpfTsKICAgIH0KfQoKZnVuY3Rpb24gY3JlYXRlT2JqZWN0SXRlcmF0b3Iob2JqKSB7CiAgICB2YXIgb2tleXMgPSBrZXlzKG9iaik7CiAgICB2YXIgaSA9IC0xOwogICAgdmFyIGxlbiA9IG9rZXlzLmxlbmd0aDsKICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkgewogICAgICAgIHZhciBrZXkgPSBva2V5c1srK2ldOwogICAgICAgIHJldHVybiBpIDwgbGVuID8ge3ZhbHVlOiBvYmpba2V5XSwga2V5OiBrZXl9IDogbnVsbDsKICAgIH07Cn0KCmZ1bmN0aW9uIGl0ZXJhdG9yKGNvbGwpIHsKICAgIGlmIChpc0FycmF5TGlrZShjb2xsKSkgewogICAgICAgIHJldHVybiBjcmVhdGVBcnJheUl0ZXJhdG9yKGNvbGwpOwogICAgfQoKICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGwpOwogICAgcmV0dXJuIGl0ZXJhdG9yID8gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIDogY3JlYXRlT2JqZWN0SXRlcmF0b3IoY29sbCk7Cn0KCmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKGZuID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC4iKTsKICAgICAgICB2YXIgY2FsbEZuID0gZm47CiAgICAgICAgZm4gPSBudWxsOwogICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfTsKfQoKZnVuY3Rpb24gX2VhY2hPZkxpbWl0KGxpbWl0KSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICAgICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgICAgIGlmIChsaW1pdCA8PSAwIHx8ICFvYmopIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgICAgIH0KICAgICAgICB2YXIgbmV4dEVsZW0gPSBpdGVyYXRvcihvYmopOwogICAgICAgIHZhciBkb25lID0gZmFsc2U7CiAgICAgICAgdmFyIHJ1bm5pbmcgPSAwOwogICAgICAgIHZhciBsb29waW5nID0gZmFsc2U7CgogICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVlQ2FsbGJhY2soZXJyLCB2YWx1ZSkgewogICAgICAgICAgICBydW5uaW5nIC09IDE7CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlOwogICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gYnJlYWtMb29wIHx8IChkb25lICYmIHJ1bm5pbmcgPD0gMCkpIHsKICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlOwogICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKCFsb29waW5nKSB7CiAgICAgICAgICAgICAgICByZXBsZW5pc2goKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gcmVwbGVuaXNoICgpIHsKICAgICAgICAgICAgbG9vcGluZyA9IHRydWU7CiAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHsKICAgICAgICAgICAgICAgIHZhciBlbGVtID0gbmV4dEVsZW0oKTsKICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcnVubmluZyArPSAxOwogICAgICAgICAgICAgICAgaXRlcmF0ZWUoZWxlbS52YWx1ZSwgZWxlbS5rZXksIG9ubHlPbmNlKGl0ZXJhdGVlQ2FsbGJhY2spKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBsb29waW5nID0gZmFsc2U7CiAgICAgICAgfQoKICAgICAgICByZXBsZW5pc2goKTsKICAgIH07Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSBlYWNoT2ZMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9CiAqIEBhbGlhcyBmb3JFYWNoT2ZMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2gKICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW4KICogYXJyYXkuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spOwp9CgpmdW5jdGlvbiBkb0xpbWl0KGZuLCBsaW1pdCkgewogICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIGZuKGl0ZXJhYmxlLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTsKICAgIH07Cn0KCi8vIGVhY2hPZiBpbXBsZW1lbnRhdGlvbiBvcHRpbWl6ZWQgZm9yIGFycmF5LWxpa2VzCmZ1bmN0aW9uIGVhY2hPZkFycmF5TGlrZShjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBpbmRleCA9IDAsCiAgICAgICAgY29tcGxldGVkID0gMCwKICAgICAgICBsZW5ndGggPSBjb2xsLmxlbmd0aDsKICAgIGlmIChsZW5ndGggPT09IDApIHsKICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRvckNhbGxiYWNrKGVyciwgdmFsdWUpIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgfSBlbHNlIGlmICgoKytjb21wbGV0ZWQgPT09IGxlbmd0aCkgfHwgdmFsdWUgPT09IGJyZWFrTG9vcCkgewogICAgICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgICB9CiAgICB9CgogICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgaXRlcmF0ZWUoY29sbFtpbmRleF0sIGluZGV4LCBvbmx5T25jZShpdGVyYXRvckNhbGxiYWNrKSk7CiAgICB9Cn0KCi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy4KdmFyIGVhY2hPZkdlbmVyaWMgPSBkb0xpbWl0KGVhY2hPZkxpbWl0LCBJbmZpbml0eSk7CgovKioKICogTGlrZSBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0sIGV4Y2VwdCB0aGF0IGl0IHBhc3NlcyB0aGUga2V5IChvciBpbmRleCkgYXMgdGhlIHNlY29uZCBhcmd1bWVudAogKiB0byB0aGUgaXRlcmF0ZWUuCiAqCiAqIEBuYW1lIGVhY2hPZgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgZm9yRWFjaE9mCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofQogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2gKICogaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXkuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICogQGV4YW1wbGUKICoKICogdmFyIG9iaiA9IHtkZXY6ICIvZGV2Lmpzb24iLCB0ZXN0OiAiL3Rlc3QuanNvbiIsIHByb2Q6ICIvcHJvZC5qc29uIn07CiAqIHZhciBjb25maWdzID0ge307CiAqCiAqIGFzeW5jLmZvckVhY2hPZihvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBjYWxsYmFjaykgewogKiAgICAgZnMucmVhZEZpbGUoX19kaXJuYW1lICsgdmFsdWUsICJ1dGY4IiwgZnVuY3Rpb24gKGVyciwgZGF0YSkgewogKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogKiAgICAgICAgIHRyeSB7CiAqICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XSA9IEpTT04ucGFyc2UoZGF0YSk7CiAqICAgICAgICAgfSBjYXRjaCAoZSkgewogKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAqICAgICAgICAgfQogKiAgICAgICAgIGNhbGxiYWNrKCk7CiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24gKGVycikgewogKiAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7CiAqICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGEKICogICAgIGRvU29tZXRoaW5nV2l0aChjb25maWdzKTsKICogfSk7CiAqLwp2YXIgZWFjaE9mID0gZnVuY3Rpb24oY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSBpc0FycmF5TGlrZShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7CiAgICBlYWNoT2ZJbXBsZW1lbnRhdGlvbihjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7Cn07CgpmdW5jdGlvbiBkb1BhcmFsbGVsKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIGZuKGVhY2hPZiwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7CiAgICB9Owp9CgpmdW5jdGlvbiBfYXN5bmNNYXAoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wOwogICAgYXJyID0gYXJyIHx8IFtdOwogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIHZhciBjb3VudGVyID0gMDsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwoKICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgXywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7CiAgICAgICAgX2l0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7CiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpOwogICAgfSk7Cn0KCi8qKgogKiBQcm9kdWNlcyBhIG5ldyBjb2xsZWN0aW9uIG9mIHZhbHVlcyBieSBtYXBwaW5nIGVhY2ggdmFsdWUgaW4gYGNvbGxgIHRocm91Z2gKICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGAKICogYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcuIEVhY2ggb2YgdGhlc2UgY2FsbGJhY2sKICogdGFrZXMgMiBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBjb2xsYC4gSWYKICogYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlCiAqIGBtYXBgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuCiAqCiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbgogKiBwYXJhbGxlbCwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUKICogaW4gb3JkZXIuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlCiAqIG9yaWdpbmFsIGBjb2xsYC4KICoKICogSWYgYG1hcGAgaXMgcGFzc2VkIGFuIE9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBhbiBBcnJheS4gIFRoZSByZXN1bHRzCiAqIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhbgogKiB2YXJ5IGFjcm9zcyBKYXZhU2NyaXB0IGVuZ2luZXMpLgogKgogKiBAbmFtZSBtYXAKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBBcnJheSBvZiB0aGUKICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLm1hcChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmcy5zdGF0LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHN0YXRzIGZvciBlYWNoIGZpbGUKICogfSk7CiAqLwp2YXIgbWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApOwoKLyoqCiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyB0byBlYWNoIGZ1bmN0aW9uIGluIHRoZSBhcnJheSwgY2FsbGluZwogKiBgY2FsbGJhY2tgIGFmdGVyIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIElmIHlvdSBvbmx5IHByb3ZpZGUgdGhlIGZpcnN0CiAqIGFyZ3VtZW50LCBgZm5zYCwgdGhlbiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlCiAqIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwuIElmIG1vcmUgYXJndW1lbnRzIGFyZQogKiBwcm92aWRlZCwgYGNhbGxiYWNrYCBpcyByZXF1aXJlZCB3aGlsZSBgYXJnc2AgaXMgc3RpbGwgb3B0aW9uYWwuCiAqCiAqIEBuYW1lIGFwcGx5RWFjaAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259cwogKiB0byBhbGwgY2FsbCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cwogKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIGFueSBudW1iZXIgb2Ygc2VwYXJhdGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlCiAqIGZ1bmN0aW9uLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gdGhlIGZpbmFsIGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgY2FsbGJhY2ssCiAqIGNhbGxlZCB3aGVuIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgcHJvY2Vzc2luZy4KICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50LCBgZm5zYCwgaXMgcHJvdmlkZWQsIGl0IHdpbGwKICogcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGUgYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUKICogZnVuY3Rpb24gY2FsbC4gVGhlIHNpZ25hdHVyZSBpcyBgKC4uYXJncywgY2FsbGJhY2spYC4gSWYgaW52b2tlZCB3aXRoIGFueQogKiBhcmd1bWVudHMsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCAnYnVja2V0JywgY2FsbGJhY2spOwogKgogKiAvLyBwYXJ0aWFsIGFwcGxpY2F0aW9uIGV4YW1wbGU6CiAqIGFzeW5jLmVhY2goCiAqICAgICBidWNrZXRzLAogKiAgICAgYXN5bmMuYXBwbHlFYWNoKFtlbmFibGVTZWFyY2gsIHVwZGF0ZVNjaGVtYV0pLAogKiAgICAgY2FsbGJhY2sKICogKTsKICovCnZhciBhcHBseUVhY2ggPSBhcHBseUVhY2gkMShtYXApOwoKZnVuY3Rpb24gZG9QYXJhbGxlbExpbWl0KGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgICAgIHJldHVybiBmbihfZWFjaE9mTGltaXQobGltaXQpLCBvYmosIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTsKICAgIH07Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBtYXBMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGUKICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgbWFwTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2FzeW5jTWFwKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgbWFwU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGUKICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgbWFwU2VyaWVzID0gZG9MaW1pdChtYXBMaW1pdCwgMSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BhcHBseUVhY2hgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXBwbHlFYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGFwcGx5RWFjaFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5hcHBseUVhY2hde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGZucyAtIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHRvIGFsbAogKiBjYWxsIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzCiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUKICogZnVuY3Rpb24uCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSB0aGUgZmluYWwgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBjYWxsYmFjaywKICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gSWYgb25seSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGl0IHdpbGwgcmV0dXJuCiAqIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGUgYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUKICogZnVuY3Rpb24gY2FsbC4KICovCnZhciBhcHBseUVhY2hTZXJpZXMgPSBhcHBseUVhY2gkMShtYXBTZXJpZXMpOwoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IKICogaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC4KICovCmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkgewogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIGFycmF5Owp9CgovKioKICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHsKICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHsKICAgIHZhciBpbmRleCA9IC0xLAogICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksCiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLAogICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsKCiAgICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdOwogICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBvYmplY3Q7CiAgfTsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgCiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LgogKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uCiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuCiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuCiAqLwp2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC4KICovCmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkgewogIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXQKICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuCiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS4KICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuCiAqLwpmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7CiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwKICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTsKCiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHsKICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7CiAgICAgIHJldHVybiBpbmRleDsKICAgIH0KICB9CiAgcmV0dXJuIC0xOwp9CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTsKfQoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHkKICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC4KICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci4KICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuCiAqLwpmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7CiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwKICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwoKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHsKICAgICAgcmV0dXJuIGluZGV4OwogICAgfQogIH0KICByZXR1cm4gLTE7Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LgogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLgogKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC4KICovCmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7CiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZQogICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KQogICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7Cn0KCi8qKgogKiBEZXRlcm1pbmVzIHRoZSBiZXN0IG9yZGVyIGZvciBydW5uaW5nIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGluIGB0YXNrc2AsIGJhc2VkIG9uCiAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zCiAqIGJlaW5nIGNvbXBsZXRlZCBmaXJzdCwgYW5kIGVhY2ggZnVuY3Rpb24gaXMgcnVuIGFzIHNvb24gYXMgaXRzIHJlcXVpcmVtZW50cwogKiBhcmUgc2F0aXNmaWVkLgogKgogKiBJZiBhbnkgb2YgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjaywgdGhlIGBhdXRvYCBzZXF1ZW5jZQogKiB3aWxsIHN0b3AuIEZ1cnRoZXIgdGFza3Mgd2lsbCBub3QgZXhlY3V0ZSAoc28gYW55IG90aGVyIGZ1bmN0aW9ucyBkZXBlbmRpbmcKICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlCiAqIGVycm9yLgogKgogKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2gKICogaGF2ZSBjb21wbGV0ZWQgc28gZmFyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgdGhleSBoYXZlIGRlcGVuZGVuY2llcy4gSWYgYQogKiB0YXNrIGZ1bmN0aW9uIGhhcyBubyBkZXBlbmRlbmNpZXMsIGl0IHdpbGwgb25seSBiZSBwYXNzZWQgYSBjYWxsYmFjay4KICoKICogQG5hbWUgYXV0bwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYQogKiBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiByZXF1aXJlbWVudHMsIHdpdGggdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufSBpdHNlbGYgdGhlIGxhc3QgaXRlbQogKiBpbiB0aGUgYXJyYXkuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eSBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sKICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yCiAqIG90aGVyIHRhc2tzLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgb25lIG9yIHR3byBhcmd1bWVudHM6CiAqICogYSBgcmVzdWx0c2Agb2JqZWN0LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91c2x5IGV4ZWN1dGVkCiAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcywKICogKiBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGZ1bmN0aW9uLCB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aGVuIGZpbmlzaGVkLAogKiAgIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uJ3MKICogICBleGVjdXRpb24uCiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvcgogKiBkZXRlcm1pbmluZyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGFza3MgdGhhdCBjYW4gYmUgcnVuIGluIHBhcmFsbGVsLiBCeQogKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIHRoZSB0YXNrcyBoYXZlIGJlZW4gY29tcGxldGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYXJndW1lbnQgaWYgYW55IGB0YXNrc2AKICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhbgogKiBlcnJvciBvY2N1cnMsIG5vIGZ1cnRoZXIgYHRhc2tzYCB3aWxsIGJlIHBlcmZvcm1lZCwgYW5kIHRoZSByZXN1bHRzIG9iamVjdAogKiB3aWxsIG9ubHkgY29udGFpbiBwYXJ0aWFsIHJlc3VsdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgLy8gdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgYmUgcGFzc2VkIGEgY2FsbGJhY2sKICogICAgIHJlYWREYXRhOiBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgJ2RhdGEudHh0JywgJ3V0Zi04JyksCiAqICAgICBzaG93RGF0YTogWydyZWFkRGF0YScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNiKSB7CiAqICAgICAgICAgLy8gcmVzdWx0cy5yZWFkRGF0YSBpcyB0aGUgZmlsZSdzIGNvbnRlbnRzCiAqICAgICAgICAgLy8gLi4uCiAqICAgICB9XQogKiB9LCBjYWxsYmFjayk7CiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIGdldF9kYXRhJyk7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7CiAqICAgICB9LAogKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIG1ha2VfZm9sZGVyJyk7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluCiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpOwogKiAgICAgfSwKICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiB3cml0ZV9maWxlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpOwogKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cywKICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpOwogKiAgICAgfV0sCiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBlbWFpbF9saW5rJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpOwogKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi4KICogICAgICAgICAvLyByZXN1bHRzLndyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7CiAqICAgICB9XQogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpOwogKiAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTsKICogfSk7CiAqLwp2YXIgYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY29uY3VycmVuY3ksIGNhbGxiYWNrKSB7CiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgLy8gY29uY3VycmVuY3kgaXMgb3B0aW9uYWwsIHNoaWZ0IHRoZSBhcmdzLgogICAgICAgIGNhbGxiYWNrID0gY29uY3VycmVuY3k7CiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsOwogICAgfQogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIGtleXMkJDEgPSBrZXlzKHRhc2tzKTsKICAgIHZhciBudW1UYXNrcyA9IGtleXMkJDEubGVuZ3RoOwogICAgaWYgKCFudW1UYXNrcykgewogICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgIH0KICAgIGlmICghY29uY3VycmVuY3kpIHsKICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzOwogICAgfQoKICAgIHZhciByZXN1bHRzID0ge307CiAgICB2YXIgcnVubmluZ1Rhc2tzID0gMDsKICAgIHZhciBoYXNFcnJvciA9IGZhbHNlOwoKICAgIHZhciBsaXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwoKICAgIHZhciByZWFkeVRhc2tzID0gW107CgogICAgLy8gZm9yIGN5Y2xlIGRldGVjdGlvbjoKICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGUKICAgIC8vIHdpdGhvdXQgdGhlIHBvc3NpYmlsaXR5IG9mIHJldHVybmluZyB0byBhbiBhbmNlc3RvciB0YXNrCiAgICB2YXIgdW5jaGVja2VkRGVwZW5kZW5jaWVzID0ge307CgogICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSkgewogICAgICAgIGlmICghaXNBcnJheSh0YXNrKSkgewogICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXMKICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCBbdGFza10pOwogICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChrZXkpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpOwogICAgICAgIHZhciByZW1haW5pbmdEZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubGVuZ3RoOwogICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHsKICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTsKICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goa2V5KTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB1bmNoZWNrZWREZXBlbmRlbmNpZXNba2V5XSA9IHJlbWFpbmluZ0RlcGVuZGVuY2llczsKCiAgICAgICAgYXJyYXlFYWNoKGRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGRlcGVuZGVuY3lOYW1lKSB7CiAgICAgICAgICAgIGlmICghdGFza3NbZGVwZW5kZW5jeU5hbWVdKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jLmF1dG8gdGFzayBgJyArIGtleSArCiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgKwogICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lOYW1lICsgJ2AgaW4gJyArCiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmpvaW4oJywgJykpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGFkZExpc3RlbmVyKGRlcGVuZGVuY3lOYW1lLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZW1haW5pbmdEZXBlbmRlbmNpZXMtLTsKICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIHRhc2spOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgIH0pOwoKICAgIGNoZWNrRm9yRGVhZGxvY2tzKCk7CiAgICBwcm9jZXNzUXVldWUoKTsKCiAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayhrZXksIHRhc2spIHsKICAgICAgICByZWFkeVRhc2tzLnB1c2goZnVuY3Rpb24gKCkgewogICAgICAgICAgICBydW5UYXNrKGtleSwgdGFzayk7CiAgICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkgewogICAgICAgIGlmIChyZWFkeVRhc2tzLmxlbmd0aCA9PT0gMCAmJiBydW5uaW5nVGFza3MgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpOwogICAgICAgIH0KICAgICAgICB3aGlsZShyZWFkeVRhc2tzLmxlbmd0aCAmJiBydW5uaW5nVGFza3MgPCBjb25jdXJyZW5jeSkgewogICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpOwogICAgICAgICAgICBydW4oKTsKICAgICAgICB9CgogICAgfQoKICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikgewogICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXTsKICAgICAgICBpZiAoIXRhc2tMaXN0ZW5lcnMpIHsKICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTsKICAgICAgICB9CgogICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7CiAgICB9CgogICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7CiAgICAgICAgdmFyIHRhc2tMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdGFza05hbWVdIHx8IFtdOwogICAgICAgIGFycmF5RWFjaCh0YXNrTGlzdGVuZXJzLCBmdW5jdGlvbiAoZm4pIHsKICAgICAgICAgICAgZm4oKTsKICAgICAgICB9KTsKICAgICAgICBwcm9jZXNzUXVldWUoKTsKICAgIH0KCgogICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHsKICAgICAgICBpZiAoaGFzRXJyb3IpIHJldHVybjsKCiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAgICAgICAgICAgIHJ1bm5pbmdUYXNrcy0tOwogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307CiAgICAgICAgICAgICAgICBiYXNlRm9yT3duKHJlc3VsdHMsIGZ1bmN0aW9uKHZhbCwgcmtleSkgewogICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gdmFsOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trZXldID0gcmVzdWx0OwogICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlOwogICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKCiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDsKICAgICAgICAgICAgICAgIHRhc2tDb21wbGV0ZShrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIHJ1bm5pbmdUYXNrcysrOwogICAgICAgIHZhciB0YXNrRm4gPSB3cmFwQXN5bmModGFza1t0YXNrLmxlbmd0aCAtIDFdKTsKICAgICAgICBpZiAodGFzay5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRhc2tGbih0YXNrQ2FsbGJhY2spOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHsKICAgICAgICAvLyBLYWhuJ3MgYWxnb3JpdGhtCiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9wb2xvZ2ljYWxfc29ydGluZyNLYWhuLjI3c19hbGdvcml0aG0KICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWwKICAgICAgICB2YXIgY3VycmVudFRhc2s7CiAgICAgICAgdmFyIGNvdW50ZXIgPSAwOwogICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7CiAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcmVhZHlUb0NoZWNrLnBvcCgpOwogICAgICAgICAgICBjb3VudGVyKys7CiAgICAgICAgICAgIGFycmF5RWFjaChnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKSwgZnVuY3Rpb24gKGRlcGVuZGVudCkgewogICAgICAgICAgICAgICAgaWYgKC0tdW5jaGVja2VkRGVwZW5kZW5jaWVzW2RlcGVuZGVudF0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChkZXBlbmRlbnQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIGlmIChjb3VudGVyICE9PSBudW1UYXNrcykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeScKICAgICAgICAgICAgKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW50cyh0YXNrTmFtZSkgewogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICBiYXNlRm9yT3duKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5KSB7CiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhc2spICYmIGJhc2VJbmRleE9mKHRhc2ssIHRhc2tOYW1lLCAwKSA+PSAwKSB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KfTsKCi8qKgogKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUKICogc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsCiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJzsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzU3ltYm9sKCdhYmMnKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7CiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fAogICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTsKfQoKLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovCnZhciBJTkZJTklUWSA9IDEgLyAwOwoKLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovCnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCQxID8gU3ltYm9sJDEucHJvdG90eXBlIDogdW5kZWZpbmVkOwp2YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaAogKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLgogKi8KZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7CiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy4KICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gdmFsdWU7CiAgfQogIGlmIChpc0FycmF5KHZhbHVlKSkgewogICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS4KICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnOwogIH0KICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7CiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnOwogIH0KICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpOwogIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS4KICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uCiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLgogKi8KZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKCiAgaWYgKHN0YXJ0IDwgMCkgewogICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTsKICB9CiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kOwogIGlmIChlbmQgPCAwKSB7CiAgICBlbmQgKz0gbGVuZ3RoOwogIH0KICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7CiAgc3RhcnQgPj4+PSAwOwoKICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKioKICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi4KICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuCiAqLwpmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHsKICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kOwogIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpOwp9CgovKioKICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sCiAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuCiAqLwpmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHsKICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDsKCiAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9CiAgcmV0dXJuIGluZGV4Owp9CgovKioKICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sCiAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLgogKi8KZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fQogIHJldHVybiBpbmRleDsKfQoKLyoqCiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7CiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7Cn0KCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi8KdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFx1ZDgwMC1cXHVkZmZmJzsKdmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcdTAzMDAtXFx1MDM2Zic7CnZhciByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFx1ZmUyMC1cXHVmZTJmJzsKdmFyIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFx1MjBkMC1cXHUyMGZmJzsKdmFyIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZTsKdmFyIHJzVmFyUmFuZ2UgPSAnXFx1ZmUwZVxcdWZlMGYnOwoKLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqLwp2YXIgcnNaV0ogPSAnXFx1MjAwZCc7CgovKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi8KdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7CgovKioKICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHsKICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTsKfQoKLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqLwp2YXIgcnNBc3RyYWxSYW5nZSQxID0gJ1xcdWQ4MDAtXFx1ZGZmZic7CnZhciByc0NvbWJvTWFya3NSYW5nZSQxID0gJ1xcdTAzMDAtXFx1MDM2Zic7CnZhciByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSA9ICdcXHVmZTIwLVxcdWZlMmYnOwp2YXIgcnNDb21ib1N5bWJvbHNSYW5nZSQxID0gJ1xcdTIwZDAtXFx1MjBmZic7CnZhciByc0NvbWJvUmFuZ2UkMSA9IHJzQ29tYm9NYXJrc1JhbmdlJDEgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMTsKdmFyIHJzVmFyUmFuZ2UkMSA9ICdcXHVmZTBlXFx1ZmUwZic7CgovKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovCnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJzsKdmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UkMSArICddJzsKdmFyIHJzRml0eiA9ICdcXHVkODNjW1xcdWRmZmItXFx1ZGZmZl0nOwp2YXIgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJzsKdmFyIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJzsKdmFyIHJzUmVnaW9uYWwgPSAnKD86XFx1ZDgzY1tcXHVkZGU2LVxcdWRkZmZdKXsyfSc7CnZhciByc1N1cnJQYWlyID0gJ1tcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0nOwp2YXIgcnNaV0okMSA9ICdcXHUyMDBkJzsKCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqLwp2YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nOwp2YXIgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlJDEgKyAnXT8nOwp2YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiQxICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonOwp2YXIgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luOwp2YXIgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7CgovKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqLwp2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7CgovKioKICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHsKICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107Cn0KCi8qKgogKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LgogKi8KZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHsKICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpCiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZykKICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7Cn0KCi8qKgogKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYAogKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy4KICogQGV4YW1wbGUKICoKICogXy50b1N0cmluZyhudWxsKTsKICogLy8gPT4gJycKICoKICogXy50b1N0cmluZygtMCk7CiAqIC8vID0+ICctMCcKICoKICogXy50b1N0cmluZyhbMSwgMiwgM10pOwogKiAvLyA9PiAnMSwyLDMnCiAqLwpmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkgewogIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpOwp9CgovKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqLwp2YXIgcmVUcmltID0gL15ccyt8XHMrJC9nOwoKLyoqCiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAzLjAuMAogKiBAY2F0ZWdvcnkgU3RyaW5nCiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uCiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS4KICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuCiAqIEBleGFtcGxlCiAqCiAqIF8udHJpbSgnICBhYmMgICcpOwogKiAvLyA9PiAnYWJjJwogKgogKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpOwogKiAvLyA9PiAnYWJjJwogKgogKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pOwogKiAvLyA9PiBbJ2ZvbycsICdiYXInXQogKi8KZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkgewogIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7CiAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHsKICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTsKICB9CiAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7CiAgICByZXR1cm4gc3RyaW5nOwogIH0KICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwKICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLAogICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSwKICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7CgogIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7Cn0KCnZhciBGTl9BUkdTID0gL14oPzphc3luY1xzKyk/KGZ1bmN0aW9uKT9ccypbXlwoXSpcKFxzKihbXlwpXSopXCkvbTsKdmFyIEZOX0FSR19TUExJVCA9IC8sLzsKdmFyIEZOX0FSRyA9IC8oPS4rKT8oXHMqKSQvOwp2YXIgU1RSSVBfQ09NTUVOVFMgPSAvKChcL1wvLiokKXwoXC9cKltcc1xTXSo/XCpcLykpL21nOwoKZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykgewogICAgZnVuYyA9IGZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKFNUUklQX0NPTU1FTlRTLCAnJyk7CiAgICBmdW5jID0gZnVuYy5tYXRjaChGTl9BUkdTKVsyXS5yZXBsYWNlKCcgJywgJycpOwogICAgZnVuYyA9IGZ1bmMgPyBmdW5jLnNwbGl0KEZOX0FSR19TUExJVCkgOiBbXTsKICAgIGZ1bmMgPSBmdW5jLm1hcChmdW5jdGlvbiAoYXJnKXsKICAgICAgICByZXR1cm4gdHJpbShhcmcucmVwbGFjZShGTl9BUkcsICcnKSk7CiAgICB9KTsKICAgIHJldHVybiBmdW5jOwp9CgovKioKICogQSBkZXBlbmRlbmN5LWluamVjdGVkIHZlcnNpb24gb2YgdGhlIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30gZnVuY3Rpb24uIERlcGVuZGVudAogKiB0YXNrcyBhcmUgc3BlY2lmaWVkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGZ1bmN0aW9uLCBhZnRlciB0aGUgdXN1YWwgY2FsbGJhY2sKICogcGFyYW1ldGVyLCB3aXRoIHRoZSBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2hpbmcgdGhlIG5hbWVzIG9mIHRoZSB0YXNrcyBpdAogKiBkZXBlbmRzIG9uLiBUaGlzIGNhbiBwcm92aWRlIGV2ZW4gbW9yZSByZWFkYWJsZSB0YXNrIGdyYXBocyB3aGljaCBjYW4gYmUKICogZWFzaWVyIHRvIG1haW50YWluLgogKgogKiBJZiBhIGZpbmFsIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgdGhlIHRhc2sgcmVzdWx0cyBhcmUgc2ltaWxhcmx5IGluamVjdGVkLAogKiBzcGVjaWZpZWQgYXMgbmFtZWQgcGFyYW1ldGVycyBhZnRlciB0aGUgaW5pdGlhbCBlcnJvciBwYXJhbWV0ZXIuCiAqCiAqIFRoZSBhdXRvSW5qZWN0IGZ1bmN0aW9uIGlzIHB1cmVseSBzeW50YWN0aWMgc3VnYXIgYW5kIGl0cyBzZW1hbnRpY3MgYXJlCiAqIG90aGVyd2lzZSBlcXVpdmFsZW50IHRvIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uCiAqCiAqIEBuYW1lIGF1dG9JbmplY3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtPYmplY3R9IHRhc2tzIC0gQW4gb2JqZWN0LCBlYWNoIG9mIHdob3NlIHByb3BlcnRpZXMgaXMgYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259IG9mCiAqIHRoZSBmb3JtICdmdW5jKFtkZXBlbmRlbmNpZXMuLi5dLCBjYWxsYmFjaykuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eQogKiBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sgZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkCiAqIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yIG90aGVyIHRhc2tzLgogKiAqIFRoZSBgY2FsbGJhY2tgIHBhcmFtZXRlciBpcyBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqICAgd2hlbiBmaW5pc2hlZCwgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZgogKiAgIHRoZSBmdW5jdGlvbidzIGV4ZWN1dGlvbi4gVGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzIG5hbWUgb3RoZXIgdGFza3Mgb24KICogICB3aGljaCB0aGUgdGFzayBpcyBkZXBlbmRlbnQsIGFuZCB0aGUgcmVzdWx0cyBmcm9tIHRob3NlIHRhc2tzIGFyZSB0aGUKICogICBhcmd1bWVudHMgb2YgdGhvc2UgcGFyYW1ldGVycy4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgCiAqIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIGFuZCBhIGByZXN1bHRzYCBvYmplY3Qgd2l0aCBhbnkgY29tcGxldGVkCiAqIHRhc2sgcmVzdWx0cywgc2ltaWxhciB0byBgYXV0b2AuCiAqIEBleGFtcGxlCiAqCiAqIC8vICBUaGUgZXhhbXBsZSBmcm9tIGBhdXRvYCBjYW4gYmUgcmV3cml0dGVuIGFzIGZvbGxvd3M6CiAqIGFzeW5jLmF1dG9JbmplY3QoewogKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7CiAqICAgICB9LAogKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluCiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpOwogKiAgICAgfSwKICogICAgIHdyaXRlX2ZpbGU6IGZ1bmN0aW9uKGdldF9kYXRhLCBtYWtlX2ZvbGRlciwgY2FsbGJhY2spIHsKICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsCiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnkKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTsKICogICAgIH0sCiAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykgewogKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi4KICogICAgICAgICAvLyB3cml0ZV9maWxlIGNvbnRhaW5zIHRoZSBmaWxlbmFtZSByZXR1cm5lZCBieSB3cml0ZV9maWxlLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTsKICogICAgIGNvbnNvbGUubG9nKCdlbWFpbF9saW5rID0gJywgcmVzdWx0cy5lbWFpbF9saW5rKTsKICogfSk7CiAqCiAqIC8vIElmIHlvdSBhcmUgdXNpbmcgYSBKUyBtaW5pZmllciB0aGF0IG1hbmdsZXMgcGFyYW1ldGVyIG5hbWVzLCBgYXV0b0luamVjdGAKICogLy8gd2lsbCBub3Qgd29yayB3aXRoIHBsYWluIGZ1bmN0aW9ucywgc2luY2UgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsIGJlCiAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW4KICogLy8gZXhwbGljaXRseSBzcGVjaWZ5IHRoZSBuYW1lcyBvZiB0aGUgcGFyYW1ldGVycyB5b3VyIHRhc2sgZnVuY3Rpb24gbmVlZHMKICogLy8gaW4gYW4gYXJyYXksIHNpbWlsYXIgdG8gQW5ndWxhci5qcyBkZXBlbmRlbmN5IGluamVjdGlvbi4KICoKICogLy8gVGhpcyBzdGlsbCBoYXMgYW4gYWR2YW50YWdlIG92ZXIgcGxhaW4gYGF1dG9gLCBzaW5jZSB0aGUgcmVzdWx0cyBhIHRhc2sKICogLy8gZGVwZW5kcyBvbiBhcmUgc3RpbGwgc3ByZWFkIGludG8gYXJndW1lbnRzLgogKiBhc3luYy5hdXRvSW5qZWN0KHsKICogICAgIC8vLi4uCiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpOwogKiAgICAgfV0sCiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTsKICogICAgIH1dCiAqICAgICAvLy4uLgogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpOwogKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspOwogKiB9KTsKICovCmZ1bmN0aW9uIGF1dG9JbmplY3QodGFza3MsIGNhbGxiYWNrKSB7CiAgICB2YXIgbmV3VGFza3MgPSB7fTsKCiAgICBiYXNlRm9yT3duKHRhc2tzLCBmdW5jdGlvbiAodGFza0ZuLCBrZXkpIHsKICAgICAgICB2YXIgcGFyYW1zOwogICAgICAgIHZhciBmbklzQXN5bmMgPSBpc0FzeW5jKHRhc2tGbik7CiAgICAgICAgdmFyIGhhc05vRGVwcyA9CiAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8CiAgICAgICAgICAgIChmbklzQXN5bmMgJiYgdGFza0ZuLmxlbmd0aCA9PT0gMCk7CgogICAgICAgIGlmIChpc0FycmF5KHRhc2tGbikpIHsKICAgICAgICAgICAgcGFyYW1zID0gdGFza0ZuLnNsaWNlKDAsIC0xKTsKICAgICAgICAgICAgdGFza0ZuID0gdGFza0ZuW3Rhc2tGbi5sZW5ndGggLSAxXTsKCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KHBhcmFtcy5sZW5ndGggPiAwID8gbmV3VGFzayA6IHRhc2tGbik7CiAgICAgICAgfSBlbHNlIGlmIChoYXNOb0RlcHMpIHsKICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGZ1bmN0aW9uIGFzLWlzCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSB0YXNrRm47CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXModGFza0ZuKTsKICAgICAgICAgICAgaWYgKHRhc2tGbi5sZW5ndGggPT09IDAgJiYgIWZuSXNBc3luYyAmJiBwYXJhbXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLiIpOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyByZW1vdmUgY2FsbGJhY2sgcGFyYW0KICAgICAgICAgICAgaWYgKCFmbklzQXN5bmMpIHBhcmFtcy5wb3AoKTsKCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KG5ld1Rhc2spOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gbmV3VGFzayhyZXN1bHRzLCB0YXNrQ2IpIHsKICAgICAgICAgICAgdmFyIG5ld0FyZ3MgPSBhcnJheU1hcChwYXJhbXMsIGZ1bmN0aW9uIChuYW1lKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tuYW1lXTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIG5ld0FyZ3MucHVzaCh0YXNrQ2IpOwogICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKS5hcHBseShudWxsLCBuZXdBcmdzKTsKICAgICAgICB9CiAgICB9KTsKCiAgICBhdXRvKG5ld1Rhc2tzLCBjYWxsYmFjayk7Cn0KCi8vIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJseV9saW5rZWRfbGlzdCkgaW1wbGVtZW50YXRpb24KLy8gdXNlZCBmb3IgcXVldWVzLiBUaGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhhdCB0aGUgbm9kZSBwcm92aWRlZCBieSB0aGUgdXNlciBjYW4gYmUgbW9kaWZpZWQKLy8gdG8gYWRqdXN0IHRoZSBuZXh0IGFuZCBsYXN0IHByb3BlcnRpZXMuIFdlIGltcGxlbWVudCBvbmx5IHRoZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkKLy8gZm9yIHF1ZXVlIHN1cHBvcnQuCmZ1bmN0aW9uIERMTCgpIHsKICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICB0aGlzLmxlbmd0aCA9IDA7Cn0KCmZ1bmN0aW9uIHNldEluaXRpYWwoZGxsLCBub2RlKSB7CiAgICBkbGwubGVuZ3RoID0gMTsKICAgIGRsbC5oZWFkID0gZGxsLnRhaWwgPSBub2RlOwp9CgpETEwucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihub2RlKSB7CiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDsKICAgIGVsc2UgdGhpcy5oZWFkID0gbm9kZS5uZXh0OwogICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7CiAgICBlbHNlIHRoaXMudGFpbCA9IG5vZGUucHJldjsKCiAgICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsOwogICAgdGhpcy5sZW5ndGggLT0gMTsKICAgIHJldHVybiBub2RlOwp9OwoKRExMLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsKICAgIHdoaWxlKHRoaXMuaGVhZCkgdGhpcy5zaGlmdCgpOwogICAgcmV0dXJuIHRoaXM7Cn07CgpETEwucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkgewogICAgbmV3Tm9kZS5wcmV2ID0gbm9kZTsKICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDsKICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbmV3Tm9kZTsKICAgIGVsc2UgdGhpcy50YWlsID0gbmV3Tm9kZTsKICAgIG5vZGUubmV4dCA9IG5ld05vZGU7CiAgICB0aGlzLmxlbmd0aCArPSAxOwp9OwoKRExMLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbihub2RlLCBuZXdOb2RlKSB7CiAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7CiAgICBuZXdOb2RlLm5leHQgPSBub2RlOwogICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBuZXdOb2RlOwogICAgZWxzZSB0aGlzLmhlYWQgPSBuZXdOb2RlOwogICAgbm9kZS5wcmV2ID0gbmV3Tm9kZTsKICAgIHRoaXMubGVuZ3RoICs9IDE7Cn07CgpETEwucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihub2RlKSB7CiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsIG5vZGUpOwogICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpOwp9OwoKRExMLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkgewogICAgaWYgKHRoaXMudGFpbCkgdGhpcy5pbnNlcnRBZnRlcih0aGlzLnRhaWwsIG5vZGUpOwogICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpOwp9OwoKRExMLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy5oZWFkKTsKfTsKCkRMTC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdGhpcy50YWlsICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLnRhaWwpOwp9OwoKRExMLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgewogICAgdmFyIGFyciA9IEFycmF5KHRoaXMubGVuZ3RoKTsKICAgIHZhciBjdXJyID0gdGhpcy5oZWFkOwogICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmxlbmd0aDsgaWR4KyspIHsKICAgICAgICBhcnJbaWR4XSA9IGN1cnIuZGF0YTsKICAgICAgICBjdXJyID0gY3Vyci5uZXh0OwogICAgfQogICAgcmV0dXJuIGFycjsKfTsKCkRMTC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRlc3RGbikgewogICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7CiAgICB3aGlsZSghIWN1cnIpIHsKICAgICAgICB2YXIgbmV4dCA9IGN1cnIubmV4dDsKICAgICAgICBpZiAodGVzdEZuKGN1cnIpKSB7CiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGluayhjdXJyKTsKICAgICAgICB9CiAgICAgICAgY3VyciA9IG5leHQ7CiAgICB9CiAgICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIHF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3ksIHBheWxvYWQpIHsKICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7CiAgICAgICAgY29uY3VycmVuY3kgPSAxOwogICAgfQogICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpOwogICAgfQoKICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7CiAgICB2YXIgbnVtUnVubmluZyA9IDA7CiAgICB2YXIgd29ya2Vyc0xpc3QgPSBbXTsKCiAgICB2YXIgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IGZhbHNlOwogICAgZnVuY3Rpb24gX2luc2VydChkYXRhLCBpbnNlcnRBdEZyb250LCBjYWxsYmFjaykgewogICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CiAgICAgICAgfQogICAgICAgIHEuc3RhcnRlZCA9IHRydWU7CiAgICAgICAgaWYgKCFpc0FycmF5KGRhdGEpKSB7CiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07CiAgICAgICAgfQogICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCAmJiBxLmlkbGUoKSkgewogICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrcwogICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlJDEoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBxLmRyYWluKCk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICB2YXIgaXRlbSA9IHsKICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sCiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgbm9vcAogICAgICAgICAgICB9OwoKICAgICAgICAgICAgaWYgKGluc2VydEF0RnJvbnQpIHsKICAgICAgICAgICAgICAgIHEuX3Rhc2tzLnVuc2hpZnQoaXRlbSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoIXByb2Nlc3NpbmdTY2hlZHVsZWQpIHsKICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IHRydWU7CiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBfbmV4dCh0YXNrcykgewogICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpewogICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7CgogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1tpXTsKCiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlSW5kZXhPZih3b3JrZXJzTGlzdCwgdGFzaywgMCk7CiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zaGlmdCgpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHsKICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zcGxpY2UoaW5kZXgsIDEpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTsKCiAgICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBxLmVycm9yKGVyciwgdGFzay5kYXRhKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPD0gKHEuY29uY3VycmVuY3kgLSBxLmJ1ZmZlcikgKSB7CiAgICAgICAgICAgICAgICBxLnVuc2F0dXJhdGVkKCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChxLmlkbGUoKSkgewogICAgICAgICAgICAgICAgcS5kcmFpbigpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHEucHJvY2VzcygpOwogICAgICAgIH07CiAgICB9CgogICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlOwogICAgdmFyIHEgPSB7CiAgICAgICAgX3Rhc2tzOiBuZXcgRExMKCksCiAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LAogICAgICAgIHBheWxvYWQ6IHBheWxvYWQsCiAgICAgICAgc2F0dXJhdGVkOiBub29wLAogICAgICAgIHVuc2F0dXJhdGVkOm5vb3AsCiAgICAgICAgYnVmZmVyOiBjb25jdXJyZW5jeSAvIDQsCiAgICAgICAgZW1wdHk6IG5vb3AsCiAgICAgICAgZHJhaW46IG5vb3AsCiAgICAgICAgZXJyb3I6IG5vb3AsCiAgICAgICAgc3RhcnRlZDogZmFsc2UsCiAgICAgICAgcGF1c2VkOiBmYWxzZSwKICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHsKICAgICAgICAgICAgX2luc2VydChkYXRhLCBmYWxzZSwgY2FsbGJhY2spOwogICAgICAgIH0sCiAgICAgICAga2lsbDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICBxLmRyYWluID0gbm9vcDsKICAgICAgICAgICAgcS5fdGFza3MuZW1wdHkoKTsKICAgICAgICB9LAogICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykgewogICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIHRydWUsIGNhbGxiYWNrKTsKICAgICAgICB9LAogICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKHRlc3RGbikgewogICAgICAgICAgICBxLl90YXNrcy5yZW1vdmUodGVzdEZuKTsKICAgICAgICB9LAogICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgLy8gQXZvaWQgdHJ5aW5nIHRvIHN0YXJ0IHRvbyBtYW55IHByb2Nlc3Npbmcgb3BlcmF0aW9ucy4gVGhpcyBjYW4gb2NjdXIKICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgcmVzb2x2ZSBzeW5jaHJvbm91c2x5ICgjMTI2NykuCiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NpbmcpIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlOwogICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKXsKICAgICAgICAgICAgICAgIHZhciB0YXNrcyA9IFtdLCBkYXRhID0gW107CiAgICAgICAgICAgICAgICB2YXIgbCA9IHEuX3Rhc2tzLmxlbmd0aDsKICAgICAgICAgICAgICAgIGlmIChxLnBheWxvYWQpIGwgPSBNYXRoLm1pbihsLCBxLnBheWxvYWQpOwogICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHEuX3Rhc2tzLnNoaWZ0KCk7CiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChub2RlKTsKICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5wdXNoKG5vZGUpOwogICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChub2RlLmRhdGEpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIG51bVJ1bm5pbmcgKz0gMTsKCiAgICAgICAgICAgICAgICBpZiAocS5fdGFza3MubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChudW1SdW5uaW5nID09PSBxLmNvbmN1cnJlbmN5KSB7CiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5T25jZShfbmV4dCh0YXNrcykpOwogICAgICAgICAgICAgICAgX3dvcmtlcihkYXRhLCBjYik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7CiAgICAgICAgfSwKICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aDsKICAgICAgICB9LAogICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIG51bVJ1bm5pbmc7CiAgICAgICAgfSwKICAgICAgICB3b3JrZXJzTGlzdDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7CiAgICAgICAgfSwKICAgICAgICBpZGxlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aCArIG51bVJ1bm5pbmcgPT09IDA7CiAgICAgICAgfSwKICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7CiAgICAgICAgfSwKICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH0KICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTsKICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEocS5wcm9jZXNzKTsKICAgICAgICB9CiAgICB9OwogICAgcmV0dXJuIHE7Cn0KCi8qKgogKiBBIGNhcmdvIG9mIHRhc2tzIGZvciB0aGUgd29ya2VyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLiBDYXJnbyBpbmhlcml0cyBhbGwgb2YKICogdGhlIHNhbWUgbWV0aG9kcyBhbmQgZXZlbnQgY2FsbGJhY2tzIGFzIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9LgogKiBAdHlwZWRlZiB7T2JqZWN0fSBDYXJnb09iamVjdAogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxlbmd0aCAtIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgaXRlbXMKICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSBsaWtlIGBjYXJnby5sZW5ndGgoKWAuCiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXlsb2FkIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSB0YXNrcwogKiBzaG91bGQgYmUgcHJvY2VzcyBwZXIgcm91bmQuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGNoYW5nZWQgYWZ0ZXIgYSBgY2FyZ29gIGlzCiAqIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIHBheWxvYWQgb24tdGhlLWZseS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcHVzaCAtIEFkZHMgYHRhc2tgIHRvIHRoZSBgcXVldWVgLiBUaGUgY2FsbGJhY2sgaXMKICogY2FsbGVkIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEKICogc2luZ2xlIHRhc2ssIGFuIGFycmF5IG9mIGB0YXNrc2AgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMKICogdXNlZCBmb3IgZXZlcnkgdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIGxpa2UgYGNhcmdvLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzYXR1cmF0ZWQgLSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlCiAqIGBxdWV1ZS5sZW5ndGgoKWAgaGl0cyB0aGUgY29uY3VycmVuY3kgYW5kIGZ1cnRoZXIgdGFza3Mgd2lsbCBiZSBxdWV1ZWQuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW0KICogZnJvbSB0aGUgYHF1ZXVlYCBpcyBnaXZlbiB0byBhIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtCiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpZGxlIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgZmFsc2UgaWYgdGhlcmUgYXJlIGl0ZW1zCiAqIHdhaXRpbmcgb3IgYmVpbmcgcHJvY2Vzc2VkLCBvciB0cnVlIGlmIG5vdC4gSW52b2tlIGxpa2UgYGNhcmdvLmlkbGUoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBhdXNlIC0gYSBmdW5jdGlvbiB0aGF0IHBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0YXNrcwogKiB1bnRpbCBgcmVzdW1lKClgIGlzIGNhbGxlZC4gSW52b2tlIGxpa2UgYGNhcmdvLnBhdXNlKClgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZgogKiBxdWV1ZWQgdGFza3Mgd2hlbiB0aGUgcXVldWUgaXMgcGF1c2VkLiBJbnZva2UgbGlrZSBgY2FyZ28ucmVzdW1lKClgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBraWxsIC0gYSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGBkcmFpbmAgY2FsbGJhY2sgYW5kCiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gSW52b2tlIGxpa2UgYGNhcmdvLmtpbGwoKWAuCiAqLwoKLyoqCiAqIENyZWF0ZXMgYSBgY2FyZ29gIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlCiAqIGNhcmdvIHdpbGwgYmUgcHJvY2Vzc2VkIGFsdG9nZXRoZXIgKHVwIHRvIHRoZSBgcGF5bG9hZGAgbGltaXQpLiBJZiB0aGUKICogYHdvcmtlcmAgaXMgaW4gcHJvZ3Jlc3MsIHRoZSB0YXNrIGlzIHF1ZXVlZCB1bnRpbCBpdCBiZWNvbWVzIGF2YWlsYWJsZS4gT25jZQogKiB0aGUgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzCiAqIGNhbGxlZC4gQ2hlY2sgb3V0IFt0aGVzZV0oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS82YmJkMzZmNGNmNWIzNWEwZjExYTk2ZGNkMmU5NzcxMWZmYzJmYjM3LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzgyZjYyNjI2MzMwNjM2NjYyMzAyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzkzNzM0NjYyZDMzMzMzOTM3NjMzNjM0NjQ2MzM4MzUzODJlNjc2OTY2KSBbYW5pbWF0aW9uc10oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS9mNDgxMGUwMGUxYzVmNWY4YWRkYmUzZTlmNDkwNjRmZDVkMTAyNjk5LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzEyZjM4MzQ2MzM5MzIzMDM2MzYyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzgzMTM0NjYyZDM5NjQzMzY0MzAzMjM0MzEzMzYyNjY2NDJlNjc2OTY2KQogKiBmb3IgaG93IGBjYXJnb2AgYW5kIGBxdWV1ZWAgd29yay4KICoKICogV2hpbGUgW2BxdWV1ZWBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0gcGFzc2VzIG9ubHkgb25lIHRhc2sgdG8gb25lIG9mIGEgZ3JvdXAgb2Ygd29ya2VycwogKiBhdCBhIHRpbWUsIGNhcmdvIHBhc3NlcyBhbiBhcnJheSBvZiB0YXNrcyB0byBhIHNpbmdsZSB3b3JrZXIsIHJlcGVhdGluZwogKiB3aGVuIHRoZSB3b3JrZXIgaXMgZmluaXNoZWQuCiAqCiAqIEBuYW1lIGNhcmdvCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYW4gYXJyYXkKICogb2YgcXVldWVkIHRhc2tzLiBJbnZva2VkIHdpdGggYCh0YXNrcywgY2FsbGJhY2spYC4KICogQHBhcmFtIHtudW1iZXJ9IFtwYXlsb2FkPUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcKICogaG93IG1hbnkgdGFza3Mgc2hvdWxkIGJlIHByb2Nlc3NlZCBwZXIgcm91bmQ7IGlmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzCiAqIHVubGltaXRlZC4KICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5DYXJnb09iamVjdH0gQSBjYXJnbyBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhbgogKiBhdHRhY2hlZCBhcyBjZXJ0YWluIHByb3BlcnRpZXMgdG8gbGlzdGVuIGZvciBzcGVjaWZpYyBldmVudHMgZHVyaW5nIHRoZQogKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvIGFuZCBpbm5lciBxdWV1ZS4KICogQGV4YW1wbGUKICoKICogLy8gY3JlYXRlIGEgY2FyZ28gb2JqZWN0IHdpdGggcGF5bG9hZCAyCiAqIHZhciBjYXJnbyA9IGFzeW5jLmNhcmdvKGZ1bmN0aW9uKHRhc2tzLCBjYWxsYmFjaykgewogKiAgICAgZm9yICh2YXIgaT0wOyBpPHRhc2tzLmxlbmd0aDsgaSsrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrc1tpXS5uYW1lKTsKICogICAgIH0KICogICAgIGNhbGxiYWNrKCk7CiAqIH0sIDIpOwogKgogKiAvLyBhZGQgc29tZSBpdGVtcwogKiBjYXJnby5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgZm9vJyk7CiAqIH0pOwogKiBjYXJnby5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7CiAqIH0pOwogKiBjYXJnby5wdXNoKHtuYW1lOiAnYmF6J30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmF6Jyk7CiAqIH0pOwogKi8KZnVuY3Rpb24gY2FyZ28od29ya2VyLCBwYXlsb2FkKSB7CiAgICByZXR1cm4gcXVldWUod29ya2VyLCAxLCBwYXlsb2FkKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBlYWNoT2ZTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfQogKiBAYWxpYXMgZm9yRWFjaE9mU2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCnZhciBlYWNoT2ZTZXJpZXMgPSBkb0xpbWl0KGVhY2hPZkxpbWl0LCAxKTsKCi8qKgogKiBSZWR1Y2VzIGBjb2xsYCBpbnRvIGEgc2luZ2xlIHZhbHVlIHVzaW5nIGFuIGFzeW5jIGBpdGVyYXRlZWAgdG8gcmV0dXJuIGVhY2gKICogc3VjY2Vzc2l2ZSBzdGVwLiBgbWVtb2AgaXMgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4gVGhpcyBmdW5jdGlvbgogKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy4KICoKICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0IG1heSBtYWtlIHNlbnNlIHRvIHNwbGl0IGEgY2FsbCB0byB0aGlzIGZ1bmN0aW9uCiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGUKICogcmVzdWx0cy4gVGhpcyBmdW5jdGlvbiBpcyBmb3Igc2l0dWF0aW9ucyB3aGVyZSBlYWNoIHN0ZXAgaW4gdGhlIHJlZHVjdGlvbgogKiBuZWVkcyB0byBiZSBhc3luYzsgaWYgeW91IGNhbiBnZXQgdGhlIGRhdGEgYmVmb3JlIHJlZHVjaW5nIGl0LCB0aGVuIGl0J3MKICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uCiAqCiAqIEBuYW1lIHJlZHVjZQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgaW5qZWN0CiAqIEBhbGlhcyBmb2xkbAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZQogKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi4KICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4KICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlCiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuCiAqIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHQpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5yZWR1Y2UoWzEsMiwzXSwgMCwgZnVuY3Rpb24obWVtbywgaXRlbSwgY2FsbGJhY2spIHsKICogICAgIC8vIHBvaW50bGVzcyBhc3luYzoKICogICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVtbyArIGl0ZW0pCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gdGhlIGxhc3QgdmFsdWUgb2YgbWVtbywgd2hpY2ggaXMgNgogKiB9KTsKICovCmZ1bmN0aW9uIHJlZHVjZShjb2xsLCBtZW1vLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgZWFjaE9mU2VyaWVzKGNvbGwsIGZ1bmN0aW9uKHgsIGksIGNhbGxiYWNrKSB7CiAgICAgICAgX2l0ZXJhdGVlKG1lbW8sIHgsIGZ1bmN0aW9uKGVyciwgdikgewogICAgICAgICAgICBtZW1vID0gdjsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uKGVycikgewogICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7CiAgICB9KTsKfQoKLyoqCiAqIFZlcnNpb24gb2YgdGhlIGNvbXBvc2UgZnVuY3Rpb24gdGhhdCBpcyBtb3JlIG5hdHVyYWwgdG8gcmVhZC4gRWFjaCBmdW5jdGlvbgogKiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBmdW5jdGlvbi4gSXQgaXMgdGhlIGVxdWl2YWxlbnQgb2YKICogW2NvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfSB3aXRoIHRoZSBhcmd1bWVudHMgcmV2ZXJzZWQuCiAqCiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLgogKgogKiBAbmFtZSBzZXEKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuY29tcG9zZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNvbXBvc2V9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGNvbXBvc2VzIHRoZSBgZnVuY3Rpb25zYCBpbiBvcmRlcgogKiBAZXhhbXBsZQogKgogKiAvLyBSZXF1aXJlcyBsb2Rhc2ggKG9yIHVuZGVyc2NvcmUpLCBleHByZXNzMyBhbmQgZHJlc2VuZGUncyBvcm0yLgogKiAvLyBQYXJ0IG9mIGFuIGFwcCwgdGhhdCBmZXRjaGVzIGNhdHMgb2YgdGhlIGxvZ2dlZCB1c2VyLgogKiAvLyBUaGlzIGV4YW1wbGUgdXNlcyBgc2VxYCBmdW5jdGlvbiB0byBhdm9pZCBvdmVybmVzdGluZyBhbmQgZXJyb3IKICogLy8gaGFuZGxpbmcgY2x1dHRlci4KICogYXBwLmdldCgnL2NhdHMnLCBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkgewogKiAgICAgdmFyIFVzZXIgPSByZXF1ZXN0Lm1vZGVscy5Vc2VyOwogKiAgICAgYXN5bmMuc2VxKAogKiAgICAgICAgIF8uYmluZChVc2VyLmdldCwgVXNlciksICAvLyAnVXNlci5nZXQnIGhhcyBzaWduYXR1cmUgKGlkLCBjYWxsYmFjayhlcnIsIGRhdGEpKQogKiAgICAgICAgIGZ1bmN0aW9uKHVzZXIsIGZuKSB7CiAqICAgICAgICAgICAgIHVzZXIuZ2V0Q2F0cyhmbik7ICAgICAgLy8gJ2dldENhdHMnIGhhcyBzaWduYXR1cmUgKGNhbGxiYWNrKGVyciwgZGF0YSkpCiAqICAgICAgICAgfQogKiAgICAgKShyZXEuc2Vzc2lvbi51c2VyX2lkLCBmdW5jdGlvbiAoZXJyLCBjYXRzKSB7CiAqICAgICAgICAgaWYgKGVycikgewogKiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7CiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH0pOwogKiAgICAgICAgIH0gZWxzZSB7CiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdvaycsIG1lc3NhZ2U6ICdDYXRzIGZvdW5kJywgZGF0YTogY2F0cyB9KTsKICogICAgICAgICB9CiAqICAgICB9KTsKICogfSk7CiAqLwpmdW5jdGlvbiBzZXEoLyouLi5mdW5jdGlvbnMqLykgewogICAgdmFyIF9mdW5jdGlvbnMgPSBhcnJheU1hcChhcmd1bWVudHMsIHdyYXBBc3luYyk7CiAgICByZXR1cm4gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICAgICAgdmFyIHRoYXQgPSB0aGlzOwoKICAgICAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07CiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIGFyZ3MucG9wKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY2IgPSBub29wOwogICAgICAgIH0KCiAgICAgICAgcmVkdWNlKF9mdW5jdGlvbnMsIGFyZ3MsIGZ1bmN0aW9uKG5ld2FyZ3MsIGZuLCBjYikgewogICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChmdW5jdGlvbihlcnIvKiwgLi4ubmV4dGFyZ3MqLykgewogICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgfSwKICAgICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICAgICAgICAgICAgY2IuYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTsKICAgICAgICB9KTsKICAgIH07Cn0KCi8qKgogKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaXMgYSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGFzeW5jaHJvbm91cwogKiBmdW5jdGlvbnMuIEVhY2ggZnVuY3Rpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdAogKiBmb2xsb3dzLiBDb21wb3NpbmcgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHdvdWxkIHByb2R1Y2UgdGhlIHJlc3VsdAogKiBvZiBgZihnKGgoKSkpYCwgb25seSB0aGlzIHZlcnNpb24gdXNlcyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSByZXR1cm4gdmFsdWVzLgogKgogKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi4KICoKICogQG5hbWUgY29tcG9zZQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZQogKiBAcmV0dXJucyB7RnVuY3Rpb259IGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NlZAogKiBhc3luY2hyb25vdXMgYGZ1bmN0aW9uc2AKICogQGV4YW1wbGUKICoKICogZnVuY3Rpb24gYWRkMShuLCBjYWxsYmFjaykgewogKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbiArIDEpOwogKiAgICAgfSwgMTApOwogKiB9CiAqCiAqIGZ1bmN0aW9uIG11bDMobiwgY2FsbGJhY2spIHsKICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKiAzKTsKICogICAgIH0sIDEwKTsKICogfQogKgogKiB2YXIgYWRkMW11bDMgPSBhc3luYy5jb21wb3NlKG11bDMsIGFkZDEpOwogKiBhZGQxbXVsMyg0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIDE1CiAqIH0pOwogKi8KdmFyIGNvbXBvc2UgPSBmdW5jdGlvbigvKi4uLmFyZ3MqLykgewogICAgcmV0dXJuIHNlcS5hcHBseShudWxsLCBzbGljZShhcmd1bWVudHMpLnJldmVyc2UoKSk7Cn07Cgp2YXIgX2NvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7CgovKioKICogVGhlIHNhbWUgYXMgW2Bjb25jYXRgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICoKICogQG5hbWUgY29uY2F0TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwKICogd2hpY2ggc2hvdWxkIHVzZSBhbiBhcnJheSBhcyBpdHMgcmVzdWx0LiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5CiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgY29uY2F0TGltaXQgPSBmdW5jdGlvbihjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIG1hcExpbWl0KGNvbGwsIGxpbWl0LCBmdW5jdGlvbih2YWwsIGNhbGxiYWNrKSB7CiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgZnVuY3Rpb24oZXJyIC8qLCAuLi5hcmdzKi8pIHsKICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzbGljZShhcmd1bWVudHMsIDEpKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uKGVyciwgbWFwUmVzdWx0cykgewogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcFJlc3VsdHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb25jYXQuYXBwbHkocmVzdWx0LCBtYXBSZXN1bHRzW2ldKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTsKICAgIH0pOwp9OwoKLyoqCiAqIEFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBjb25jYXRlbmF0aW5nIHRoZSByZXN1bHRzLiBSZXR1cm5zCiAqIHRoZSBjb25jYXRlbmF0ZWQgbGlzdC4gVGhlIGBpdGVyYXRlZWBzIGFyZSBjYWxsZWQgaW4gcGFyYWxsZWwsIGFuZCB0aGUKICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUKICogcmVzdWx0cyBhcnJheSB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBvcmlnaW5hbCBvcmRlciBvZiBgY29sbGAgcGFzc2VkIHRvIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9uLgogKgogKiBAbmFtZSBjb25jYXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLAogKiB3aGljaCBzaG91bGQgdXNlIGFuIGFycmF5IGFzIGl0cyByZXN1bHQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheQogKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5jb25jYXQoWydkaXIxJywnZGlyMicsJ2RpcjMnXSwgZnMucmVhZGRpciwgZnVuY3Rpb24oZXJyLCBmaWxlcykgewogKiAgICAgLy8gZmlsZXMgaXMgbm93IGEgbGlzdCBvZiBmaWxlbmFtZXMgdGhhdCBleGlzdCBpbiB0aGUgMyBkaXJlY3RvcmllcwogKiB9KTsKICovCnZhciBjb25jYXQgPSBkb0xpbWl0KGNvbmNhdExpbWl0LCBJbmZpbml0eSk7CgovKioKICogVGhlIHNhbWUgYXMgW2Bjb25jYXRgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGNvbmNhdFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGFuIGFycmF5IGFuIGFycmF5IG9mIHJlc3VsdHMuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheQogKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIGNvbmNhdFNlcmllcyA9IGRvTGltaXQoY29uY2F0TGltaXQsIDEpOwoKLyoqCiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkLCBjYWxscy1iYWNrIHdpdGggdGhlIHZhbHVlcyBwcm92aWRlZC4KICogVXNlZnVsIGFzIHRoZSBmaXJzdCBmdW5jdGlvbiBpbiBhIFtgd2F0ZXJmYWxsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndhdGVyZmFsbH0sIG9yIGZvciBwbHVnZ2luZyB2YWx1ZXMgaW4gdG8KICogW2BhdXRvYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99LgogKgogKiBAbmFtZSBjb25zdGFudAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgaW52b2tlCiAqIGNhbGxiYWNrIHdpdGguCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGludm9rZWQsIGF1dG9tYXRpY2FsbHkKICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgYXN5bmMuY29uc3RhbnQoNDIpLAogKiAgICAgZnVuY3Rpb24gKHZhbHVlLCBuZXh0KSB7CiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyCiAqICAgICB9LAogKiAgICAgLy8uLi4KICogXSwgY2FsbGJhY2spOwogKgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsICJ1dGY4IiksCiAqICAgICBmcy5yZWFkRmlsZSwKICogICAgIGZ1bmN0aW9uIChmaWxlRGF0YSwgbmV4dCkgewogKiAgICAgICAgIC8vLi4uCiAqICAgICB9CiAqICAgICAvLy4uLgogKiBdLCBjYWxsYmFjayk7CiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgaG9zdG5hbWU6IGFzeW5jLmNvbnN0YW50KCJodHRwczovL3NlcnZlci5uZXQvIiksCiAqICAgICBwb3J0OiBmaW5kRnJlZVBvcnQsCiAqICAgICBsYXVuY2hTZXJ2ZXI6IFsiaG9zdG5hbWUiLCAicG9ydCIsIGZ1bmN0aW9uIChvcHRpb25zLCBjYikgewogKiAgICAgICAgIHN0YXJ0U2VydmVyKG9wdGlvbnMsIGNiKTsKICogICAgIH1dLAogKiAgICAgLy8uLi4KICogfSwgY2FsbGJhY2spOwogKi8KdmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykgewogICAgdmFyIHZhbHVlcyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICB2YXIgYXJncyA9IFtudWxsXS5jb25jYXQodmFsdWVzKTsKICAgIHJldHVybiBmdW5jdGlvbiAoLyouLi5pZ25vcmVkQXJncywgY2FsbGJhY2sqLykgewogICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfTsKfTsKCi8qKgogKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy4KICoKICogQHN0YXRpYwogKiBAc2luY2UgMC4xLjAKICogQG1lbWJlck9mIF8KICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuCiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuCiAqIEBleGFtcGxlCiAqCiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9OwogKgogKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7CiAqIC8vID0+IHRydWUKICovCmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlOwp9CgpmdW5jdGlvbiBfY3JlYXRlVGVzdGVyKGNoZWNrLCBnZXRSZXN1bHQpIHsKICAgIHJldHVybiBmdW5jdGlvbihlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNiKSB7CiAgICAgICAgY2IgPSBjYiB8fCBub29wOwogICAgICAgIHZhciB0ZXN0UGFzc2VkID0gZmFsc2U7CiAgICAgICAgdmFyIHRlc3RSZXN1bHQ7CiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24odmFsdWUsIF8sIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrKHJlc3VsdCkgJiYgIXRlc3RSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgICB0ZXN0UGFzc2VkID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICB0ZXN0UmVzdWx0ID0gZ2V0UmVzdWx0KHRydWUsIHZhbHVlKTsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBicmVha0xvb3ApOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgY2IoZXJyKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKICAgIH07Cn0KCmZ1bmN0aW9uIF9maW5kR2V0UmVzdWx0KHYsIHgpIHsKICAgIHJldHVybiB4Owp9CgovKioKICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gYGNvbGxgIHRoYXQgcGFzc2VzIGFuIGFzeW5jIHRydXRoIHRlc3QuIFRoZQogKiBgaXRlcmF0ZWVgIGlzIGFwcGxpZWQgaW4gcGFyYWxsZWwsIG1lYW5pbmcgdGhlIGZpcnN0IGl0ZXJhdGVlIHRvIHJldHVybgogKiBgdHJ1ZWAgd2lsbCBmaXJlIHRoZSBkZXRlY3QgYGNhbGxiYWNrYCB3aXRoIHRoYXQgcmVzdWx0LiBUaGF0IG1lYW5zIHRoZQogKiByZXN1bHQgbWlnaHQgbm90IGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBvcmlnaW5hbCBgY29sbGAgKGluIHRlcm1zIG9mIG9yZGVyKQogKiB0aGF0IHBhc3NlcyB0aGUgdGVzdC4KCiAqIElmIG9yZGVyIHdpdGhpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIGlzIGltcG9ydGFudCwgdGhlbiBsb29rIGF0CiAqIFtgZGV0ZWN0U2VyaWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdFNlcmllc30uCiAqCiAqIEBuYW1lIGRldGVjdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgZmluZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnMKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0CiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZGV0ZWN0KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0cwogKiB9KTsKICovCnZhciBkZXRlY3QgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgZGV0ZWN0TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZGV0ZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fQogKiBAYWxpYXMgZmluZExpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9ucwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdAogKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgZGV0ZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3RlcihpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZGV0ZWN0U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0KICogQGFsaWFzIGZpbmRTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb25zCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdAogKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgZGV0ZWN0U2VyaWVzID0gZG9MaW1pdChkZXRlY3RMaW1pdCwgMSk7CgpmdW5jdGlvbiBjb25zb2xlRnVuYyhuYW1lKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKGZuLyosIC4uLmFyZ3MqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVtuYW1lXSkgewogICAgICAgICAgICAgICAgICAgIGFycmF5RWFjaChhcmdzLCBmdW5jdGlvbiAoeCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgd3JhcEFzeW5jKGZuKS5hcHBseShudWxsLCBhcmdzKTsKICAgIH07Cn0KCi8qKgogKiBMb2dzIHRoZSByZXN1bHQgb2YgYW4gW2Bhc3luY2AgZnVuY3Rpb25de0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHRoZQogKiBgY29uc29sZWAgdXNpbmcgYGNvbnNvbGUuZGlyYCB0byBkaXNwbGF5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0LgogKiBPbmx5IHdvcmtzIGluIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmRpcmAgYW5kCiAqIGBjb25zb2xlLmVycm9yYCAoc3VjaCBhcyBGRiBhbmQgQ2hyb21lKS4KICogSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luYyBmdW5jdGlvbiwKICogYGNvbnNvbGUuZGlyYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci4KICoKICogQG5hbWUgZGlyCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseQogKiBhbGwgYXJndW1lbnRzIHRvLgogKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi4KICogQGV4YW1wbGUKICoKICogLy8gaW4gYSBtb2R1bGUKICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHsKICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwge2hlbGxvOiBuYW1lfSk7CiAqICAgICB9LCAxMDAwKTsKICogfTsKICoKICogLy8gaW4gdGhlIG5vZGUgcmVwbAogKiBub2RlPiBhc3luYy5kaXIoaGVsbG8sICd3b3JsZCcpOwogKiB7aGVsbG86ICd3b3JsZCd9CiAqLwp2YXIgZGlyID0gY29uc29sZUZ1bmMoJ2RpcicpOwoKLyoqCiAqIFRoZSBwb3N0LWNoZWNrIHZlcnNpb24gb2YgW2BkdXJpbmdgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZHVyaW5nfS4gVG8gcmVmbGVjdCB0aGUgZGlmZmVyZW5jZSBpbgogKiB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucywgdGhlIGFyZ3VtZW50cyBgdGVzdGAgYW5kIGBmbmAgYXJlIHN3aXRjaGVkLgogKgogKiBBbHNvIGEgdmVyc2lvbiBvZiBbYGRvV2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSB3aXRoIGFzeW5jaHJvbm91cyBgdGVzdGAgZnVuY3Rpb24uCiAqIEBuYW1lIGRvRHVyaW5nCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmR1cmluZ117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmR1cmluZ30KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZQogKiBgdGVzdGAgcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBiZWZvcmUgZWFjaAogKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjayksIHdoZXJlIGAuLi5hcmdzYCBhcmUgdGhlCiAqIG5vbi1lcnJvciBhcmdzIGZyb20gdGhlIHByZXZpb3VzIGNhbGxiYWNrIG9mIGBmbmAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdAogKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGZuYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYAogKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBpZiBvbmUgb2NjdXJyZWQsIG90aGVyd2lzZSBgbnVsbGAuCiAqLwpmdW5jdGlvbiBkb0R1cmluZyhmbiwgdGVzdCwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGZuKTsKICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTsKCiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgYXJncy5wdXNoKGNoZWNrKTsKICAgICAgICBfdGVzdC5hcHBseSh0aGlzLCBhcmdzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgICAgIF9mbihuZXh0KTsKICAgIH0KCiAgICBjaGVjayhudWxsLCB0cnVlKTsKCn0KCi8qKgogKiBUaGUgcG9zdC1jaGVjayB2ZXJzaW9uIG9mIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uIFRvIHJlZmxlY3QgdGhlIGRpZmZlcmVuY2UgaW4KICogdGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMsIHRoZSBhcmd1bWVudHMgYHRlc3RgIGFuZCBgaXRlcmF0ZWVgIGFyZSBzd2l0Y2hlZC4KICoKICogYGRvV2hpbHN0YCBpcyB0byBgd2hpbHN0YCBhcyBgZG8gd2hpbGVgIGlzIHRvIGB3aGlsZWAgaW4gcGxhaW4gSmF2YVNjcmlwdC4KICoKICogQG5hbWUgZG9XaGlsc3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUgYHRlc3RgCiAqIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYWZ0ZXIgZWFjaAogKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoIGFueSBub24tZXJyb3IgY2FsbGJhY2sgcmVzdWx0cyBvZgogKiBgaXRlcmF0ZWVgLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuCiAqIGBjYWxsYmFja2Agd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbAogKiBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pOwogKi8KZnVuY3Rpb24gZG9XaGlsc3QoaXRlcmF0ZWUsIHRlc3QsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgaWYgKHRlc3QuYXBwbHkodGhpcywgYXJncykpIHJldHVybiBfaXRlcmF0ZWUobmV4dCk7CiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7CiAgICB9OwogICAgX2l0ZXJhdGVlKG5leHQpOwp9CgovKioKICogTGlrZSBbJ2RvV2hpbHN0J117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgaW52ZXJ0ZWQuIE5vdGUgdGhlCiAqIGFyZ3VtZW50IG9yZGVyaW5nIGRpZmZlcnMgZnJvbSBgdW50aWxgLgogKgogKiBAbmFtZSBkb1VudGlsCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmRvV2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUKICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdCAtIHN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBhZnRlciBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggYW55IG5vbi1lcnJvciBjYWxsYmFjayByZXN1bHRzIG9mCiAqIGBpdGVyYXRlZWAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdAogKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYAogKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsIGBpdGVyYXRlZWAncwogKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7CiAqLwpmdW5jdGlvbiBkb1VudGlsKGl0ZXJhdGVlLCB0ZXN0LCBjYWxsYmFjaykgewogICAgZG9XaGlsc3QoaXRlcmF0ZWUsIGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfSwgY2FsbGJhY2spOwp9CgovKioKICogTGlrZSBbYHdoaWxzdGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9LCBleGNlcHQgdGhlIGB0ZXN0YCBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdAogKiBpcyBwYXNzZWQgYSBjYWxsYmFjayBpbiB0aGUgZm9ybSBvZiBgZnVuY3Rpb24gKGVyciwgdHJ1dGgpYC4gSWYgZXJyb3IgaXMKICogcGFzc2VkIHRvIGB0ZXN0YCBvciBgZm5gLCB0aGUgbWFpbiBjYWxsYmFjayBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUKICogdmFsdWUgb2YgdGhlIGVycm9yLgogKgogKiBAbmFtZSBkdXJpbmcKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGVzdCAtIGFzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2gKICogZXhlY3V0aW9uIG9mIGBmbmAuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZQogKiBgdGVzdGAgcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgZm5gIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yLCBpZiBvbmUgb2NjdXJyZWQsIG90aGVyd2lzZSBgbnVsbGAuCiAqIEBleGFtcGxlCiAqCiAqIHZhciBjb3VudCA9IDA7CiAqCiAqIGFzeW5jLmR1cmluZygKICogICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgewogKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjb3VudCA8IDUpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgewogKiAgICAgICAgIGNvdW50Kys7CiAqICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24gKGVycikgewogKiAgICAgICAgIC8vIDUgc2Vjb25kcyBoYXZlIHBhc3NlZAogKiAgICAgfQogKiApOwogKi8KZnVuY3Rpb24gZHVyaW5nKHRlc3QsIGZuLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmx5T25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pOwogICAgdmFyIF90ZXN0ID0gd3JhcEFzeW5jKHRlc3QpOwoKICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgX3Rlc3QoY2hlY2spOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoZWNrKGVyciwgdHJ1dGgpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCk7CiAgICAgICAgX2ZuKG5leHQpOwogICAgfQoKICAgIF90ZXN0KGNoZWNrKTsKfQoKZnVuY3Rpb24gX3dpdGhvdXRJbmRleChpdGVyYXRlZSkgewogICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlLCBjYWxsYmFjayk7CiAgICB9Owp9CgovKioKICogQXBwbGllcyB0aGUgZnVuY3Rpb24gYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBpbiBwYXJhbGxlbC4KICogVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIHRoZSBsaXN0LCBhbmQgYSBjYWxsYmFjayBmb3Igd2hlbgogKiBpdCBoYXMgZmluaXNoZWQuIElmIHRoZSBgaXRlcmF0ZWVgIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgYGNhbGxiYWNrYCwgdGhlCiAqIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgZWFjaGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZQogKiBlcnJvci4KICoKICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsCiAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci4KICoKICogQG5hbWUgZWFjaAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgZm9yRWFjaAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0bwogKiBlYWNoIGl0ZW0gaW4gYGNvbGxgLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLgogKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mYC4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLgogKiBAZXhhbXBsZQogKgogKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lcyBhbmQgc2F2ZUZpbGUgaXMgYSBmdW5jdGlvbgogKiAvLyB0byBzYXZlIHRoZSBtb2RpZmllZCBjb250ZW50cyBvZiB0aGF0IGZpbGU6CiAqCiAqIGFzeW5jLmVhY2gob3BlbkZpbGVzLCBzYXZlRmlsZSwgZnVuY3Rpb24oZXJyKXsKICogICAvLyBpZiBhbnkgb2YgdGhlIHNhdmVzIHByb2R1Y2VkIGFuIGVycm9yLCBlcnIgd291bGQgZXF1YWwgdGhhdCBlcnJvcgogKiB9KTsKICoKICogLy8gYXNzdW1pbmcgb3BlbkZpbGVzIGlzIGFuIGFycmF5IG9mIGZpbGUgbmFtZXMKICogYXN5bmMuZWFjaChvcGVuRmlsZXMsIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7CiAqCiAqICAgICAvLyBQZXJmb3JtIG9wZXJhdGlvbiBvbiBmaWxlIGhlcmUuCiAqICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBmaWxlICcgKyBmaWxlKTsKICoKICogICAgIGlmKCBmaWxlLmxlbmd0aCA+IDMyICkgewogKiAgICAgICBjb25zb2xlLmxvZygnVGhpcyBmaWxlIG5hbWUgaXMgdG9vIGxvbmcnKTsKICogICAgICAgY2FsbGJhY2soJ0ZpbGUgbmFtZSB0b28gbG9uZycpOwogKiAgICAgfSBlbHNlIHsKICogICAgICAgLy8gRG8gd29yayB0byBwcm9jZXNzIGZpbGUgaGVyZQogKiAgICAgICBjb25zb2xlLmxvZygnRmlsZSBwcm9jZXNzZWQnKTsKICogICAgICAgY2FsbGJhY2soKTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAvLyBpZiBhbnkgb2YgdGhlIGZpbGUgcHJvY2Vzc2luZyBwcm9kdWNlZCBhbiBlcnJvciwgZXJyIHdvdWxkIGVxdWFsIHRoYXQgZXJyb3IKICogICAgIGlmKCBlcnIgKSB7CiAqICAgICAgIC8vIE9uZSBvZiB0aGUgaXRlcmF0aW9ucyBwcm9kdWNlZCBhbiBlcnJvci4KICogICAgICAgLy8gQWxsIHByb2Nlc3Npbmcgd2lsbCBub3cgc3RvcC4KICogICAgICAgY29uc29sZS5sb2coJ0EgZmlsZSBmYWlsZWQgdG8gcHJvY2VzcycpOwogKiAgICAgfSBlbHNlIHsKICogICAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseScpOwogKiAgICAgfQogKiB9KTsKICovCmZ1bmN0aW9uIGVhY2hMaW1pdChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGVhY2hPZihjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGVhY2hMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0KICogQGFsaWFzIGZvckVhY2hMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS4KICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCmZ1bmN0aW9uIGVhY2hMaW1pdCQxKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZWFjaFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0KICogQGFsaWFzIGZvckVhY2hTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaAogKiBpdGVtIGluIGBjb2xsYC4KICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLgogKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mU2VyaWVzYC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCnZhciBlYWNoU2VyaWVzID0gZG9MaW1pdChlYWNoTGltaXQkMSwgMSk7CgovKioKICogV3JhcCBhbiBhc3luYyBmdW5jdGlvbiBhbmQgZW5zdXJlIGl0IGNhbGxzIGl0cyBjYWxsYmFjayBvbiBhIGxhdGVyIHRpY2sgb2YKICogdGhlIGV2ZW50IGxvb3AuICBJZiB0aGUgZnVuY3Rpb24gYWxyZWFkeSBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBuZXh0IHRpY2ssCiAqIG5vIGV4dHJhIGRlZmVycmFsIGlzIGFkZGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3MKICogKGBSYW5nZUVycm9yOiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZGApIGFuZCBnZW5lcmFsbHkga2VlcGluZwogKiBbWmFsZ29dKGh0dHA6Ly9ibG9nLml6cy5tZS9wb3N0LzU5MTQyNzQyMTQzL2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KQogKiBjb250YWluZWQuIEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucyBhcmUgcmV0dXJuZWQgYXMtaXMgLS0gdGhleSBhcmUgaW1tdW5lCiAqIHRvIFphbGdvJ3MgY29ycnVwdGluZyBpbmZsdWVuY2VzLCBhcyB0aGV5IGFsd2F5cyByZXNvbHZlIG9uIGEgbGF0ZXIgdGljay4KICoKICogQG5hbWUgZW5zdXJlQXN5bmMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uLCBvbmUgdGhhdCBleHBlY3RzIGEgbm9kZS1zdHlsZQogKiBjYWxsYmFjayBhcyBpdHMgbGFzdCBhcmd1bWVudC4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHdpdGggdGhlIGV4YWN0IHNhbWUgY2FsbAogKiBzaWduYXR1cmUgYXMgdGhlIGZ1bmN0aW9uIHBhc3NlZCBpbi4KICogQGV4YW1wbGUKICoKICogZnVuY3Rpb24gc29tZXRpbWVzQXN5bmMoYXJnLCBjYWxsYmFjaykgewogKiAgICAgaWYgKGNhY2hlW2FyZ10pIHsKICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY2FjaGVbYXJnXSk7IC8vIHRoaXMgd291bGQgYmUgc3luY2hyb25vdXMhIQogKiAgICAgfSBlbHNlIHsKICogICAgICAgICBkb1NvbWVJTyhhcmcsIGNhbGxiYWNrKTsgLy8gdGhpcyBJTyB3b3VsZCBiZSBhc3luY2hyb25vdXMKICogICAgIH0KICogfQogKgogKiAvLyB0aGlzIGhhcyBhIHJpc2sgb2Ygc3RhY2sgb3ZlcmZsb3dzIGlmIG1hbnkgcmVzdWx0cyBhcmUgY2FjaGVkIGluIGEgcm93CiAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBzb21ldGltZXNBc3luYywgZG9uZSk7CiAqCiAqIC8vIHRoaXMgd2lsbCBkZWZlciBzb21ldGltZXNBc3luYydzIGNhbGxiYWNrIGlmIG5lY2Vzc2FyeSwKICogLy8gcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3MKICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIGFzeW5jLmVuc3VyZUFzeW5jKHNvbWV0aW1lc0FzeW5jKSwgZG9uZSk7CiAqLwpmdW5jdGlvbiBlbnN1cmVBc3luYyhmbikgewogICAgaWYgKGlzQXN5bmMoZm4pKSByZXR1cm4gZm47CiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgc3luYyA9IHRydWU7CiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IGFyZ3VtZW50czsKICAgICAgICAgICAgaWYgKHN5bmMpIHsKICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBpbm5lckFyZ3MpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBpbm5lckFyZ3MpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7CiAgICAgICAgc3luYyA9IGZhbHNlOwogICAgfSk7Cn0KCmZ1bmN0aW9uIG5vdElkKHYpIHsKICAgIHJldHVybiAhdjsKfQoKLyoqCiAqIFJldHVybnMgYHRydWVgIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LiBJZiBhbnkKICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLgogKgogKiBAbmFtZSBldmVyeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgYWxsCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9uIGluIHBhcmFsbGVsLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAKICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZXZlcnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7CiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGlmIHJlc3VsdCBpcyB0cnVlIHRoZW4gZXZlcnkgZmlsZSBleGlzdHMKICogfSk7CiAqLwp2YXIgZXZlcnkgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIobm90SWQsIG5vdElkKSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BldmVyeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGV2ZXJ5TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0KICogQGFsaWFzIGFsbExpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gcGFyYWxsZWwuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYAogKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KdmFyIGV2ZXJ5TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGV2ZXJ5U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9CiAqIEBhbGlhcyBhbGxTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gc2VyaWVzLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAKICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCnZhciBldmVyeVNlcmllcyA9IGRvTGltaXQoZXZlcnlMaW1pdCwgMSk7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkgewogIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHsKICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldOwogIH07Cn0KCmZ1bmN0aW9uIGZpbHRlckFycmF5KGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciB0cnV0aFZhbHVlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsKICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHsKICAgICAgICBpdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCB2KSB7CiAgICAgICAgICAgIHRydXRoVmFsdWVzW2luZGV4XSA9ICEhdjsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmICh0cnV0aFZhbHVlc1tpXSkgcmVzdWx0cy5wdXNoKGFycltpXSk7CiAgICAgICAgfQogICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpOwogICAgfSk7Cn0KCmZ1bmN0aW9uIGZpbHRlckdlbmVyaWMoZWFjaGZuLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciByZXN1bHRzID0gW107CiAgICBlYWNoZm4oY29sbCwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykgewogICAgICAgIGl0ZXJhdGVlKHgsIGZ1bmN0aW9uIChlcnIsIHYpIHsKICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmICh2KSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtpbmRleDogaW5kZXgsIHZhbHVlOiB4fSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjYWxsYmFjaygpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGFycmF5TWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikgewogICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4OwogICAgICAgICAgICB9KSwgYmFzZVByb3BlcnR5KCd2YWx1ZScpKSk7CiAgICAgICAgfQogICAgfSk7Cn0KCmZ1bmN0aW9uIF9maWx0ZXIoZWFjaGZuLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciBmaWx0ZXIgPSBpc0FycmF5TGlrZShjb2xsKSA/IGZpbHRlckFycmF5IDogZmlsdGVyR2VuZXJpYzsKICAgIGZpbHRlcihlYWNoZm4sIGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrIHx8IG5vb3ApOwp9CgovKioKICogUmV0dXJucyBhIG5ldyBhcnJheSBvZiBhbGwgdGhlIHZhbHVlcyBpbiBgY29sbGAgd2hpY2ggcGFzcyBhbiBhc3luYyB0cnV0aAogKiB0ZXN0LiBUaGlzIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlCiAqIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBvcmlnaW5hbC4KICoKICogQG5hbWUgZmlsdGVyCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBzZWxlY3QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZmlsdGVyKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBleGlzdGluZyBmaWxlcwogKiB9KTsKICovCnZhciBmaWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIGZpbHRlckxpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0KICogQGFsaWFzIHNlbGVjdExpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCnZhciBmaWx0ZXJMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfZmlsdGVyKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZmlsdGVyU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0KICogQGFsaWFzIHNlbGVjdFNlcmllcwogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWQKICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpCiAqLwp2YXIgZmlsdGVyU2VyaWVzID0gZG9MaW1pdChmaWx0ZXJMaW1pdCwgMSk7CgovKioKICogQ2FsbHMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBgZm5gIHdpdGggYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBhbGxvd3MgaXQKICogdG8gY2FsbCBpdHNlbGYgYWdhaW4sIGluIHNlcmllcywgaW5kZWZpbml0ZWx5LgoKICogSWYgYW4gZXJyb3IgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayB0aGVuIGBlcnJiYWNrYCBpcyBjYWxsZWQgd2l0aCB0aGUKICogZXJyb3IsIGFuZCBleGVjdXRpb24gc3RvcHMsIG90aGVyd2lzZSBpdCB3aWxsIG5ldmVyIGJlIGNhbGxlZC4KICoKICogQG5hbWUgZm9yZXZlcgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBhbiBhc3luYyBmdW5jdGlvbiB0byBjYWxsIHJlcGVhdGVkbHkuCiAqIEludm9rZWQgd2l0aCAobmV4dCkuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJiYWNrXSAtIHdoZW4gYGZuYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXQncyBjYWxsYmFjaywKICogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCwgYW5kIGV4ZWN1dGlvbiBzdG9wcy4gSW52b2tlZCB3aXRoIChlcnIpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5mb3JldmVyKAogKiAgICAgZnVuY3Rpb24obmV4dCkgewogKiAgICAgICAgIC8vIG5leHQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gdGhpbmdzIHRoYXQgbmVlZCBhIGNhbGxiYWNrKGVyciBbLCB3aGF0ZXZlcl0pOwogKiAgICAgICAgIC8vIGl0IHdpbGwgcmVzdWx0IGluIHRoaXMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGFnYWluLgogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGVycikgewogKiAgICAgICAgIC8vIGlmIG5leHQgaXMgY2FsbGVkIHdpdGggYSB2YWx1ZSBpbiBpdHMgZmlyc3QgcGFyYW1ldGVyLCBpdCB3aWxsIGFwcGVhcgogKiAgICAgICAgIC8vIGluIGhlcmUgYXMgJ2VycicsIGFuZCBleGVjdXRpb24gd2lsbCBzdG9wLgogKiAgICAgfQogKiApOwogKi8KZnVuY3Rpb24gZm9yZXZlcihmbiwgZXJyYmFjaykgewogICAgdmFyIGRvbmUgPSBvbmx5T25jZShlcnJiYWNrIHx8IG5vb3ApOwogICAgdmFyIHRhc2sgPSB3cmFwQXN5bmMoZW5zdXJlQXN5bmMoZm4pKTsKCiAgICBmdW5jdGlvbiBuZXh0KGVycikgewogICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7CiAgICAgICAgdGFzayhuZXh0KTsKICAgIH0KICAgIG5leHQoKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICoKICogQG5hbWUgZ3JvdXBCeUxpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzCiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LgogKi8KdmFyIGdyb3VwQnlMaW1pdCA9IGZ1bmN0aW9uKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgbWFwTGltaXQoY29sbCwgbGltaXQsIGZ1bmN0aW9uKHZhbCwgY2FsbGJhY2spIHsKICAgICAgICBfaXRlcmF0ZWUodmFsLCBmdW5jdGlvbihlcnIsIGtleSkgewogICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtrZXk6IGtleSwgdmFsOiB2YWx9KTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uKGVyciwgbWFwUmVzdWx0cykgewogICAgICAgIHZhciByZXN1bHQgPSB7fTsKICAgICAgICAvLyBmcm9tIE1ETiwgaGFuZGxlIG9iamVjdCBoYXZpbmcgYW4gYGhhc093blByb3BlcnR5YCBwcm9wCiAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBSZXN1bHRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChtYXBSZXN1bHRzW2ldKSB7CiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWFwUmVzdWx0c1tpXS5rZXk7CiAgICAgICAgICAgICAgICB2YXIgdmFsID0gbWFwUmVzdWx0c1tpXS52YWw7CgogICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWwpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IFt2YWxdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpOwogICAgfSk7Cn07CgovKioKICogUmV0dXJucyBhIG5ldyBvYmplY3QsIHdoZXJlIGVhY2ggdmFsdWUgY29ycmVzcG9uZHMgdG8gYW4gYXJyYXkgb2YgaXRlbXMsIGZyb20KICogYGNvbGxgLCB0aGF0IHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS4gVGhhdCBpcywgdGhlIGtleXMgb2YgdGhlIG9iamVjdAogKiBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZWVgIGNhbGxiYWNrLgogKgogKiBOb3RlOiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLAogKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci4KICogSG93ZXZlciwgdGhlIHZhbHVlcyBmb3IgZWFjaCBrZXkgaW4gdGhlIGByZXN1bHRgIHdpbGwgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMKICogdGhlIG9yaWdpbmFsIGBjb2xsYC4gRm9yIE9iamVjdHMsIHRoZSB2YWx1ZXMgd2lsbCByb3VnaGx5IGJlIGluIHRoZSBvcmRlciBvZgogKiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuCiAqCiAqIEBuYW1lIGdyb3VwQnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXMKICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmdyb3VwQnkoWyd1c2VySWQxJywgJ3VzZXJJZDInLCAndXNlcklkMyddLCBmdW5jdGlvbih1c2VySWQsIGNhbGxiYWNrKSB7CiAqICAgICBkYi5maW5kQnlJZCh1c2VySWQsIGZ1bmN0aW9uKGVyciwgdXNlcikgewogKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1c2VyLmFnZSk7CiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgdXNlcklkcyBncm91cGVkIGJ5IGFnZQogKiAgICAgLy8gZS5nLiB7IDMwOiBbJ3VzZXJJZDEnLCAndXNlcklkMyddLCA0MjogWyd1c2VySWQyJ119OwogKiB9KTsKICovCnZhciBncm91cEJ5ID0gZG9MaW1pdChncm91cEJ5TGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBncm91cEJ5U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzCiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LgogKi8KdmFyIGdyb3VwQnlTZXJpZXMgPSBkb0xpbWl0KGdyb3VwQnlMaW1pdCwgMSk7CgovKioKICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIGBhc3luY2AgZnVuY3Rpb24gdG8gdGhlIGBjb25zb2xlYC4gT25seSB3b3JrcyBpbgogKiBOb2RlLmpzIG9yIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgY29uc29sZS5sb2dgIGFuZCBgY29uc29sZS5lcnJvcmAgKHN1Y2gKICogYXMgRkYgYW5kIENocm9tZSkuIElmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgYXN5bmMKICogZnVuY3Rpb24sIGBjb25zb2xlLmxvZ2AgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuCiAqCiAqIEBuYW1lIGxvZwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHkKICogYWxsIGFyZ3VtZW50cyB0by4KICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uCiAqIEBleGFtcGxlCiAqCiAqIC8vIGluIGEgbW9kdWxlCiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7CiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdoZWxsbyAnICsgbmFtZSk7CiAqICAgICB9LCAxMDAwKTsKICogfTsKICoKICogLy8gaW4gdGhlIG5vZGUgcmVwbAogKiBub2RlPiBhc3luYy5sb2coaGVsbG8sICd3b3JsZCcpOwogKiAnaGVsbG8gd29ybGQnCiAqLwp2YXIgbG9nID0gY29uc29sZUZ1bmMoJ2xvZycpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIG1hcFZhbHVlc0xpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5CiAqIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmcKICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KZnVuY3Rpb24gbWFwVmFsdWVzTGltaXQob2JqLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgbmV3T2JqID0ge307CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIGVhY2hPZkxpbWl0KG9iaiwgbGltaXQsIGZ1bmN0aW9uKHZhbCwga2V5LCBuZXh0KSB7CiAgICAgICAgX2l0ZXJhdGVlKHZhbCwga2V5LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKTsKICAgICAgICAgICAgbmV3T2JqW2tleV0gPSByZXN1bHQ7CiAgICAgICAgICAgIG5leHQoKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIG5ld09iaik7CiAgICB9KTsKfQoKLyoqCiAqIEEgcmVsYXRpdmUgb2YgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSwgZGVzaWduZWQgZm9yIHVzZSB3aXRoIG9iamVjdHMuCiAqCiAqIFByb2R1Y2VzIGEgbmV3IE9iamVjdCBieSBtYXBwaW5nIGVhY2ggdmFsdWUgb2YgYG9iamAgdGhyb3VnaCB0aGUgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIGVhY2ggYHZhbHVlYCBhbmQgYGtleWAgZnJvbSBgb2JqYCBhbmQgYQogKiBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3MgdGFrZXMKICogdHdvIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYG9iamAuIElmIGBpdGVyYXRlZWAKICogcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgbWFwVmFsdWVzYAogKiBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLgogKgogKiBOb3RlLCB0aGUgb3JkZXIgb2YgdGhlIGtleXMgaW4gdGhlIHJlc3VsdCBpcyBub3QgZ3VhcmFudGVlZC4gIFRoZSBrZXlzIHdpbGwKICogYmUgcm91Z2hseSBpbiB0aGUgb3JkZXIgdGhleSBjb21wbGV0ZSwgKGJ1dCB0aGlzIGlzIHZlcnkgZW5naW5lLXNwZWNpZmljKQogKgogKiBAbmFtZSBtYXBWYWx1ZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleQogKiBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nCiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMubWFwVmFsdWVzKHsKICogICAgIGYxOiAnZmlsZTEnLAogKiAgICAgZjI6ICdmaWxlMicsCiAqICAgICBmMzogJ2ZpbGUzJwogKiB9LCBmdW5jdGlvbiAoZmlsZSwga2V5LCBjYWxsYmFjaykgewogKiAgIGZzLnN0YXQoZmlsZSwgY2FsbGJhY2spOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGlzIG5vdyBhIG1hcCBvZiBzdGF0cyBmb3IgZWFjaCBmaWxlLCBlLmcuCiAqICAgICAvLyB7CiAqICAgICAvLyAgICAgZjE6IFtzdGF0cyBmb3IgZmlsZTFdLAogKiAgICAgLy8gICAgIGYyOiBbc3RhdHMgZm9yIGZpbGUyXSwKICogICAgIC8vICAgICBmMzogW3N0YXRzIGZvciBmaWxlM10KICogICAgIC8vIH0KICogfSk7CiAqLwoKdmFyIG1hcFZhbHVlcyA9IGRvTGltaXQobWFwVmFsdWVzTGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYG1hcFZhbHVlc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgbWFwVmFsdWVzU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleQogKiBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nCiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCnZhciBtYXBWYWx1ZXNTZXJpZXMgPSBkb0xpbWl0KG1hcFZhbHVlc0xpbWl0LCAxKTsKCmZ1bmN0aW9uIGhhcyhvYmosIGtleSkgewogICAgcmV0dXJuIGtleSBpbiBvYmo7Cn0KCi8qKgogKiBDYWNoZXMgdGhlIHJlc3VsdHMgb2YgYW4gYXN5bmMgZnVuY3Rpb24uIFdoZW4gY3JlYXRpbmcgYSBoYXNoIHRvIHN0b3JlCiAqIGZ1bmN0aW9uIHJlc3VsdHMgYWdhaW5zdCwgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgZnJvbSB0aGUgaGFzaCBhbmQgYW4KICogb3B0aW9uYWwgaGFzaCBmdW5jdGlvbiBjYW4gYmUgdXNlZC4KICoKICogSWYgbm8gaGFzaCBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGFzaCBrZXksCiAqIHdoaWNoIG1heSB3b3JrIHJlYXNvbmFibHkgaWYgaXQgaXMgYSBzdHJpbmcgb3IgYSBkYXRhIHR5cGUgdGhhdCBjb252ZXJ0cyB0byBhCiAqIGRpc3RpbmN0IHN0cmluZy4gTm90ZSB0aGF0IG9iamVjdHMgYW5kIGFycmF5cyB3aWxsIG5vdCBiZWhhdmUgcmVhc29uYWJseS4KICogTmVpdGhlciB3aWxsIGNhc2VzIHdoZXJlIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHNpZ25pZmljYW50LiBJbiBzdWNoIGNhc2VzLAogKiBzcGVjaWZ5IHlvdXIgb3duIGhhc2ggZnVuY3Rpb24uCiAqCiAqIFRoZSBjYWNoZSBvZiByZXN1bHRzIGlzIGV4cG9zZWQgYXMgdGhlIGBtZW1vYCBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb24KICogcmV0dXJuZWQgYnkgYG1lbW9pemVgLgogKgogKiBAbmFtZSBtZW1vaXplCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gcHJveHkgYW5kIGNhY2hlIHJlc3VsdHMgZnJvbS4KICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaGVyIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSBjdXN0b20gaGFzaAogKiBmb3Igc3RvcmluZyByZXN1bHRzLiBJdCBoYXMgYWxsIHRoZSBhcmd1bWVudHMgYXBwbGllZCB0byBpdCBhcGFydCBmcm9tIHRoZQogKiBjYWxsYmFjaywgYW5kIG11c3QgYmUgc3luY2hyb25vdXMuCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIG1lbW9pemVkIHZlcnNpb24gb2YgYGZuYAogKiBAZXhhbXBsZQogKgogKiB2YXIgc2xvd19mbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcKICogICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7CiAqIH07CiAqIHZhciBmbiA9IGFzeW5jLm1lbW9pemUoc2xvd19mbik7CiAqCiAqIC8vIGZuIGNhbiBub3cgYmUgdXNlZCBhcyBpZiBpdCB3ZXJlIHNsb3dfZm4KICogZm4oJ3NvbWUgbmFtZScsIGZ1bmN0aW9uKCkgewogKiAgICAgLy8gY2FsbGJhY2sKICogfSk7CiAqLwpmdW5jdGlvbiBtZW1vaXplKGZuLCBoYXNoZXIpIHsKICAgIHZhciBtZW1vID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgIHZhciBxdWV1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgaGFzaGVyID0gaGFzaGVyIHx8IGlkZW50aXR5OwogICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7CiAgICB2YXIgbWVtb2l6ZWQgPSBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIG1lbW9pemVkKGFyZ3MsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTsKICAgICAgICBpZiAoaGFzKG1lbW8sIGtleSkpIHsKICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pOwogICAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKGhhcyhxdWV1ZXMsIGtleSkpIHsKICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdOwogICAgICAgICAgICBfZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoZnVuY3Rpb24oLyphcmdzKi8pIHsKICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTsKICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3M7CiAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldOwogICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldOwogICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJncyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pKTsKICAgICAgICB9CiAgICB9KTsKICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vOwogICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuOwogICAgcmV0dXJuIG1lbW9pemVkOwp9CgovKioKICogQ2FsbHMgYGNhbGxiYWNrYCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kIHRoZSBldmVudCBsb29wLiBJbiBOb2RlLmpzIHRoaXMganVzdAogKiBjYWxscyBgcHJvY2Vzcy5uZXh0VGlja2AuICBJbiB0aGUgYnJvd3NlciBpdCB3aWxsIHVzZSBgc2V0SW1tZWRpYXRlYCBpZgogKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXIKICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC4KICoKICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy4KICoKICogQG5hbWUgbmV4dFRpY2sKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuc2V0SW1tZWRpYXRlXXtAbGluayBtb2R1bGU6VXRpbHMuc2V0SW1tZWRpYXRlfQogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGEgbGF0ZXIgbG9vcCBhcm91bmQKICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuCiAqIEBwYXJhbSB7Li4uKn0gYXJncy4uLiAtIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUKICogY2FsbGJhY2sgb24gdGhlIG5leHQgdGljay4KICogQGV4YW1wbGUKICoKICogdmFyIGNhbGxfb3JkZXIgPSBbXTsKICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7CiAqICAgICBjYWxsX29yZGVyLnB1c2goJ3R3bycpOwogKiAgICAgLy8gY2FsbF9vcmRlciBub3cgZXF1YWxzIFsnb25lJywndHdvJ10KICogfSk7CiAqIGNhbGxfb3JkZXIucHVzaCgnb25lJyk7CiAqCiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykgewogKiAgICAgLy8gYSwgYiwgYW5kIGMgZXF1YWwgMSwgMiwgYW5kIDMKICogfSwgMSwgMiwgMyk7CiAqLwp2YXIgX2RlZmVyJDE7CgppZiAoaGFzTmV4dFRpY2spIHsKICAgIF9kZWZlciQxID0gcHJvY2Vzcy5uZXh0VGljazsKfSBlbHNlIGlmIChoYXNTZXRJbW1lZGlhdGUpIHsKICAgIF9kZWZlciQxID0gc2V0SW1tZWRpYXRlOwp9IGVsc2UgewogICAgX2RlZmVyJDEgPSBmYWxsYmFjazsKfQoKdmFyIG5leHRUaWNrID0gd3JhcChfZGVmZXIkMSk7CgpmdW5jdGlvbiBfcGFyYWxsZWwoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIHZhciByZXN1bHRzID0gaXNBcnJheUxpa2UodGFza3MpID8gW10gOiB7fTsKCiAgICBlYWNoZm4odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXksIGNhbGxiYWNrKSB7CiAgICAgICAgd3JhcEFzeW5jKHRhc2spKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgewogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzdWx0OwogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVycikgewogICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7CiAgICB9KTsKfQoKLyoqCiAqIFJ1biB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsCiAqIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBwYXNzIGFuIGVycm9yIHRvCiAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlCiAqIGVycm9yLiBPbmNlIHRoZSBgdGFza3NgIGhhdmUgY29tcGxldGVkLCB0aGUgcmVzdWx0cyBhcmUgcGFzc2VkIHRvIHRoZSBmaW5hbAogKiBgY2FsbGJhY2tgIGFzIGFuIGFycmF5LgogKgogKiAqKk5vdGU6KiogYHBhcmFsbGVsYCBpcyBhYm91dCBraWNraW5nLW9mZiBJL08gdGFza3MgaW4gcGFyYWxsZWwsIG5vdCBhYm91dAogKiBwYXJhbGxlbCBleGVjdXRpb24gb2YgY29kZS4gIElmIHlvdXIgdGFza3MgZG8gbm90IHVzZSBhbnkgdGltZXJzIG9yIHBlcmZvcm0KICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cAogKiBzZWN0aW9ucyBmb3IgZWFjaCB0YXNrIHdpbGwgaGFwcGVuIG9uZSBhZnRlciB0aGUgb3RoZXIuICBKYXZhU2NyaXB0IHJlbWFpbnMKICogc2luZ2xlLXRocmVhZGVkLgogKgogKiAqKkhpbnQ6KiogVXNlIFtgcmVmbGVjdGBde0BsaW5rIG1vZHVsZTpVdGlscy5yZWZsZWN0fSB0byBjb250aW51ZSB0aGUKICogZXhlY3V0aW9uIG9mIG90aGVyIHRhc2tzIHdoZW4gYSB0YXNrIGZhaWxzLgogKgogKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsCiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYAogKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZwogKiByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnBhcmFsbGVsfS4KICoKICogQG5hbWUgcGFyYWxsZWwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gb2YKICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLgogKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5CiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICoKICogQGV4YW1wbGUKICogYXN5bmMucGFyYWxsZWwoWwogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiBdLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgZXF1YWwgWydvbmUnLCd0d28nXSBldmVuIHRob3VnaAogKiAgICAgLy8gdGhlIHNlY29uZCBmdW5jdGlvbiBoYWQgYSBzaG9ydGVyIHRpbWVvdXQuCiAqIH0pOwogKgogKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5CiAqIGFzeW5jLnBhcmFsbGVsKHsKICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFscyB0bzoge29uZTogMSwgdHdvOiAyfQogKiB9KTsKICovCmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQodGFza3MsIGNhbGxiYWNrKSB7CiAgICBfcGFyYWxsZWwoZWFjaE9mLCB0YXNrcywgY2FsbGJhY2spOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2BwYXJhbGxlbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIHBhcmFsbGVsTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gb2YKICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLgogKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlCiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXkKICogKG9yIG9iamVjdCkgY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSB0YXNrIGNhbGxiYWNrcy4KICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKi8KZnVuY3Rpb24gcGFyYWxsZWxMaW1pdCQxKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHsKICAgIF9wYXJhbGxlbChfZWFjaE9mTGltaXQobGltaXQpLCB0YXNrcywgY2FsbGJhY2spOwp9CgovKioKICogQSBxdWV1ZSBvZiB0YXNrcyBmb3IgdGhlIHdvcmtlciBmdW5jdGlvbiB0byBjb21wbGV0ZS4KICogQHR5cGVkZWYge09iamVjdH0gUXVldWVPYmplY3QKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsZW5ndGggLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zCiAqIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUubGVuZ3RoKClgLgogKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnkKICogaXRlbXMgaGF2ZSBiZWVuIHB1c2hlZCBhbmQgcHJvY2Vzc2VkIGJ5IHRoZSBxdWV1ZS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcnVubmluZyAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgaXRlbXMKICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHdvcmtlcnNMaXN0IC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGFycmF5IG9mIGl0ZW1zCiAqIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS53b3JrZXJzTGlzdCgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtcwogKiB3YWl0aW5nIG9yIGJlaW5nIHByb2Nlc3NlZCwgb3IgdHJ1ZSBpZiBub3QuIEludm9rZSB3aXRoIGBxdWV1ZS5pZGxlKClgLgogKiBAcHJvcGVydHkge251bWJlcn0gY29uY3VycmVuY3kgLSBhbiBpbnRlZ2VyIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSBgd29ya2VyYAogKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhCiAqIGBxdWV1ZWAgaXMgY3JlYXRlZCB0byBhbHRlciB0aGUgY29uY3VycmVuY3kgb24tdGhlLWZseS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcHVzaCAtIGFkZCBhIG5ldyB0YXNrIHRvIHRoZSBgcXVldWVgLiBDYWxscyBgY2FsbGJhY2tgCiAqIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEgc2luZ2xlIHRhc2ssCiAqIGEgYHRhc2tzYCBhcnJheSBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpcyB1c2VkIGZvciBldmVyeQogKiB0YXNrIGluIHRoZSBsaXN0LiBJbnZva2Ugd2l0aCBgcXVldWUucHVzaCh0YXNrLCBbY2FsbGJhY2tdKWAsCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuCiAqIEludm9rZSB3aXRoIGBxdWV1ZS51bnNoaWZ0KHRhc2ssIFtjYWxsYmFja10pYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVtb3ZlIC0gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHF1ZXVlIHRoYXQgbWF0Y2ggYSB0ZXN0CiAqIGZ1bmN0aW9uLiAgVGhlIHRlc3QgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYW4gb2JqZWN0IHdpdGggYSBgZGF0YWAgcHJvcGVydHksCiAqIGFuZCBhIGBwcmlvcml0eWAgcHJvcGVydHksIGlmIHRoaXMgaXMgYQogKiBbcHJpb3JpdHlRdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnByaW9yaXR5UXVldWV9IG9iamVjdC4KICogSW52b2tlZCB3aXRoIGBxdWV1ZS5yZW1vdmUodGVzdEZuKWAsIHdoZXJlIGB0ZXN0Rm5gIGlzIG9mIHRoZSBmb3JtCiAqIGBmdW5jdGlvbiAoe2RhdGEsIHByaW9yaXR5fSkge31gIGFuZCByZXR1cm5zIGEgQm9vbGVhbi4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBudW1iZXIgb2YKICogcnVubmluZyB3b3JrZXJzIGhpdHMgdGhlIGBjb25jdXJyZW5jeWAgbGltaXQsIGFuZCBmdXJ0aGVyIHRhc2tzIHdpbGwgYmUKICogcXVldWVkLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1bnNhdHVyYXRlZCAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyCiAqIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJiBgYnVmZmVyYCBsaW1pdHMsIGFuZAogKiBmdXJ0aGVyIHRhc2tzIHdpbGwgbm90IGJlIHF1ZXVlZC4KICogQHByb3BlcnR5IHtudW1iZXJ9IGJ1ZmZlciAtIEEgbWluaW11bSB0aHJlc2hvbGQgYnVmZmVyIGluIG9yZGVyIHRvIHNheSB0aGF0CiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW0KICogZnJvbSB0aGUgYHF1ZXVlYCBpcyBnaXZlbiB0byBhIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtCiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlcnJvciAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHRhc2sgZXJyb3JzLgogKiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC4KICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZWQgLSBhIGJvb2xlYW4gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHF1ZXVlIGlzCiAqIGluIGEgcGF1c2VkIHN0YXRlLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3MKICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5wYXVzZSgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVzdW1lIC0gYSBmdW5jdGlvbiB0aGF0IHJlc3VtZXMgdGhlIHByb2Nlc3Npbmcgb2YKICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZAogKiBlbXB0aWVzIHJlbWFpbmluZyB0YXNrcyBmcm9tIHRoZSBxdWV1ZSBmb3JjaW5nIGl0IHRvIGdvIGlkbGUuIE5vIG1vcmUgdGFza3MKICogc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgcXVldWUgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBJbnZva2Ugd2l0aCBgcXVldWUua2lsbCgpYC4KICovCgovKioKICogQ3JlYXRlcyBhIGBxdWV1ZWAgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBgY29uY3VycmVuY3lgLiBUYXNrcyBhZGRlZCB0byB0aGUKICogYHF1ZXVlYCBhcmUgcHJvY2Vzc2VkIGluIHBhcmFsbGVsICh1cCB0byB0aGUgYGNvbmN1cnJlbmN5YCBsaW1pdCkuIElmIGFsbAogKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLgogKiBPbmNlIGEgYHdvcmtlcmAgY29tcGxldGVzIGEgYHRhc2tgLCB0aGF0IGB0YXNrYCdzIGNhbGxiYWNrIGlzIGNhbGxlZC4KICoKICogQG5hbWUgcXVldWUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGEgcXVldWVkIHRhc2suCiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0bwogKiBgcS5wdXNoKClgLiBJbnZva2VkIHdpdGggKHRhc2ssIGNhbGxiYWNrKS4KICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT0xXSAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkKICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3kKICogZGVmYXVsdHMgdG8gYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLgogKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LlF1ZXVlT2JqZWN0fSBBIHF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBDYWxsYmFja3MgY2FuCiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlCiAqIGxpZmVjeWNsZSBvZiB0aGUgcXVldWUuCiAqIEBleGFtcGxlCiAqCiAqIC8vIGNyZWF0ZSBhIHF1ZXVlIG9iamVjdCB3aXRoIGNvbmN1cnJlbmN5IDIKICogdmFyIHEgPSBhc3luYy5xdWV1ZShmdW5jdGlvbih0YXNrLCBjYWxsYmFjaykgewogKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpOwogKiAgICAgY2FsbGJhY2soKTsKICogfSwgMik7CiAqCiAqIC8vIGFzc2lnbiBhIGNhbGxiYWNrCiAqIHEuZHJhaW4gPSBmdW5jdGlvbigpIHsKICogICAgIGNvbnNvbGUubG9nKCdhbGwgaXRlbXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCcpOwogKiB9OwogKgogKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWUKICogcS5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgZm9vJyk7CiAqIH0pOwogKiBxLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7CiAqIH0pOwogKgogKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWUgKGJhdGNoLXdpc2UpCiAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGl0ZW0nKTsKICogfSk7CiAqCiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWUKICogcS51bnNoaWZ0KHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpOwogKiB9KTsKICovCnZhciBxdWV1ZSQxID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHsKICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7CiAgICByZXR1cm4gcXVldWUoZnVuY3Rpb24gKGl0ZW1zLCBjYikgewogICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTsKICAgIH0sIGNvbmN1cnJlbmN5LCAxKTsKfTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0gb25seSB0YXNrcyBhcmUgYXNzaWduZWQgYSBwcmlvcml0eSBhbmQKICogY29tcGxldGVkIGluIGFzY2VuZGluZyBwcmlvcml0eSBvcmRlci4KICoKICogQG5hbWUgcHJpb3JpdHlRdWV1ZQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWQgdGFzay4KICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyBmcm9tIGFuIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvCiAqIGBxLnB1c2goKWAuCiAqIEludm9rZWQgd2l0aCAodGFzaywgY2FsbGJhY2spLgogKiBAcGFyYW0ge251bWJlcn0gY29uY3VycmVuY3kgLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgCiAqIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5IGRlZmF1bHRzIHRvCiAqIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi4KICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBwcmlvcml0eVF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBUaGVyZSBhcmUgdHdvCiAqIGRpZmZlcmVuY2VzIGJldHdlZW4gYHF1ZXVlYCBhbmQgYHByaW9yaXR5UXVldWVgIG9iamVjdHM6CiAqICogYHB1c2godGFzaywgcHJpb3JpdHksIFtjYWxsYmFja10pYCAtIGBwcmlvcml0eWAgc2hvdWxkIGJlIGEgbnVtYmVyLiBJZiBhbgogKiAgIGFycmF5IG9mIGB0YXNrc2AgaXMgZ2l2ZW4sIGFsbCB0YXNrcyB3aWxsIGJlIGFzc2lnbmVkIHRoZSBzYW1lIHByaW9yaXR5LgogKiAqIFRoZSBgdW5zaGlmdGAgbWV0aG9kIHdhcyByZW1vdmVkLgogKi8KdmFyIHByaW9yaXR5UXVldWUgPSBmdW5jdGlvbih3b3JrZXIsIGNvbmN1cnJlbmN5KSB7CiAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlCiAgICB2YXIgcSA9IHF1ZXVlJDEod29ya2VyLCBjb25jdXJyZW5jeSk7CgogICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHkKICAgIHEucHVzaCA9IGZ1bmN0aW9uKGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykgewogICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IG5vb3A7CiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CiAgICAgICAgfQogICAgICAgIHEuc3RhcnRlZCA9IHRydWU7CiAgICAgICAgaWYgKCFpc0FycmF5KGRhdGEpKSB7CiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07CiAgICAgICAgfQogICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrcwogICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlJDEoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBxLmRyYWluKCk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwOwogICAgICAgIHZhciBuZXh0Tm9kZSA9IHEuX3Rhc2tzLmhlYWQ7CiAgICAgICAgd2hpbGUgKG5leHROb2RlICYmIHByaW9yaXR5ID49IG5leHROb2RlLnByaW9yaXR5KSB7CiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dDsKICAgICAgICB9CgogICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgdmFyIGl0ZW0gPSB7CiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhW2ldLAogICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LAogICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrCiAgICAgICAgICAgIH07CgogICAgICAgICAgICBpZiAobmV4dE5vZGUpIHsKICAgICAgICAgICAgICAgIHEuX3Rhc2tzLmluc2VydEJlZm9yZShuZXh0Tm9kZSwgaXRlbSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHNldEltbWVkaWF0ZSQxKHEucHJvY2Vzcyk7CiAgICB9OwoKICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uCiAgICBkZWxldGUgcS51bnNoaWZ0OwoKICAgIHJldHVybiBxOwp9OwoKLyoqCiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlCiAqIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIE9uY2UgYW55IG9mIHRoZSBgdGFza3NgIGNvbXBsZXRlIG9yIHBhc3MgYW4KICogZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZC4gSXQncwogKiBlcXVpdmFsZW50IHRvIGBQcm9taXNlLnJhY2UoKWAuCiAqCiAqIEBuYW1lIHJhY2UKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0KICogdG8gcnVuLiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFuIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYW55IG9mIHRoZSBmdW5jdGlvbnMgaGF2ZQogKiBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhbiBlcnJvciBvciByZXN1bHQgZnJvbSB0aGUgZmlyc3QgZnVuY3Rpb24gdGhhdAogKiBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKiBAcmV0dXJucyB1bmRlZmluZWQKICogQGV4YW1wbGUKICoKICogYXN5bmMucmFjZShbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgICAgIH0sIDEwMCk7CiAqICAgICB9CiAqIF0sCiAqIC8vIG1haW4gY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHRoZSByZXN1bHQgd2lsbCBiZSBlcXVhbCB0byAndHdvJyBhcyBpdCBmaW5pc2hlcyBlYXJsaWVyCiAqIH0pOwogKi8KZnVuY3Rpb24gcmFjZSh0YXNrcywgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byByYWNlIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpOwogICAgaWYgKCF0YXNrcy5sZW5ndGgpIHJldHVybiBjYWxsYmFjaygpOwogICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YXNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICB3cmFwQXN5bmModGFza3NbaV0pKGNhbGxiYWNrKTsKICAgIH0KfQoKLyoqCiAqIFNhbWUgYXMgW2ByZWR1Y2VgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVkdWNlfSwgb25seSBvcGVyYXRlcyBvbiBgYXJyYXlgIGluIHJldmVyc2Ugb3JkZXIuCiAqCiAqIEBuYW1lIHJlZHVjZVJpZ2h0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnJlZHVjZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX0KICogQGFsaWFzIGZvbGRyCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlCiAqIGFycmF5IHRvIHByb2R1Y2UgdGhlIG5leHQgc3RlcCBpbiB0aGUgcmVkdWN0aW9uLgogKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLgogKiBJZiB0aGUgaXRlcmF0ZWUgY29tcGxldGUgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGUKICogbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci4KICogSW52b2tlZCB3aXRoIChtZW1vLCBpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCBpcyB0aGUgcmVkdWNlZCB2YWx1ZS4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqLwpmdW5jdGlvbiByZWR1Y2VSaWdodCAoYXJyYXksIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIHJldmVyc2VkID0gc2xpY2UoYXJyYXkpLnJldmVyc2UoKTsKICAgIHJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFdyYXBzIHRoZSBhc3luYyBmdW5jdGlvbiBpbiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIGNvbXBsZXRlcyB3aXRoIGEKICogcmVzdWx0IG9iamVjdCwgZXZlbiB3aGVuIGl0IGVycm9ycy4KICoKICogVGhlIHJlc3VsdCBvYmplY3QgaGFzIGVpdGhlciB0aGUgcHJvcGVydHkgYGVycm9yYCBvciBgdmFsdWVgLgogKgogKiBAbmFtZSByZWZsZWN0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24geW91IHdhbnQgdG8gd3JhcAogKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyBwYXNzZXMgbnVsbCB0byBpdCdzIGNhbGxiYWNrIGFzCiAqIHRoZSBlcnJvci4gVGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgd2lsbCBiZSBhbiBgb2JqZWN0YCB3aXRoCiAqIGVpdGhlciBhbiBgZXJyb3JgIG9yIGEgYHZhbHVlYCBwcm9wZXJ0eS4KICogQGV4YW1wbGUKICoKICogYXN5bmMucGFyYWxsZWwoWwogKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgfSksCiAqICAgICBhc3luYy5yZWZsZWN0KGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIGJ1dCBlcnJvciAuLi4KICogICAgICAgICBjYWxsYmFjaygnYmFkIHN0dWZmIGhhcHBlbmVkJyk7CiAqICAgICB9KSwKICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgfSkKICogXSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyB2YWx1ZXMKICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJwogKiAgICAgLy8gcmVzdWx0c1sxXS5lcnJvciA9ICdiYWQgc3R1ZmYgaGFwcGVuZWQnCiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bycKICogfSk7CiAqLwpmdW5jdGlvbiByZWZsZWN0KGZuKSB7CiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGZuKTsKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIHJlZmxlY3RPbihhcmdzLCByZWZsZWN0Q2FsbGJhY2spIHsKICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gY2FsbGJhY2soZXJyb3IsIGNiQXJnKSB7CiAgICAgICAgICAgIGlmIChlcnJvcikgewogICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgZXJyb3I6IGVycm9yIH0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFyIHZhbHVlOwogICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikgewogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2JBcmc7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJlZmxlY3RDYWxsYmFjayhudWxsLCB7IHZhbHVlOiB2YWx1ZSB9KTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfSk7Cn0KCi8qKgogKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdyYXBzIGFuIGFycmF5IG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgd2l0aCBgcmVmbGVjdGAuCiAqCiAqIEBuYW1lIHJlZmxlY3RBbGwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmVmbGVjdF17QGxpbmsgbW9kdWxlOlV0aWxzLnJlZmxlY3R9CiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fEl0ZXJhYmxlfSB0YXNrcyAtIFRoZSBjb2xsZWN0aW9uIG9mCiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHdyYXAgaW4gYGFzeW5jLnJlZmxlY3RgLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgYXN5bmMgZnVuY3Rpb25zLCBlYWNoIHdyYXBwZWQgaW4KICogYGFzeW5jLnJlZmxlY3RgCiAqIEBleGFtcGxlCiAqCiAqIGxldCB0YXNrcyA9IFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgICAgIH0sIDIwMCk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgYnV0IGVycm9yIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgICAgIH0sIDEwMCk7CiAqICAgICB9CiAqIF07CiAqCiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHZhbHVlcwogKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnCiAqICAgICAvLyByZXN1bHRzWzFdLmVycm9yID0gRXJyb3IoJ2JhZCBzdHVmZiBoYXBwZW5lZCcpCiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bycKICogfSk7CiAqCiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkKICogbGV0IHRhc2tzID0gewogKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBjYWxsYmFjaygndHdvJyk7CiAqICAgICB9LAogKiAgICAgdGhyZWU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogfTsKICoKICogYXN5bmMucGFyYWxsZWwoYXN5bmMucmVmbGVjdEFsbCh0YXNrcyksCiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrCiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gdmFsdWVzCiAqICAgICAvLyByZXN1bHRzLm9uZS52YWx1ZSA9ICdvbmUnCiAqICAgICAvLyByZXN1bHRzLnR3by5lcnJvciA9ICd0d28nCiAqICAgICAvLyByZXN1bHRzLnRocmVlLnZhbHVlID0gJ3RocmVlJwogKiB9KTsKICovCmZ1bmN0aW9uIHJlZmxlY3RBbGwodGFza3MpIHsKICAgIHZhciByZXN1bHRzOwogICAgaWYgKGlzQXJyYXkodGFza3MpKSB7CiAgICAgICAgcmVzdWx0cyA9IGFycmF5TWFwKHRhc2tzLCByZWZsZWN0KTsKICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0cyA9IHt9OwogICAgICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uKHRhc2ssIGtleSkgewogICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZWZsZWN0LmNhbGwodGhpcywgdGFzayk7CiAgICAgICAgfSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0czsKfQoKZnVuY3Rpb24gcmVqZWN0JDEoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgX2ZpbHRlcihlYWNoZm4sIGFyciwgZnVuY3Rpb24odmFsdWUsIGNiKSB7CiAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGZ1bmN0aW9uKGVyciwgdikgewogICAgICAgICAgICBjYihlcnIsICF2KTsKICAgICAgICB9KTsKICAgIH0sIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LgogKgogKiBAbmFtZSByZWplY3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICoKICogYXN5bmMucmVqZWN0KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIG1pc3NpbmcgZmlsZXMKICogICAgIGNyZWF0ZUZpbGVzKHJlc3VsdHMpOwogKiB9KTsKICovCnZhciByZWplY3QgPSBkb1BhcmFsbGVsKHJlamVjdCQxKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHJlamVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSByZWplY3RMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgcmVqZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQocmVqZWN0JDEpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSByZWplY3RTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmVqZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCnZhciByZWplY3RTZXJpZXMgPSBkb0xpbWl0KHJlamVjdExpbWl0LCAxKTsKCi8qKgogKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDIuNC4wCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLgogKiBAZXhhbXBsZQogKgogKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7CiAqCiAqIGNvbnNvbGUubG9nKG9iamVjdHMpOwogKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV0KICoKICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7CiAqIC8vID0+IHRydWUKICovCmZ1bmN0aW9uIGNvbnN0YW50JDEodmFsdWUpIHsKICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdmFsdWU7CiAgfTsKfQoKLyoqCiAqIEF0dGVtcHRzIHRvIGdldCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZnJvbSBgdGFza2Agbm8gbW9yZSB0aGFuIGB0aW1lc2AgdGltZXMKICogYmVmb3JlIHJldHVybmluZyBhbiBlcnJvci4gSWYgdGhlIHRhc2sgaXMgc3VjY2Vzc2Z1bCwgdGhlIGBjYWxsYmFja2Agd2lsbCBiZQogKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrCiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LgogKgogKiBAbmFtZSByZXRyeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBzZWUgW2FzeW5jLnJldHJ5YWJsZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5YWJsZX0KICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW4KICogb2JqZWN0IHdpdGggYHRpbWVzYCBhbmQgYGludGVydmFsYCBvciBhIG51bWJlci4KICogKiBgdGltZXNgIC0gVGhlIG51bWJlciBvZiBhdHRlbXB0cyB0byBtYWtlIGJlZm9yZSBnaXZpbmcgdXAuICBUaGUgZGVmYXVsdAogKiAgIGlzIGA1YC4KICogKiBgaW50ZXJ2YWxgIC0gVGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHJldHJpZXMsIGluIG1pbGxpc2Vjb25kcy4gIFRoZQogKiAgIGRlZmF1bHQgaXMgYDBgLiBUaGUgaW50ZXJ2YWwgbWF5IGFsc28gYmUgc3BlY2lmaWVkIGFzIGEgZnVuY3Rpb24gb2YgdGhlCiAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS4KICogKiBgZXJyb3JGaWx0ZXJgIC0gQW4gb3B0aW9uYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIG9uCiAqICAgZXJyb25lb3VzIHJlc3VsdC4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAgdGhlIHJldHJ5IGF0dGVtcHRzIHdpbGwgY29udGludWU7CiAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnQKICogICBhdHRlbXB0J3MgZXJyb3IgYW5kIHJlc3VsdCBiZWluZyByZXR1cm5lZCB0byB0aGUgZmluYWwgY2FsbGJhY2suCiAqICAgSW52b2tlZCB3aXRoIChlcnIpLgogKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSwKICogICB3aXRoIHRoZSBkZWZhdWx0IGludGVydmFsIG9mIGAwYC4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gcmV0cnkuCiAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlCiAqIHRhc2sgaGFzIHN1Y2NlZWRlZCwgb3IgYWZ0ZXIgdGhlIGZpbmFsIGZhaWxlZCBhdHRlbXB0LiBJdCByZWNlaXZlcyB0aGUgYGVycmAKICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZAogKiB3aXRoIChlcnIsIHJlc3VsdHMpLgogKgogKiBAZXhhbXBsZQogKgogKiAvLyBUaGUgYHJldHJ5YCBmdW5jdGlvbiBjYW4gYmUgdXNlZCBhcyBhIHN0YW5kLWFsb25lIGNvbnRyb2wgZmxvdyBieSBwYXNzaW5nCiAqIC8vIGEgY2FsbGJhY2ssIGFzIHNob3duIGJlbG93OgogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcwogKiBhc3luYy5yZXRyeSgzLCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcywgd2FpdGluZyAyMDAgbXMgYmV0d2VlbiBlYWNoIHJldHJ5CiAqIGFzeW5jLnJldHJ5KHt0aW1lczogMywgaW50ZXJ2YWw6IDIwMH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHQKICogfSk7CiAqCiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAxMCB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYKICogLy8gKGkuZS4gaW50ZXJ2YWxzIG9mIDEwMCwgMjAwLCA0MDAsIDgwMCwgMTYwMCwgLi4uIG1pbGxpc2Vjb25kcykKICogYXN5bmMucmV0cnkoewogKiAgIHRpbWVzOiAxMCwKICogICBpbnRlcnZhbDogZnVuY3Rpb24ocmV0cnlDb3VudCkgewogKiAgICAgcmV0dXJuIDUwICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7CiAqICAgfQogKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgdGhlIGRlZmF1bHQgNSB0aW1lcyBubyBkZWxheSBiZXR3ZWVuIGVhY2ggcmV0cnkKICogYXN5bmMucmV0cnkoYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdAogKiB9KTsKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIG9ubHkgd2hlbiBlcnJvciBjb25kaXRpb24gc2F0aXNmaWVzLCBhbGwgb3RoZXIKICogLy8gZXJyb3JzIHdpbGwgYWJvcnQgdGhlIHJldHJ5IGNvbnRyb2wgZmxvdyBhbmQgcmV0dXJuIHRvIGZpbmFsIGNhbGxiYWNrCiAqIGFzeW5jLnJldHJ5KHsKICogICBlcnJvckZpbHRlcjogZnVuY3Rpb24oZXJyKSB7CiAqICAgICByZXR1cm4gZXJyLm1lc3NhZ2UgPT09ICdUZW1wb3JhcnkgZXJyb3InOyAvLyBvbmx5IHJldHJ5IG9uIGEgc3BlY2lmaWMgZXJyb3IKICogICB9CiAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHQKICogfSk7CiAqCiAqIC8vIHRvIHJldHJ5IGluZGl2aWR1YWwgbWV0aG9kcyB0aGF0IGFyZSBub3QgYXMgcmVsaWFibGUgd2l0aGluIG90aGVyCiAqIC8vIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMsIHVzZSB0aGUgYHJldHJ5YWJsZWAgd3JhcHBlcjoKICogYXN5bmMuYXV0byh7CiAqICAgICB1c2VyczogYXBpLmdldFVzZXJzLmJpbmQoYXBpKSwKICogICAgIHBheW1lbnRzOiBhc3luYy5yZXRyeWFibGUoMywgYXBpLmdldFBheW1lbnRzLmJpbmQoYXBpKSkKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0cwogKiB9KTsKICoKICovCmZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7CiAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7CiAgICB2YXIgREVGQVVMVF9JTlRFUlZBTCA9IDA7CgogICAgdmFyIG9wdGlvbnMgPSB7CiAgICAgICAgdGltZXM6IERFRkFVTFRfVElNRVMsCiAgICAgICAgaW50ZXJ2YWxGdW5jOiBjb25zdGFudCQxKERFRkFVTFRfSU5URVJWQUwpCiAgICB9OwoKICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KSB7CiAgICAgICAgaWYgKHR5cGVvZiB0ID09PSAnb2JqZWN0JykgewogICAgICAgICAgICBhY2MudGltZXMgPSArdC50aW1lcyB8fCBERUZBVUxUX1RJTUVTOwoKICAgICAgICAgICAgYWNjLmludGVydmFsRnVuYyA9IHR5cGVvZiB0LmludGVydmFsID09PSAnZnVuY3Rpb24nID8KICAgICAgICAgICAgICAgIHQuaW50ZXJ2YWwgOgogICAgICAgICAgICAgICAgY29uc3RhbnQkMSgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTsKCiAgICAgICAgICAgIGFjYy5lcnJvckZpbHRlciA9IHQuZXJyb3JGaWx0ZXI7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgIGFjYy50aW1lcyA9ICt0IHx8IERFRkFVTFRfVElNRVM7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgYXN5bmMucmV0cnkiKTsKICAgICAgICB9CiAgICB9CgogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgY2FsbGJhY2sgPSB0YXNrIHx8IG5vb3A7CiAgICAgICAgdGFzayA9IG9wdHM7CiAgICB9IGVsc2UgewogICAgICAgIHBhcnNlVGltZXMob3B0aW9ucywgb3B0cyk7CiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wOwogICAgfQoKICAgIGlmICh0eXBlb2YgdGFzayAhPT0gJ2Z1bmN0aW9uJykgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5Iik7CiAgICB9CgogICAgdmFyIF90YXNrID0gd3JhcEFzeW5jKHRhc2spOwoKICAgIHZhciBhdHRlbXB0ID0gMTsKICAgIGZ1bmN0aW9uIHJldHJ5QXR0ZW1wdCgpIHsKICAgICAgICBfdGFzayhmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgaWYgKGVyciAmJiBhdHRlbXB0KysgPCBvcHRpb25zLnRpbWVzICYmCiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMuZXJyb3JGaWx0ZXIgIT0gJ2Z1bmN0aW9uJyB8fAogICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHsKICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmV0cnlBdHRlbXB0LCBvcHRpb25zLmludGVydmFsRnVuYyhhdHRlbXB0KSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9CgogICAgcmV0cnlBdHRlbXB0KCk7Cn0KCi8qKgogKiBBIGNsb3NlIHJlbGF0aXZlIG9mIFtgcmV0cnlgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9LiAgVGhpcyBtZXRob2QKICogd3JhcHMgYSB0YXNrIGFuZCBtYWtlcyBpdCByZXRyeWFibGUsIHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IGNhbGxpbmcgaXQKICogd2l0aCByZXRyaWVzLgogKgogKiBAbmFtZSByZXRyeWFibGUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmV0cnlde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeX0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gb3B0aW9uYWwKICogb3B0aW9ucywgZXhhY3RseSB0aGUgc2FtZSBhcyBmcm9tIGByZXRyeWAKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwLgogKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCB3cmFwcGVyLgogKiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKS4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLCB3aGljaCB3aGVuIGludm9rZWQsIHdpbGwKICogcmV0cnkgb24gYW4gZXJyb3IsIGJhc2VkIG9uIHRoZSBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiBgb3B0c2AuCiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhY2NlcHQgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyBgdGFza2AuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLAogKiAgICAgcHJvY2VzczogWyJkZXAxIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikgewogKiAgICAgICAgIG1heWJlUHJvY2Vzc0RhdGEocmVzdWx0cy5kZXAxLCBjYik7CiAqICAgICB9KV0KICogfSwgY2FsbGJhY2spOwogKi8KdmFyIHJldHJ5YWJsZSA9IGZ1bmN0aW9uIChvcHRzLCB0YXNrKSB7CiAgICBpZiAoIXRhc2spIHsKICAgICAgICB0YXNrID0gb3B0czsKICAgICAgICBvcHRzID0gbnVsbDsKICAgIH0KICAgIHZhciBfdGFzayA9IHdyYXBBc3luYyh0YXNrKTsKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIGZ1bmN0aW9uIHRhc2tGbihjYikgewogICAgICAgICAgICBfdGFzay5hcHBseShudWxsLCBhcmdzLmNvbmNhdChjYikpOwogICAgICAgIH0KCiAgICAgICAgaWYgKG9wdHMpIHJldHJ5KG9wdHMsIHRhc2tGbiwgY2FsbGJhY2spOwogICAgICAgIGVsc2UgcmV0cnkodGFza0ZuLCBjYWxsYmFjayk7CgogICAgfSk7Cn07CgovKioKICogUnVuIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBpbiBzZXJpZXMsIGVhY2ggb25lIHJ1bm5pbmcgb25jZQogKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IGZ1bmN0aW9ucyBpbiB0aGUgc2VyaWVzIHBhc3MgYW4KICogZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCBubyBtb3JlIGZ1bmN0aW9ucyBhcmUgcnVuLCBhbmQgYGNhbGxiYWNrYCBpcwogKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGVycm9yLiBPdGhlcndpc2UsIGBjYWxsYmFja2AKICogcmVjZWl2ZXMgYW4gYXJyYXkgb2YgcmVzdWx0cyB3aGVuIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQuCiAqCiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGwKICogYmUgcnVuIGFzIGEgZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYAogKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZwogKiAgcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5zZXJpZXN9LgogKgogKiAqKk5vdGUqKiB0aGF0IHdoaWxlIG1hbnkgaW1wbGVtZW50YXRpb25zIHByZXNlcnZlIHRoZSBvcmRlciBvZiBvYmplY3QKICogcHJvcGVydGllcywgdGhlIFtFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb25dKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjYpCiAqIGV4cGxpY2l0bHkgc3RhdGVzIHRoYXQKICoKICogPiBUaGUgbWVjaGFuaWNzIGFuZCBvcmRlciBvZiBlbnVtZXJhdGluZyB0aGUgcHJvcGVydGllcyBpcyBub3Qgc3BlY2lmaWVkLgogKgogKiBTbyBpZiB5b3UgcmVseSBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggeW91ciBzZXJpZXMgb2YgZnVuY3Rpb25zIGFyZSBleGVjdXRlZCwKICogYW5kIHdhbnQgdGhpcyB0byB3b3JrIG9uIGFsbCBwbGF0Zm9ybXMsIGNvbnNpZGVyIHVzaW5nIGFuIGFycmF5LgogKgogKiBAbmFtZSBzZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZwogKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4gaW4gc2VyaWVzLgogKiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXkgKG9yIG9iamVjdCkKICogY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBgdGFza2AgY2FsbGJhY2tzLiBJbnZva2VkCiAqIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICogYXN5bmMuc2VyaWVzKFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi4KICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgfQogKiBdLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFsIHRvIFsnb25lJywgJ3R3byddCiAqIH0pOwogKgogKiBhc3luYy5zZXJpZXMoewogKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpOwogKiAgICAgICAgIH0sIDIwMCk7CiAqICAgICB9LAogKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjayl7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBlcXVhbCB0bzoge29uZTogMSwgdHdvOiAyfQogKiB9KTsKICovCmZ1bmN0aW9uIHNlcmllcyh0YXNrcywgY2FsbGJhY2spIHsKICAgIF9wYXJhbGxlbChlYWNoT2ZTZXJpZXMsIHRhc2tzLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBSZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LgogKiBJZiBhbnkgaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGB0cnVlYCwgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseQogKiBjYWxsZWQuCiAqCiAqIEBuYW1lIHNvbWUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIGFueQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbQogKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gcGFyYWxsZWwuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMKICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5zb21lKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBpZiByZXN1bHQgaXMgdHJ1ZSB0aGVuIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzCiAqIH0pOwogKi8KdmFyIHNvbWUgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgaWRlbnRpdHkpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIHNvbWVMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0KICogQGFsaWFzIGFueUxpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLgogKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jCiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCnZhciBzb21lTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3RlcihCb29sZWFuLCBpZGVudGl0eSkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgc29tZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIHNvbWVTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9CiAqIEBhbGlhcyBhbnlTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHNlcmllcy4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueQogKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYwogKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgc29tZVNlcmllcyA9IGRvTGltaXQoc29tZUxpbWl0LCAxKTsKCi8qKgogKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jCiAqIGBpdGVyYXRlZWAuCiAqCiAqIEBuYW1lIHNvcnRCeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSB2YWx1ZSB0byB1c2UgYXMgdGhlIHNvcnQgY3JpdGVyaWEgYXMKICogaXRzIGByZXN1bHRgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyB0aGUgaXRlbXMKICogZnJvbSB0aGUgb3JpZ2luYWwgYGNvbGxgIHNvcnRlZCBieSB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBgaXRlcmF0ZWVgCiAqIGNhbGxzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnNvcnRCeShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykgewogKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7CiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBzdGF0cy5tdGltZSk7CiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5CiAqICAgICAvLyBtb2RpZmllZCBkYXRlCiAqIH0pOwogKgogKiAvLyBCeSBtb2RpZnlpbmcgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciB0aGUKICogLy8gc29ydGluZyBvcmRlciBjYW4gYmUgaW5mbHVlbmNlZDoKICoKICogLy8gYXNjZW5kaW5nIG9yZGVyCiAqIGFzeW5jLnNvcnRCeShbMSw5LDMsNV0sIGZ1bmN0aW9uKHgsIGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCB4KTsKICogfSwgZnVuY3Rpb24oZXJyLHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrCiAqIH0pOwogKgogKiAvLyBkZXNjZW5kaW5nIG9yZGVyCiAqIGFzeW5jLnNvcnRCeShbMSw5LDMsNV0sIGZ1bmN0aW9uKHgsIGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCB4Ki0xKTsgICAgLy88LSB4Ki0xIGluc3RlYWQgb2YgeCwgdHVybnMgdGhlIG9yZGVyIGFyb3VuZAogKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgY2FsbGJhY2sKICogfSk7CiAqLwpmdW5jdGlvbiBzb3J0QnkgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBtYXAoY29sbCwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7CiAgICAgICAgX2l0ZXJhdGVlKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7CiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIGNhbGxiYWNrKG51bGwsIGFycmF5TWFwKHJlc3VsdHMuc29ydChjb21wYXJhdG9yKSwgYmFzZVByb3BlcnR5KCd2YWx1ZScpKSk7CiAgICB9KTsKCiAgICBmdW5jdGlvbiBjb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7CiAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7CiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwOwogICAgfQp9CgovKioKICogU2V0cyBhIHRpbWUgbGltaXQgb24gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgY2FsbAogKiBpdHMgY2FsbGJhY2sgd2l0aGluIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEKICogdGltZW91dCBlcnJvci4gVGhlIGNvZGUgcHJvcGVydHkgZm9yIHRoZSBlcnJvciBvYmplY3Qgd2lsbCBiZSBgJ0VUSU1FRE9VVCdgLgogKgogKiBAbmFtZSB0aW1lb3V0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gYXN5bmNGbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBsaW1pdCBpbiB0aW1lLgogKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gVGhlIHNwZWNpZmllZCB0aW1lIGxpbWl0LgogKiBAcGFyYW0geyp9IFtpbmZvXSAtIEFueSB2YXJpYWJsZSB5b3Ugd2FudCBhdHRhY2hlZCAoYHN0cmluZ2AsIGBvYmplY3RgLCBldGMpCiAqIHRvIHRpbWVvdXQgRXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uLgogKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGFueQogKiBvZiB0aGUgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4KICogSW52b2tlIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHlvdSB3b3VsZCBgYXN5bmNGdW5jYC4KICogQGV4YW1wbGUKICoKICogZnVuY3Rpb24gbXlGdW5jdGlvbihmb28sIGNhbGxiYWNrKSB7CiAqICAgICBkb0FzeW5jVGFzayhmb28sIGZ1bmN0aW9uKGVyciwgZGF0YSkgewogKiAgICAgICAgIC8vIGhhbmRsZSBlcnJvcnMKICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICoKICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLgogKgogKiAgICAgICAgIC8vIHJldHVybiBwcm9jZXNzZWQgZGF0YQogKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkYXRhKTsKICogICAgIH0pOwogKiB9CiAqCiAqIHZhciB3cmFwcGVkID0gYXN5bmMudGltZW91dChteUZ1bmN0aW9uLCAxMDAwKTsKICoKICogLy8gY2FsbCBgd3JhcHBlZGAgYXMgeW91IHdvdWxkIGBteUZ1bmN0aW9uYAogKiB3cmFwcGVkKHsgYmFyOiAnYmFyJyB9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHsKICogICAgIC8vIGlmIGBteUZ1bmN0aW9uYCB0YWtlcyA8IDEwMDAgbXMgdG8gZXhlY3V0ZSwgYGVycmAKICogICAgIC8vIGFuZCBgZGF0YWAgd2lsbCBoYXZlIHRoZWlyIGV4cGVjdGVkIHZhbHVlcwogKgogKiAgICAgLy8gZWxzZSBgZXJyYCB3aWxsIGJlIGFuIEVycm9yIHdpdGggdGhlIGNvZGUgJ0VUSU1FRE9VVCcKICogfSk7CiAqLwpmdW5jdGlvbiB0aW1lb3V0KGFzeW5jRm4sIG1pbGxpc2Vjb25kcywgaW5mbykgewogICAgdmFyIGZuID0gd3JhcEFzeW5jKGFzeW5jRm4pOwoKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIHZhciB0aW1lZE91dCA9IGZhbHNlOwogICAgICAgIHZhciB0aW1lcjsKCiAgICAgICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkgewogICAgICAgICAgICB2YXIgbmFtZSA9IGFzeW5jRm4ubmFtZSB8fCAnYW5vbnltb3VzJzsKICAgICAgICAgICAgdmFyIGVycm9yICA9IG5ldyBFcnJvcignQ2FsbGJhY2sgZnVuY3Rpb24gIicgKyBuYW1lICsgJyIgdGltZWQgb3V0LicpOwogICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VUSU1FRE9VVCc7CiAgICAgICAgICAgIGlmIChpbmZvKSB7CiAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0gaW5mbzsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aW1lZE91dCA9IHRydWU7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTsKICAgICAgICB9CgogICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGlmICghdGltZWRPdXQpIHsKICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIC8vIHNldHVwIHRpbWVyIGFuZCBjYWxsIG9yaWdpbmFsIGZ1bmN0aW9uCiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgbWlsbGlzZWNvbmRzKTsKICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTsKICAgIH0pOwp9CgovKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovCnZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsOwp2YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0CiAqIGNvZXJjZSBhcmd1bWVudHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLgogKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLgogKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS4KICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy4KICovCmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksCiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CgogIHdoaWxlIChsZW5ndGgtLSkgewogICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7CiAgICBzdGFydCArPSBzdGVwOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKioKICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSB0aW1lc0xpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuCiAqIEludm9rZWQgd2l0aCB0aGUgaXRlcmF0aW9uIGluZGV4IGFuZCBhIGNhbGxiYWNrOiAobiwgbmV4dCkuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LgogKi8KZnVuY3Rpb24gdGltZUxpbWl0KGNvdW50LCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIG1hcExpbWl0KGJhc2VSYW5nZSgwLCBjb3VudCwgMSksIGxpbWl0LCBfaXRlcmF0ZWUsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIENhbGxzIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uIGBuYCB0aW1lcywgYW5kIGFjY3VtdWxhdGVzIHJlc3VsdHMgaW4gdGhlIHNhbWUKICogbWFubmVyIHlvdSB3b3VsZCB1c2Ugd2l0aCBbbWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS4KICoKICogQG5hbWUgdGltZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLgogKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSB7QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uCiAqIEBleGFtcGxlCiAqCiAqIC8vIFByZXRlbmQgdGhpcyBpcyBzb21lIGNvbXBsaWNhdGVkIGFzeW5jIGZhY3RvcnkKICogdmFyIGNyZWF0ZVVzZXIgPSBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHsKICogICAgIGNhbGxiYWNrKG51bGwsIHsKICogICAgICAgICBpZDogJ3VzZXInICsgaWQKICogICAgIH0pOwogKiB9OwogKgogKiAvLyBnZW5lcmF0ZSA1IHVzZXJzCiAqIGFzeW5jLnRpbWVzKDUsIGZ1bmN0aW9uKG4sIG5leHQpIHsKICogICAgIGNyZWF0ZVVzZXIobiwgZnVuY3Rpb24oZXJyLCB1c2VyKSB7CiAqICAgICAgICAgbmV4dChlcnIsIHVzZXIpOwogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgdXNlcnMpIHsKICogICAgIC8vIHdlIHNob3VsZCBub3cgaGF2ZSA1IHVzZXJzCiAqIH0pOwogKi8KdmFyIHRpbWVzID0gZG9MaW1pdCh0aW1lTGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbdGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc30gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSB0aW1lc1NlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy50aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLgogKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSB7QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uCiAqLwp2YXIgdGltZXNTZXJpZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgMSk7CgovKioKICogQSByZWxhdGl2ZSBvZiBgcmVkdWNlYC4gIFRha2VzIGFuIE9iamVjdCBvciBBcnJheSwgYW5kIGl0ZXJhdGVzIG92ZXIgZWFjaAogKiBlbGVtZW50IGluIHNlcmllcywgZWFjaCBzdGVwIHBvdGVudGlhbGx5IG11dGF0aW5nIGFuIGBhY2N1bXVsYXRvcmAgdmFsdWUuCiAqIFRoZSB0eXBlIG9mIHRoZSBhY2N1bXVsYXRvciBkZWZhdWx0cyB0byB0aGUgdHlwZSBvZiBjb2xsZWN0aW9uIHBhc3NlZCBpbi4KICoKICogQG5hbWUgdHJhbnNmb3JtCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHRyYW5zZm9ybS4gIElmIG9taXR0ZWQsCiAqIGl0IHdpbGwgZGVmYXVsdCB0byBhbiBlbXB0eSBPYmplY3Qgb3IgQXJyYXksIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBgY29sbGAKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlCiAqIGNvbGxlY3Rpb24gdGhhdCBwb3RlbnRpYWxseSBtb2RpZmllcyB0aGUgYWNjdW11bGF0b3IuCiAqIEludm9rZWQgd2l0aCAoYWNjdW11bGF0b3IsIGl0ZW0sIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHRyYW5zZm9ybWVkIGFjY3VtdWxhdG9yLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMudHJhbnNmb3JtKFsxLDIsM10sIGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgsIGNhbGxiYWNrKSB7CiAqICAgICAvLyBwb2ludGxlc3MgYXN5bmM6CiAqICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgewogKiAgICAgICAgIGFjYy5wdXNoKGl0ZW0gKiAyKQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwpCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gWzIsIDQsIDZdCiAqIH0pOwogKgogKiBAZXhhbXBsZQogKgogKiBhc3luYy50cmFuc2Zvcm0oe2E6IDEsIGI6IDIsIGM6IDN9LCBmdW5jdGlvbiAob2JqLCB2YWwsIGtleSwgY2FsbGJhY2spIHsKICogICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7CiAqICAgICAgICAgb2JqW2tleV0gPSB2YWwgKiAyOwogKiAgICAgICAgIGNhbGxiYWNrKCk7CiAqICAgICB9KQogKiB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBlcXVhbCB0byB7YTogMiwgYjogNCwgYzogNn0KICogfSkKICovCmZ1bmN0aW9uIHRyYW5zZm9ybSAoY29sbCwgYWNjdW11bGF0b3IsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykgewogICAgICAgIGNhbGxiYWNrID0gaXRlcmF0ZWU7CiAgICAgICAgaXRlcmF0ZWUgPSBhY2N1bXVsYXRvcjsKICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyYXkoY29sbCkgPyBbXSA6IHt9OwogICAgfQogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CgogICAgZWFjaE9mKGNvbGwsIGZ1bmN0aW9uKHYsIGssIGNiKSB7CiAgICAgICAgX2l0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2LCBrLCBjYik7CiAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIGFjY3VtdWxhdG9yKTsKICAgIH0pOwp9CgovKioKICogSXQgcnVucyBlYWNoIHRhc2sgaW4gc2VyaWVzIGJ1dCBzdG9wcyB3aGVuZXZlciBhbnkgb2YgdGhlIGZ1bmN0aW9ucyB3ZXJlCiAqIHN1Y2Nlc3NmdWwuIElmIG9uZSBvZiB0aGUgdGFza3Mgd2VyZSBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlCiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCB0YXNrcyBmYWlsLCB0aGUgY2FsbGJhY2sKICogd2lsbCBiZSBwYXNzZWQgdGhlIGVycm9yIGFuZCByZXN1bHQgKGlmIGFueSkgb2YgdGhlIGZpbmFsIGF0dGVtcHQuCiAqCiAqIEBuYW1lIHRyeUVhY2gKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZyBmdW5jdGlvbnMgdG8KICogcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGl0IG11c3QgY2FsbCBvbgogKiBjb21wbGV0aW9uIHdpdGggYW4gZXJyb3IgYGVycmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCBhbiBvcHRpb25hbCBgcmVzdWx0YAogKiB2YWx1ZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIG9uZQogKiBvZiB0aGUgdGFza3MgaGFzIHN1Y2NlZWRlZCwgb3IgYWxsIGhhdmUgZmFpbGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYW5kCiAqIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKiBhc3luYy50cnlFYWNoKFsKICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tRmlyc3RXZWJzaXRlKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgd2Vic2l0ZQogKiAgICAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21TZWNvbmRXZWJzaXRlKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gRmlyc3Qgd2Vic2l0ZSBmYWlsZWQsCiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgYmFja3VwIHdlYnNpdGUKICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpOwogKiAgICAgfQogKiBdLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIE5vdyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4KICogfSk7CiAqCiAqLwpmdW5jdGlvbiB0cnlFYWNoKHRhc2tzLCBjYWxsYmFjaykgewogICAgdmFyIGVycm9yID0gbnVsbDsKICAgIHZhciByZXN1bHQ7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICBlYWNoU2VyaWVzKHRhc2tzLCBmdW5jdGlvbih0YXNrLCBjYWxsYmFjaykgewogICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXMvKiwgLi4uYXJncyovKSB7CiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlczsKICAgICAgICAgICAgfQogICAgICAgICAgICBlcnJvciA9IGVycjsKICAgICAgICAgICAgY2FsbGJhY2soIWVycik7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoKSB7CiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7CiAgICB9KTsKfQoKLyoqCiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLAogKiB1bm1lbW9pemVkIGZvcm0uIEhhbmR5IGZvciB0ZXN0aW5nLgogKgogKiBAbmFtZSB1bm1lbW9pemUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWVtb2l6ZV17QGxpbmsgbW9kdWxlOlV0aWxzLm1lbW9pemV9CiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgb3JpZ2luYWwgdW5tZW1vaXplZCBmdW5jdGlvbgogKi8KZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgIH07Cn0KCi8qKgogKiBSZXBlYXRlZGx5IGNhbGwgYGl0ZXJhdGVlYCwgd2hpbGUgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW4KICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLgogKgogKiBAbmFtZSB3aGlsc3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lCiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2AKICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MKICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pOwogKiBAcmV0dXJucyB1bmRlZmluZWQKICogQGV4YW1wbGUKICoKICogdmFyIGNvdW50ID0gMDsKICogYXN5bmMud2hpbHN0KAogKiAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBjb3VudCA8IDU7IH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNvdW50Kys7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY291bnQpOwogKiAgICAgICAgIH0sIDEwMDApOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uIChlcnIsIG4pIHsKICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1CiAqICAgICB9CiAqICk7CiAqLwpmdW5jdGlvbiB3aGlsc3QodGVzdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBpZiAoIXRlc3QoKSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgdmFyIG5leHQgPSBmdW5jdGlvbihlcnIvKiwgLi4uYXJncyovKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgaWYgKHRlc3QoKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7CiAgICB9OwogICAgX2l0ZXJhdGVlKG5leHQpOwp9CgovKioKICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW4KICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgY2FsbGJhY2tgIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkKICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzIGNhbGxiYWNrLgogKgogKiBUaGUgaW52ZXJzZSBvZiBbd2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS4KICoKICogQG5hbWUgdW50aWwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2gKICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoKS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUKICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBwYXNzZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTsKICovCmZ1bmN0aW9uIHVudGlsKHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgd2hpbHN0KGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHNlcmllcywgZWFjaCBwYXNzaW5nIHRoZWlyIHJlc3VsdHMgdG8KICogdGhlIG5leHQgaW4gdGhlIGFycmF5LiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIGB0YXNrc2AgcGFzcyBhbiBlcnJvciB0byB0aGVpcgogKiBvd24gY2FsbGJhY2ssIHRoZSBuZXh0IGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMKICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLgogKgogKiBAbmFtZSB3YXRlcmZhbGwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IG9mIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259CiAqIHRvIHJ1bi4KICogRWFjaCBmdW5jdGlvbiBzaG91bGQgY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIGByZXN1bHRgIHZhbHVlcy4KICogVGhlIGByZXN1bHRgIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMsIGluIG9yZGVyLCB0byB0aGUgbmV4dCB0YXNrLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgd2lsbCBiZSBwYXNzZWQgdGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgdGFzaydzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHsKICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJwogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZScKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpOwogKiAgICAgfQogKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJwogKiB9KTsKICoKICogLy8gT3IsIHdpdGggbmFtZWQgZnVuY3Rpb25zOgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgbXlGaXJzdEZ1bmN0aW9uLAogKiAgICAgbXlTZWNvbmRGdW5jdGlvbiwKICogICAgIG15TGFzdEZ1bmN0aW9uLAogKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJwogKiB9KTsKICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpOwogKiB9CiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHsKICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nCiAqICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTsKICogfQogKiBmdW5jdGlvbiBteUxhc3RGdW5jdGlvbihhcmcxLCBjYWxsYmFjaykgewogKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZScKICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7CiAqIH0KICovCnZhciB3YXRlcmZhbGwgPSBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTsKICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTsKICAgIHZhciB0YXNrSW5kZXggPSAwOwoKICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHsKICAgICAgICB2YXIgdGFzayA9IHdyYXBBc3luYyh0YXNrc1t0YXNrSW5kZXgrK10pOwogICAgICAgIGFyZ3MucHVzaChvbmx5T25jZShuZXh0KSk7CiAgICAgICAgdGFzay5hcHBseShudWxsLCBhcmdzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICBpZiAoZXJyIHx8IHRhc2tJbmRleCA9PT0gdGFza3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICAgIH0KICAgICAgICBuZXh0VGFzayhzbGljZShhcmd1bWVudHMsIDEpKTsKICAgIH0KCiAgICBuZXh0VGFzayhbXSk7Cn07CgovKioKICogQW4gImFzeW5jIGZ1bmN0aW9uIiBpbiB0aGUgY29udGV4dCBvZiBBc3luYyBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gd2l0aAogKiBhIHZhcmlhYmxlIG51bWJlciBvZiBwYXJhbWV0ZXJzLCB3aXRoIHRoZSBmaW5hbCBwYXJhbWV0ZXIgYmVpbmcgYSBjYWxsYmFjay4KICogKGBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgLi4uLCBjYWxsYmFjaykge31gKQogKiBUaGUgZmluYWwgY2FsbGJhY2sgaXMgb2YgdGhlIGZvcm0gYGNhbGxiYWNrKGVyciwgcmVzdWx0cy4uLilgLCB3aGljaCBtdXN0IGJlCiAqIGNhbGxlZCBvbmNlIHRoZSBmdW5jdGlvbiBpcyBjb21wbGV0ZWQuICBUaGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGEKICogRXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIHNpZ25hbCB0aGF0IGFuIGVycm9yIG9jY3VycmVkLgogKiBPdGhlcndpc2UsIGlmIG5vIGVycm9yIG9jY3VycmVkLCBpdCBzaG91bGQgYmUgY2FsbGVkIHdpdGggYG51bGxgIGFzIHRoZSBmaXJzdAogKiBhcmd1bWVudCwgYW5kIGFueSBhZGRpdGlvbmFsIGByZXN1bHRgIGFyZ3VtZW50cyB0aGF0IG1heSBhcHBseSwgdG8gc2lnbmFsCiAqIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi4KICogVGhlIGNhbGxiYWNrIG11c3QgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSwgaWRlYWxseSBvbiBhIGxhdGVyIHRpY2sgb2YgdGhlCiAqIEphdmFTY3JpcHQgZXZlbnQgbG9vcC4KICoKICogVGhpcyB0eXBlIG9mIGZ1bmN0aW9uIGlzIGFsc28gcmVmZXJyZWQgdG8gYXMgYSAiTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiIsCiAqIG9yIGEgImNvbnRpbnVhdGlvbiBwYXNzaW5nLXN0eWxlIGZ1bmN0aW9uIiAoQ1BTKS4gTW9zdCBvZiB0aGUgbWV0aG9kcyBvZiB0aGlzCiAqIGxpYnJhcnkgYXJlIHRoZW1zZWx2ZXMgQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLCBvciBmdW5jdGlvbnMgdGhhdAogKiByZXR1cm4gQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLgogKgogKiBXaGVyZXZlciB3ZSBhY2NlcHQgYSBOb2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9uLCB3ZSBhbHNvIGRpcmVjdGx5IGFjY2VwdCBhbgogKiBbRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0YXRlbWVudHMvYXN5bmNfZnVuY3Rpb259LgogKiBJbiB0aGlzIGNhc2UsIHRoZSBgYXN5bmNgIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHBhc3NlZCBhIGZpbmFsIGNhbGxiYWNrCiAqIGFyZ3VtZW50LCBhbmQgYW55IHRocm93biBlcnJvciB3aWxsIGJlIHVzZWQgYXMgdGhlIGBlcnJgIGFyZ3VtZW50IG9mIHRoZQogKiBpbXBsaWNpdCBjYWxsYmFjaywgYW5kIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBgcmVzdWx0YCB2YWx1ZS4KICogKGkuZS4gYSBgcmVqZWN0ZWRgIG9mIHRoZSByZXR1cm5lZCBQcm9taXNlIGJlY29tZXMgdGhlIGBlcnJgIGNhbGxiYWNrCiAqIGFyZ3VtZW50LCBhbmQgYSBgcmVzb2x2ZWRgIHZhbHVlIGJlY29tZXMgdGhlIGByZXN1bHRgLikKICoKICogTm90ZSwgZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIHdlIGNhbiBvbmx5IGRldGVjdCBuYXRpdmUgYGFzeW5jYAogKiBmdW5jdGlvbnMgYW5kIG5vdCB0cmFuc3BpbGllZCBpbXBsZW1lbnRhdGlvbnMuCiAqIFlvdXIgZW52aXJvbm1lbnQgbXVzdCBoYXZlIGBhc3luY2AvYGF3YWl0YCBzdXBwb3J0IGZvciB0aGlzIHRvIHdvcmsuCiAqIChlLmcuIE5vZGUgPiB2Ny42LCBvciBhIHJlY2VudCB2ZXJzaW9uIG9mIGEgbW9kZXJuIGJyb3dzZXIpLgogKiBJZiB5b3UgYXJlIHVzaW5nIGBhc3luY2AgZnVuY3Rpb25zIHRocm91Z2ggYSB0cmFuc3BpbGVyIChlLmcuIEJhYmVsKSwgeW91CiAqIG11c3Qgc3RpbGwgd3JhcCB0aGUgZnVuY3Rpb24gd2l0aCBbYXN5bmNpZnlde0BsaW5rIG1vZHVsZTpVdGlscy5hc3luY2lmeX0sCiAqIGJlY2F1c2UgdGhlIGBhc3luYyBmdW5jdGlvbmAgd2lsbCBiZSBjb21waWxlZCB0byBhbiBvcmRpbmFyeSBmdW5jdGlvbiB0aGF0CiAqIHJldHVybnMgYSBwcm9taXNlLgogKgogKiBAdHlwZWRlZiB7RnVuY3Rpb259IEFzeW5jRnVuY3Rpb24KICogQHN0YXRpYwogKi8KCi8qKgogKiBBc3luYyBpcyBhIHV0aWxpdHkgbW9kdWxlIHdoaWNoIHByb3ZpZGVzIHN0cmFpZ2h0LWZvcndhcmQsIHBvd2VyZnVsIGZ1bmN0aW9ucwogKiBmb3Igd29ya2luZyB3aXRoIGFzeW5jaHJvbm91cyBKYXZhU2NyaXB0LiBBbHRob3VnaCBvcmlnaW5hbGx5IGRlc2lnbmVkIGZvcgogKiB1c2Ugd2l0aCBbTm9kZS5qc10oaHR0cDovL25vZGVqcy5vcmcpIGFuZCBpbnN0YWxsYWJsZSB2aWEKICogYG5wbSBpbnN0YWxsIC0tc2F2ZSBhc3luY2AsIGl0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuCiAqIEBtb2R1bGUgYXN5bmMKICogQHNlZSBBc3luY0Z1bmN0aW9uCiAqLwoKCi8qKgogKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyBjb2xsZWN0aW9ucywgc3VjaCBhcwogKiBhcnJheXMgYW5kIG9iamVjdHMuCiAqIEBtb2R1bGUgQ29sbGVjdGlvbnMKICovCgovKioKICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBjb250cm9sbGluZyB0aGUgZmxvdyB0aHJvdWdoIGEgc2NyaXB0LgogKiBAbW9kdWxlIENvbnRyb2xGbG93CiAqLwoKLyoqCiAqIEEgY29sbGVjdGlvbiBvZiBgYXN5bmNgIHV0aWxpdHkgZnVuY3Rpb25zLgogKiBAbW9kdWxlIFV0aWxzCiAqLwoKdmFyIGluZGV4ID0gewogICAgYXBwbHk6IGFwcGx5LAogICAgYXBwbHlFYWNoOiBhcHBseUVhY2gsCiAgICBhcHBseUVhY2hTZXJpZXM6IGFwcGx5RWFjaFNlcmllcywKICAgIGFzeW5jaWZ5OiBhc3luY2lmeSwKICAgIGF1dG86IGF1dG8sCiAgICBhdXRvSW5qZWN0OiBhdXRvSW5qZWN0LAogICAgY2FyZ286IGNhcmdvLAogICAgY29tcG9zZTogY29tcG9zZSwKICAgIGNvbmNhdDogY29uY2F0LAogICAgY29uY2F0TGltaXQ6IGNvbmNhdExpbWl0LAogICAgY29uY2F0U2VyaWVzOiBjb25jYXRTZXJpZXMsCiAgICBjb25zdGFudDogY29uc3RhbnQsCiAgICBkZXRlY3Q6IGRldGVjdCwKICAgIGRldGVjdExpbWl0OiBkZXRlY3RMaW1pdCwKICAgIGRldGVjdFNlcmllczogZGV0ZWN0U2VyaWVzLAogICAgZGlyOiBkaXIsCiAgICBkb0R1cmluZzogZG9EdXJpbmcsCiAgICBkb1VudGlsOiBkb1VudGlsLAogICAgZG9XaGlsc3Q6IGRvV2hpbHN0LAogICAgZHVyaW5nOiBkdXJpbmcsCiAgICBlYWNoOiBlYWNoTGltaXQsCiAgICBlYWNoTGltaXQ6IGVhY2hMaW1pdCQxLAogICAgZWFjaE9mOiBlYWNoT2YsCiAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsCiAgICBlYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcywKICAgIGVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsCiAgICBlbnN1cmVBc3luYzogZW5zdXJlQXN5bmMsCiAgICBldmVyeTogZXZlcnksCiAgICBldmVyeUxpbWl0OiBldmVyeUxpbWl0LAogICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzLAogICAgZmlsdGVyOiBmaWx0ZXIsCiAgICBmaWx0ZXJMaW1pdDogZmlsdGVyTGltaXQsCiAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcywKICAgIGZvcmV2ZXI6IGZvcmV2ZXIsCiAgICBncm91cEJ5OiBncm91cEJ5LAogICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQsCiAgICBncm91cEJ5U2VyaWVzOiBncm91cEJ5U2VyaWVzLAogICAgbG9nOiBsb2csCiAgICBtYXA6IG1hcCwKICAgIG1hcExpbWl0OiBtYXBMaW1pdCwKICAgIG1hcFNlcmllczogbWFwU2VyaWVzLAogICAgbWFwVmFsdWVzOiBtYXBWYWx1ZXMsCiAgICBtYXBWYWx1ZXNMaW1pdDogbWFwVmFsdWVzTGltaXQsCiAgICBtYXBWYWx1ZXNTZXJpZXM6IG1hcFZhbHVlc1NlcmllcywKICAgIG1lbW9pemU6IG1lbW9pemUsCiAgICBuZXh0VGljazogbmV4dFRpY2ssCiAgICBwYXJhbGxlbDogcGFyYWxsZWxMaW1pdCwKICAgIHBhcmFsbGVsTGltaXQ6IHBhcmFsbGVsTGltaXQkMSwKICAgIHByaW9yaXR5UXVldWU6IHByaW9yaXR5UXVldWUsCiAgICBxdWV1ZTogcXVldWUkMSwKICAgIHJhY2U6IHJhY2UsCiAgICByZWR1Y2U6IHJlZHVjZSwKICAgIHJlZHVjZVJpZ2h0OiByZWR1Y2VSaWdodCwKICAgIHJlZmxlY3Q6IHJlZmxlY3QsCiAgICByZWZsZWN0QWxsOiByZWZsZWN0QWxsLAogICAgcmVqZWN0OiByZWplY3QsCiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQsCiAgICByZWplY3RTZXJpZXM6IHJlamVjdFNlcmllcywKICAgIHJldHJ5OiByZXRyeSwKICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlLAogICAgc2VxOiBzZXEsCiAgICBzZXJpZXM6IHNlcmllcywKICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsCiAgICBzb21lOiBzb21lLAogICAgc29tZUxpbWl0OiBzb21lTGltaXQsCiAgICBzb21lU2VyaWVzOiBzb21lU2VyaWVzLAogICAgc29ydEJ5OiBzb3J0QnksCiAgICB0aW1lb3V0OiB0aW1lb3V0LAogICAgdGltZXM6IHRpbWVzLAogICAgdGltZXNMaW1pdDogdGltZUxpbWl0LAogICAgdGltZXNTZXJpZXM6IHRpbWVzU2VyaWVzLAogICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sCiAgICB0cnlFYWNoOiB0cnlFYWNoLAogICAgdW5tZW1vaXplOiB1bm1lbW9pemUsCiAgICB1bnRpbDogdW50aWwsCiAgICB3YXRlcmZhbGw6IHdhdGVyZmFsbCwKICAgIHdoaWxzdDogd2hpbHN0LAoKICAgIC8vIGFsaWFzZXMKICAgIGFsbDogZXZlcnksCiAgICBhbGxMaW1pdDogZXZlcnlMaW1pdCwKICAgIGFsbFNlcmllczogZXZlcnlTZXJpZXMsCiAgICBhbnk6IHNvbWUsCiAgICBhbnlMaW1pdDogc29tZUxpbWl0LAogICAgYW55U2VyaWVzOiBzb21lU2VyaWVzLAogICAgZmluZDogZGV0ZWN0LAogICAgZmluZExpbWl0OiBkZXRlY3RMaW1pdCwKICAgIGZpbmRTZXJpZXM6IGRldGVjdFNlcmllcywKICAgIGZvckVhY2g6IGVhY2hMaW1pdCwKICAgIGZvckVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsCiAgICBmb3JFYWNoTGltaXQ6IGVhY2hMaW1pdCQxLAogICAgZm9yRWFjaE9mOiBlYWNoT2YsCiAgICBmb3JFYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcywKICAgIGZvckVhY2hPZkxpbWl0OiBlYWNoT2ZMaW1pdCwKICAgIGluamVjdDogcmVkdWNlLAogICAgZm9sZGw6IHJlZHVjZSwKICAgIGZvbGRyOiByZWR1Y2VSaWdodCwKICAgIHNlbGVjdDogZmlsdGVyLAogICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0LAogICAgc2VsZWN0U2VyaWVzOiBmaWx0ZXJTZXJpZXMsCiAgICB3cmFwU3luYzogYXN5bmNpZnkKfTsKCmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGluZGV4OwpleHBvcnRzLmFwcGx5ID0gYXBwbHk7CmV4cG9ydHMuYXBwbHlFYWNoID0gYXBwbHlFYWNoOwpleHBvcnRzLmFwcGx5RWFjaFNlcmllcyA9IGFwcGx5RWFjaFNlcmllczsKZXhwb3J0cy5hc3luY2lmeSA9IGFzeW5jaWZ5OwpleHBvcnRzLmF1dG8gPSBhdXRvOwpleHBvcnRzLmF1dG9JbmplY3QgPSBhdXRvSW5qZWN0OwpleHBvcnRzLmNhcmdvID0gY2FyZ287CmV4cG9ydHMuY29tcG9zZSA9IGNvbXBvc2U7CmV4cG9ydHMuY29uY2F0ID0gY29uY2F0OwpleHBvcnRzLmNvbmNhdExpbWl0ID0gY29uY2F0TGltaXQ7CmV4cG9ydHMuY29uY2F0U2VyaWVzID0gY29uY2F0U2VyaWVzOwpleHBvcnRzLmNvbnN0YW50ID0gY29uc3RhbnQ7CmV4cG9ydHMuZGV0ZWN0ID0gZGV0ZWN0OwpleHBvcnRzLmRldGVjdExpbWl0ID0gZGV0ZWN0TGltaXQ7CmV4cG9ydHMuZGV0ZWN0U2VyaWVzID0gZGV0ZWN0U2VyaWVzOwpleHBvcnRzLmRpciA9IGRpcjsKZXhwb3J0cy5kb0R1cmluZyA9IGRvRHVyaW5nOwpleHBvcnRzLmRvVW50aWwgPSBkb1VudGlsOwpleHBvcnRzLmRvV2hpbHN0ID0gZG9XaGlsc3Q7CmV4cG9ydHMuZHVyaW5nID0gZHVyaW5nOwpleHBvcnRzLmVhY2ggPSBlYWNoTGltaXQ7CmV4cG9ydHMuZWFjaExpbWl0ID0gZWFjaExpbWl0JDE7CmV4cG9ydHMuZWFjaE9mID0gZWFjaE9mOwpleHBvcnRzLmVhY2hPZkxpbWl0ID0gZWFjaE9mTGltaXQ7CmV4cG9ydHMuZWFjaE9mU2VyaWVzID0gZWFjaE9mU2VyaWVzOwpleHBvcnRzLmVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzOwpleHBvcnRzLmVuc3VyZUFzeW5jID0gZW5zdXJlQXN5bmM7CmV4cG9ydHMuZXZlcnkgPSBldmVyeTsKZXhwb3J0cy5ldmVyeUxpbWl0ID0gZXZlcnlMaW1pdDsKZXhwb3J0cy5ldmVyeVNlcmllcyA9IGV2ZXJ5U2VyaWVzOwpleHBvcnRzLmZpbHRlciA9IGZpbHRlcjsKZXhwb3J0cy5maWx0ZXJMaW1pdCA9IGZpbHRlckxpbWl0OwpleHBvcnRzLmZpbHRlclNlcmllcyA9IGZpbHRlclNlcmllczsKZXhwb3J0cy5mb3JldmVyID0gZm9yZXZlcjsKZXhwb3J0cy5ncm91cEJ5ID0gZ3JvdXBCeTsKZXhwb3J0cy5ncm91cEJ5TGltaXQgPSBncm91cEJ5TGltaXQ7CmV4cG9ydHMuZ3JvdXBCeVNlcmllcyA9IGdyb3VwQnlTZXJpZXM7CmV4cG9ydHMubG9nID0gbG9nOwpleHBvcnRzLm1hcCA9IG1hcDsKZXhwb3J0cy5tYXBMaW1pdCA9IG1hcExpbWl0OwpleHBvcnRzLm1hcFNlcmllcyA9IG1hcFNlcmllczsKZXhwb3J0cy5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7CmV4cG9ydHMubWFwVmFsdWVzTGltaXQgPSBtYXBWYWx1ZXNMaW1pdDsKZXhwb3J0cy5tYXBWYWx1ZXNTZXJpZXMgPSBtYXBWYWx1ZXNTZXJpZXM7CmV4cG9ydHMubWVtb2l6ZSA9IG1lbW9pemU7CmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljazsKZXhwb3J0cy5wYXJhbGxlbCA9IHBhcmFsbGVsTGltaXQ7CmV4cG9ydHMucGFyYWxsZWxMaW1pdCA9IHBhcmFsbGVsTGltaXQkMTsKZXhwb3J0cy5wcmlvcml0eVF1ZXVlID0gcHJpb3JpdHlRdWV1ZTsKZXhwb3J0cy5xdWV1ZSA9IHF1ZXVlJDE7CmV4cG9ydHMucmFjZSA9IHJhY2U7CmV4cG9ydHMucmVkdWNlID0gcmVkdWNlOwpleHBvcnRzLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7CmV4cG9ydHMucmVmbGVjdCA9IHJlZmxlY3Q7CmV4cG9ydHMucmVmbGVjdEFsbCA9IHJlZmxlY3RBbGw7CmV4cG9ydHMucmVqZWN0ID0gcmVqZWN0OwpleHBvcnRzLnJlamVjdExpbWl0ID0gcmVqZWN0TGltaXQ7CmV4cG9ydHMucmVqZWN0U2VyaWVzID0gcmVqZWN0U2VyaWVzOwpleHBvcnRzLnJldHJ5ID0gcmV0cnk7CmV4cG9ydHMucmV0cnlhYmxlID0gcmV0cnlhYmxlOwpleHBvcnRzLnNlcSA9IHNlcTsKZXhwb3J0cy5zZXJpZXMgPSBzZXJpZXM7CmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlJDE7CmV4cG9ydHMuc29tZSA9IHNvbWU7CmV4cG9ydHMuc29tZUxpbWl0ID0gc29tZUxpbWl0OwpleHBvcnRzLnNvbWVTZXJpZXMgPSBzb21lU2VyaWVzOwpleHBvcnRzLnNvcnRCeSA9IHNvcnRCeTsKZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDsKZXhwb3J0cy50aW1lcyA9IHRpbWVzOwpleHBvcnRzLnRpbWVzTGltaXQgPSB0aW1lTGltaXQ7CmV4cG9ydHMudGltZXNTZXJpZXMgPSB0aW1lc1NlcmllczsKZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07CmV4cG9ydHMudHJ5RWFjaCA9IHRyeUVhY2g7CmV4cG9ydHMudW5tZW1vaXplID0gdW5tZW1vaXplOwpleHBvcnRzLnVudGlsID0gdW50aWw7CmV4cG9ydHMud2F0ZXJmYWxsID0gd2F0ZXJmYWxsOwpleHBvcnRzLndoaWxzdCA9IHdoaWxzdDsKZXhwb3J0cy5hbGwgPSBldmVyeTsKZXhwb3J0cy5hbGxMaW1pdCA9IGV2ZXJ5TGltaXQ7CmV4cG9ydHMuYWxsU2VyaWVzID0gZXZlcnlTZXJpZXM7CmV4cG9ydHMuYW55ID0gc29tZTsKZXhwb3J0cy5hbnlMaW1pdCA9IHNvbWVMaW1pdDsKZXhwb3J0cy5hbnlTZXJpZXMgPSBzb21lU2VyaWVzOwpleHBvcnRzLmZpbmQgPSBkZXRlY3Q7CmV4cG9ydHMuZmluZExpbWl0ID0gZGV0ZWN0TGltaXQ7CmV4cG9ydHMuZmluZFNlcmllcyA9IGRldGVjdFNlcmllczsKZXhwb3J0cy5mb3JFYWNoID0gZWFjaExpbWl0OwpleHBvcnRzLmZvckVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzOwpleHBvcnRzLmZvckVhY2hMaW1pdCA9IGVhY2hMaW1pdCQxOwpleHBvcnRzLmZvckVhY2hPZiA9IGVhY2hPZjsKZXhwb3J0cy5mb3JFYWNoT2ZTZXJpZXMgPSBlYWNoT2ZTZXJpZXM7CmV4cG9ydHMuZm9yRWFjaE9mTGltaXQgPSBlYWNoT2ZMaW1pdDsKZXhwb3J0cy5pbmplY3QgPSByZWR1Y2U7CmV4cG9ydHMuZm9sZGwgPSByZWR1Y2U7CmV4cG9ydHMuZm9sZHIgPSByZWR1Y2VSaWdodDsKZXhwb3J0cy5zZWxlY3QgPSBmaWx0ZXI7CmV4cG9ydHMuc2VsZWN0TGltaXQgPSBmaWx0ZXJMaW1pdDsKZXhwb3J0cy5zZWxlY3RTZXJpZXMgPSBmaWx0ZXJTZXJpZXM7CmV4cG9ydHMud3JhcFN5bmMgPSBhc3luY2lmeTsKCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7Cgp9KSkpOwoKfSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSxfZGVyZXFfKCJ0aW1lcnMiKS5zZXRJbW1lZGlhdGUpCgp9LHsiX3Byb2Nlc3MiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3Byb2Nlc3NAMC4xMS4xMEBwcm9jZXNzL2Jyb3dzZXIuanMiLCJ0aW1lcnMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3RpbWVycy1icm93c2VyaWZ5QDEuNC4yQHRpbWVycy1icm93c2VyaWZ5L21haW4uanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeSIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Cn0seyJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5IiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YiKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IiKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvciI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoidXNlIHN0cmljdCI7CgpleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICB9Cn07Cn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoidXNlIHN0cmljdCI7CgpleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwoKdmFyIF9kZWZpbmVQcm9wZXJ0eSA9IF9kZXJlcV8oIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSIpOwoKdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgewogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgewogICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOwogICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7CiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsKICAgICAgaWYgKCJ2YWx1ZSIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7CiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOwogICAgfQogIH0KCiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsKICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7CiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsKICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICB9Owp9KCk7Cn0seyIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoidXNlIHN0cmljdCI7CgpleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwoKdmFyIF9kZWZpbmVQcm9wZXJ0eSA9IF9kZXJlcV8oIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSIpOwoKdmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkgewogIGlmIChrZXkgaW4gb2JqKSB7CiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShvYmosIGtleSwgewogICAgICB2YWx1ZTogdmFsdWUsCiAgICAgIGVudW1lcmFibGU6IHRydWUsCiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgd3JpdGFibGU6IHRydWUKICAgIH0pOwogIH0gZWxzZSB7CiAgICBvYmpba2V5XSA9IHZhbHVlOwogIH0KCiAgcmV0dXJuIG9iajsKfTsKfSx7Ii4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Cgp2YXIgX3NldFByb3RvdHlwZU9mID0gX2RlcmVxXygiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZiIpOwoKdmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7Cgp2YXIgX2NyZWF0ZSA9IF9kZXJlcV8oIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZSIpOwoKdmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTsKCnZhciBfdHlwZW9mMiA9IF9kZXJlcV8oIi4uL2hlbHBlcnMvdHlwZW9mIik7Cgp2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9CgpleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsKICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICJmdW5jdGlvbiIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7CiAgfQoKICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgewogICAgY29uc3RydWN0b3I6IHsKICAgICAgdmFsdWU6IHN1YkNsYXNzLAogICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgfQogIH0pOwogIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOwp9Owp9LHsiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uL2hlbHBlcnMvdHlwZW9mIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Cgp2YXIgX3R5cGVvZjIgPSBfZGVyZXFfKCIuLi9oZWxwZXJzL3R5cGVvZiIpOwoKdmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHsKICBpZiAoIXNlbGYpIHsKICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7CiAgfQoKICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gIm9iamVjdCIgfHwgdHlwZW9mIGNhbGwgPT09ICJmdW5jdGlvbiIpID8gY2FsbCA6IHNlbGY7Cn07Cn0seyIuLi9oZWxwZXJzL3R5cGVvZiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Cgp2YXIgX2l0ZXJhdG9yID0gX2RlcmVxXygiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IiKTsKCnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpOwoKdmFyIF9zeW1ib2wgPSBfZGVyZXFfKCIuLi9jb3JlLWpzL3N5bWJvbCIpOwoKdmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTsKCnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09ICJmdW5jdGlvbiIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gInN5bWJvbCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSAiZnVuY3Rpb24iICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gInN5bWJvbCIgOiB0eXBlb2Ygb2JqOyB9OwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSAiZnVuY3Rpb24iICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gInN5bWJvbCIgPyBmdW5jdGlvbiAob2JqKSB7CiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiBfdHlwZW9mKG9iaik7Cn0gOiBmdW5jdGlvbiAob2JqKSB7CiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gImZ1bmN0aW9uIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/ICJzeW1ib2wiIDogdHlwZW9mIG9iaiA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2Yob2JqKTsKfTsKfSx7Ii4uL2NvcmUtanMvc3ltYm9sIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFzZTY0LWpzQDEuMy4wQGJhc2U2NC1qcy9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCcKCmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGgKZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5CmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXkKCnZhciBsb29rdXAgPSBbXQp2YXIgcmV2TG9va3VwID0gW10KdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheQoKdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycKZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICBsb29rdXBbaV0gPSBjb2RlW2ldCiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpCn0KCi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy4KLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9ucwpyZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjIKcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzCgpmdW5jdGlvbiBnZXRMZW5zIChiNjQpIHsKICB2YXIgbGVuID0gYjY0Lmxlbmd0aAoKICBpZiAobGVuICUgNCA+IDApIHsKICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpCiAgfQoKICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmQKICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDIKICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpCiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW4KCiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4KICAgID8gMAogICAgOiA0IC0gKHZhbGlkTGVuICUgNCkKCiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXQp9CgovLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGEKZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7CiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCkKICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdCiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV0KICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW4KfQoKZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikgewogIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlbgp9CgpmdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7CiAgdmFyIHRtcAogIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpCiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXQogIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdCgogIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpCgogIHZhciBjdXJCeXRlID0gMAoKICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzCiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAKICAgID8gdmFsaWRMZW4gLSA0CiAgICA6IHZhbGlkTGVuCgogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHsKICAgIHRtcCA9CiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8CiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfAogICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfAogICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXQogICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkYKICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkYKICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRgogIH0KCiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikgewogICAgdG1wID0KICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfAogICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCkKICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRgogIH0KCiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkgewogICAgdG1wID0KICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwKICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwKICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpCiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGCiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkYKICB9CgogIHJldHVybiBhcnIKfQoKZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHsKICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsKICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArCiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArCiAgICBsb29rdXBbbnVtICYgMHgzRl0KfQoKZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7CiAgdmFyIHRtcAogIHZhciBvdXRwdXQgPSBbXQogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7CiAgICB0bXAgPQogICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArCiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArCiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKQogICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpCiAgfQogIHJldHVybiBvdXRwdXQuam9pbignJykKfQoKZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHsKICB2YXIgdG1wCiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aAogIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlcwogIHZhciBwYXJ0cyA9IFtdCiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzCgogIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXIKICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKAogICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpCiAgICApKQogIH0KCiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlcwogIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXQogICAgcGFydHMucHVzaCgKICAgICAgbG9va3VwW3RtcCA+PiAyXSArCiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gKwogICAgICAnPT0nCiAgICApCiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7CiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXQogICAgcGFydHMucHVzaCgKICAgICAgbG9va3VwW3RtcCA+PiAxMF0gKwogICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICsKICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArCiAgICAgICc9JwogICAgKQogIH0KCiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpCn0KCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2Jyb3dzZXItcmVzb2x2ZUAxLjExLjJAYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19idWZmZXJANS4xLjBAYnVmZmVyL2luZGV4LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8qIQogKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci4KICoKICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz4KICogQGxpY2Vuc2UgIE1JVAogKi8KLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi8KCid1c2Ugc3RyaWN0JwoKdmFyIGJhc2U2NCA9IF9kZXJlcV8oJ2Jhc2U2NC1qcycpCnZhciBpZWVlNzU0ID0gX2RlcmVxXygnaWVlZTc1NCcpCgpleHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcgpleHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyCmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MAoKdmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmYKZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RICgovKioKICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDoKICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdCkKICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0CiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpCiAqCiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywKICogT3BlcmEgMTEuNissIGlPUyA0LjIrLgogKgogKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGUKICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YAogKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0CiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLgogKi8KQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpCgppZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJgogICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHsKICBjb25zb2xlLmVycm9yKAogICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICsKICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LicKICApCn0KCmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHsKICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/CiAgdHJ5IHsKICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKQogICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19CiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MgogIH0gY2F0Y2ggKGUpIHsKICAgIHJldHVybiBmYWxzZQogIH0KfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7CiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkgewogICAgICByZXR1cm4gdW5kZWZpbmVkCiAgICB9CiAgICByZXR1cm4gdGhpcy5idWZmZXIKICB9Cn0pCgpPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHsKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7CiAgICAgIHJldHVybiB1bmRlZmluZWQKICAgIH0KICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQKICB9Cn0pCgpmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkgewogIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpCiAgfQogIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlCiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCkKICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZQogIHJldHVybiBidWYKfQoKLyoqCiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpcgogKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mCiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHMKICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQKICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC4KICoKICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLgogKi8KCmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICAvLyBDb21tb24gY2FzZS4KICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHsKICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycKICAgICAgKQogICAgfQogICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZykKICB9CiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCn0KCi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3CmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJgogICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHsKICAgIHZhbHVlOiBudWxsLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICB3cml0YWJsZTogZmFsc2UKICB9KQp9CgpCdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24KCmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInZhbHVlIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpCiAgfQoKICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgKHZhbHVlICYmIGlzQXJyYXlCdWZmZXIodmFsdWUuYnVmZmVyKSkpIHsKICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKICB9CgogIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCkKICB9CgogIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKQp9CgovKioKICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3IKICogaWYgdmFsdWUgaXMgYSBudW1iZXIuCiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSkKICogQnVmZmVyLmZyb20oYXJyYXkpCiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcikKICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pCiAqKi8KQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCn0KCi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1ZzoKLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDgKQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZQpCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheQoKZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJykKICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJykKICB9Cn0KCmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykgewogIGFzc2VydFNpemUoc2l6ZSkKICBpZiAoc2l6ZSA8PSAwKSB7CiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpCiAgfQogIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHsKICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzCiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkCiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuCiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJwogICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKQogICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpCiAgfQogIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSkKfQoKLyoqCiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS4KICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKQogKiovCkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykgewogIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykKfQoKZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHsKICBhc3NlcnRTaXplKHNpemUpCiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCkKfQoKLyoqCiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuCiAqICovCkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7CiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpCn0KLyoqCiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLgogKi8KQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7CiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpCn0KCmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHsKICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHsKICAgIGVuY29kaW5nID0gJ3V0ZjgnCiAgfQoKICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKQogIH0KCiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwCiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpCgogIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZykKCiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7CiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGwKICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuCiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJykKICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpCiAgfQoKICByZXR1cm4gYnVmCn0KCmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7CiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMAogIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHsKICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1CiAgfQogIHJldHVybiBidWYKfQoKZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignIm9mZnNldCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJykKICB9CgogIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcibGVuZ3RoIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKQogIH0KCiAgdmFyIGJ1ZgogIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KQogIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KQogIH0gZWxzZSB7CiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKQogIH0KCiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UKICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZQogIHJldHVybiBidWYKfQoKZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7CiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7CiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDAKICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKQoKICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBidWYKICAgIH0KCiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbikKICAgIHJldHVybiBidWYKICB9CgogIGlmIChvYmopIHsKICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHsKICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkgewogICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMCkKICAgICAgfQogICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopCiAgICB9CgogICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkgewogICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSkKICAgIH0KICB9CgogIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LicpCn0KCmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkgewogIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlbgogIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKQogIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICsKICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpCiAgfQogIHJldHVybiBsZW5ndGggfCAwCn0KCmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkgewogIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcQogICAgbGVuZ3RoID0gMAogIH0KICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpCn0KCkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7CiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZQp9CgpCdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJykKICB9CgogIGlmIChhID09PSBiKSByZXR1cm4gMAoKICB2YXIgeCA9IGEubGVuZ3RoCiAgdmFyIHkgPSBiLmxlbmd0aAoKICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgeCA9IGFbaV0KICAgICAgeSA9IGJbaV0KICAgICAgYnJlYWsKICAgIH0KICB9CgogIGlmICh4IDwgeSkgcmV0dXJuIC0xCiAgaWYgKHkgPCB4KSByZXR1cm4gMQogIHJldHVybiAwCn0KCkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHsKICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkgewogICAgY2FzZSAnaGV4JzoKICAgIGNhc2UgJ3V0ZjgnOgogICAgY2FzZSAndXRmLTgnOgogICAgY2FzZSAnYXNjaWknOgogICAgY2FzZSAnbGF0aW4xJzoKICAgIGNhc2UgJ2JpbmFyeSc6CiAgICBjYXNlICdiYXNlNjQnOgogICAgY2FzZSAndWNzMic6CiAgICBjYXNlICd1Y3MtMic6CiAgICBjYXNlICd1dGYxNmxlJzoKICAgIGNhc2UgJ3V0Zi0xNmxlJzoKICAgICAgcmV0dXJuIHRydWUKICAgIGRlZmF1bHQ6CiAgICAgIHJldHVybiBmYWxzZQogIH0KfQoKQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7CiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJykKICB9CgogIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgewogICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKQogIH0KCiAgdmFyIGkKICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGxlbmd0aCA9IDAKICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aAogICAgfQogIH0KCiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpCiAgdmFyIHBvcyA9IDAKICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgdmFyIGJ1ZiA9IGxpc3RbaV0KICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmKSkgewogICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpCiAgICB9CiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKQogICAgfQogICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpCiAgICBwb3MgKz0gYnVmLmxlbmd0aAogIH0KICByZXR1cm4gYnVmZmVyCn0KCmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHsKICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHsKICAgIHJldHVybiBzdHJpbmcubGVuZ3RoCiAgfQogIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHsKICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aAogIH0KICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHsKICAgIHN0cmluZyA9ICcnICsgc3RyaW5nCiAgfQoKICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aAogIGlmIChsZW4gPT09IDApIHJldHVybiAwCgogIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvbgogIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlCiAgZm9yICg7OykgewogICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICBjYXNlICdhc2NpaSc6CiAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgcmV0dXJuIGxlbgogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICBjYXNlIHVuZGVmaW5lZDoKICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGgKICAgICAgY2FzZSAndWNzMic6CiAgICAgIGNhc2UgJ3Vjcy0yJzoKICAgICAgY2FzZSAndXRmMTZsZSc6CiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzoKICAgICAgICByZXR1cm4gbGVuICogMgogICAgICBjYXNlICdoZXgnOgogICAgICAgIHJldHVybiBsZW4gPj4+IDEKICAgICAgY2FzZSAnYmFzZTY0JzoKICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aAogICAgICBkZWZhdWx0OgogICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4CiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKQogICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZQogICAgfQogIH0KfQpCdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGgKCmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHsKICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZQoKICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0ICJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5CiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS4KCiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kCiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLgogIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sCiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uCiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7CiAgICBzdGFydCA9IDAKICB9CiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzIKICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LgogIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7CiAgICByZXR1cm4gJycKICB9CgogIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkgewogICAgZW5kID0gdGhpcy5sZW5ndGgKICB9CgogIGlmIChlbmQgPD0gMCkgewogICAgcmV0dXJuICcnCiAgfQoKICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLgogIGVuZCA+Pj49IDAKICBzdGFydCA+Pj49IDAKCiAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgcmV0dXJuICcnCiAgfQoKICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JwoKICB3aGlsZSAodHJ1ZSkgewogICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICBjYXNlICdoZXgnOgogICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAndXRmOCc6CiAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICdhc2NpaSc6CiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAndWNzMic6CiAgICAgIGNhc2UgJ3Vjcy0yJzoKICAgICAgY2FzZSAndXRmMTZsZSc6CiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzoKICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBkZWZhdWx0OgogICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKQogICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkKICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWUKICAgIH0KICB9Cn0KCi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSkKLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYAovLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudAovLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXIKLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLgovLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTQKQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlCgpmdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7CiAgdmFyIGkgPSBiW25dCiAgYltuXSA9IGJbbV0KICBiW21dID0gaQp9CgpCdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7CiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoCiAgaWYgKGxlbiAlIDIgIT09IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpCiAgfQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHsKICAgIHN3YXAodGhpcywgaSwgaSArIDEpCiAgfQogIHJldHVybiB0aGlzCn0KCkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHsKICB2YXIgbGVuID0gdGhpcy5sZW5ndGgKICBpZiAobGVuICUgNCAhPT0gMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJykKICB9CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkgewogICAgc3dhcCh0aGlzLCBpLCBpICsgMykKICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKQogIH0KICByZXR1cm4gdGhpcwp9CgpCdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7CiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoCiAgaWYgKGxlbiAlIDggIT09IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpCiAgfQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHsKICAgIHN3YXAodGhpcywgaSwgaSArIDcpCiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNikKICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KQogICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpCiAgfQogIHJldHVybiB0aGlzCn0KCkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7CiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoCiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnCiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKQogIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKQp9CgpCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZwoKQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpCiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlCiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwCn0KCkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkgewogIHZhciBzdHIgPSAnJwogIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTCiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgewogICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJykKICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICcKICB9CiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPicKfQoKQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJykKICB9CgogIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7CiAgICBzdGFydCA9IDAKICB9CiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7CiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMAogIH0KICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHsKICAgIHRoaXNTdGFydCA9IDAKICB9CiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkgewogICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoCiAgfQoKICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKQogIH0KCiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkgewogICAgcmV0dXJuIDAKICB9CiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7CiAgICByZXR1cm4gLTEKICB9CiAgaWYgKHN0YXJ0ID49IGVuZCkgewogICAgcmV0dXJuIDEKICB9CgogIHN0YXJ0ID4+Pj0gMAogIGVuZCA+Pj49IDAKICB0aGlzU3RhcnQgPj4+PSAwCiAgdGhpc0VuZCA+Pj49IDAKCiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDAKCiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0CiAgdmFyIHkgPSBlbmQgLSBzdGFydAogIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KQoKICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCkKICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKQoKICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKICAgICAgeCA9IHRoaXNDb3B5W2ldCiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldCiAgICAgIGJyZWFrCiAgICB9CiAgfQoKICBpZiAoeCA8IHkpIHJldHVybiAtMQogIGlmICh5IDwgeCkgcmV0dXJuIDEKICByZXR1cm4gMAp9CgovLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsCi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuCi8vCi8vIEFyZ3VtZW50czoKLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2gKLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXIKLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyCi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nCi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mCmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaAogIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTEKCiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQKICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7CiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQKICAgIGJ5dGVPZmZzZXQgPSAwCiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgewogICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmYKICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgewogICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwCiAgfQogIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci4KICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHsKICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sICJmb28iLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXIKICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKQogIH0KCiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXIKICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldAogIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKICAgIGlmIChkaXIpIHJldHVybiAtMQogICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDEKICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7CiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMAogICAgZWxzZSByZXR1cm4gLTEKICB9CgogIC8vIE5vcm1hbGl6ZSB2YWwKICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpCiAgfQoKICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZgogIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkgewogICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlscwogICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIC0xCiAgICB9CiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKQogIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XQogICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIGlmIChkaXIpIHsKICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KQogICAgICB9CiAgICB9CiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikKICB9CgogIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpCn0KCmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICB2YXIgaW5kZXhTaXplID0gMQogIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoCiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGgKCiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHsKICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fAogICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHsKICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7CiAgICAgICAgcmV0dXJuIC0xCiAgICAgIH0KICAgICAgaW5kZXhTaXplID0gMgogICAgICBhcnJMZW5ndGggLz0gMgogICAgICB2YWxMZW5ndGggLz0gMgogICAgICBieXRlT2Zmc2V0IC89IDIKICAgIH0KICB9CgogIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkgewogICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkgewogICAgICByZXR1cm4gYnVmW2ldCiAgICB9IGVsc2UgewogICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKQogICAgfQogIH0KCiAgdmFyIGkKICBpZiAoZGlyKSB7CiAgICB2YXIgZm91bmRJbmRleCA9IC0xCiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkgewogICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGkKICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplCiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4CiAgICAgICAgZm91bmRJbmRleCA9IC0xCiAgICAgIH0KICAgIH0KICB9IGVsc2UgewogICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGgKICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgIHZhciBmb3VuZCA9IHRydWUKICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykgewogICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHsKICAgICAgICAgIGZvdW5kID0gZmFsc2UKICAgICAgICAgIGJyZWFrCiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGkKICAgIH0KICB9CgogIHJldHVybiAtMQp9CgpCdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMQp9CgpCdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpCn0KCkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSkKfQoKZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDAKICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldAogIGlmICghbGVuZ3RoKSB7CiAgICBsZW5ndGggPSByZW1haW5pbmcKICB9IGVsc2UgewogICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCkKICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHsKICAgICAgbGVuZ3RoID0gcmVtYWluaW5nCiAgICB9CiAgfQoKICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aAoKICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikgewogICAgbGVuZ3RoID0gc3RyTGVuIC8gMgogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KQogICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpCiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQKICB9CiAgcmV0dXJuIGkKfQoKZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCkKfQoKZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKfQoKZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCkKfQoKZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7CiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZykKICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHsKICAgIGVuY29kaW5nID0gJ3V0ZjgnCiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aAogICAgb2Zmc2V0ID0gMAogIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKQogIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHsKICAgIGVuY29kaW5nID0gb2Zmc2V0CiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aAogICAgb2Zmc2V0ID0gMAogIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pCiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7CiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7CiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMAogICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCcKICAgIH0gZWxzZSB7CiAgICAgIGVuY29kaW5nID0gbGVuZ3RoCiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZAogICAgfQogIH0gZWxzZSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCcKICAgICkKICB9CgogIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldAogIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZwoKICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJykKICB9CgogIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnCgogIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlCiAgZm9yICg7OykgewogICAgc3dpdGNoIChlbmNvZGluZykgewogICAgICBjYXNlICdoZXgnOgogICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgY2FzZSAndXRmOCc6CiAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICdhc2NpaSc6CiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlCiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKQogICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZQogICAgfQogIH0KfQoKQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkgewogIHJldHVybiB7CiAgICB0eXBlOiAnQnVmZmVyJywKICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKQogIH0KfQoKZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHsKICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpCiAgfSBlbHNlIHsKICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpCiAgfQp9CgpmdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKICB2YXIgcmVzID0gW10KCiAgdmFyIGkgPSBzdGFydAogIHdoaWxlIChpIDwgZW5kKSB7CiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldCiAgICB2YXIgY29kZVBvaW50ID0gbnVsbAogICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0CiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gMwogICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDIKICAgICAgOiAxCgogICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkgewogICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50CgogICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHsKICAgICAgICBjYXNlIDE6CiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkgewogICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGUKICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrCiAgICAgICAgY2FzZSAyOgogICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV0KICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKQogICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHsKICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGJyZWFrCiAgICAgICAgY2FzZSAzOgogICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV0KICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl0KICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkgewogICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRikKICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDQ6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXQogICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM10KICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKQogICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHsKICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHsKICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYQogICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlCiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRAogICAgICBieXRlc1BlclNlcXVlbmNlID0gMQogICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHsKICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSkKICAgICAgY29kZVBvaW50IC09IDB4MTAwMDAKICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKQogICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRgogICAgfQoKICAgIHJlcy5wdXNoKGNvZGVQb2ludCkKICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZQogIH0KCiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpCn0KCi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aAovLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuCi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHkKdmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwCgpmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHsKICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGgKICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7CiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKCkKICB9CgogIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZCIuCiAgdmFyIHJlcyA9ICcnCiAgdmFyIGkgPSAwCiAgd2hpbGUgKGkgPCBsZW4pIHsKICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KAogICAgICBTdHJpbmcsCiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkKICAgICkKICB9CiAgcmV0dXJuIHJlcwp9CgpmdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKICB2YXIgcmV0ID0gJycKICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpCgogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKQogIH0KICByZXR1cm4gcmV0Cn0KCmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKICB2YXIgcmV0ID0gJycKICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpCgogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pCiAgfQogIHJldHVybiByZXQKfQoKZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciBsZW4gPSBidWYubGVuZ3RoCgogIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDAKICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuCgogIHZhciBvdXQgPSAnJwogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKQogIH0KICByZXR1cm4gb3V0Cn0KCmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpCiAgdmFyIHJlcyA9ICcnCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikgewogICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSkKICB9CiAgcmV0dXJuIHJlcwp9CgpCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHsKICB2YXIgbGVuID0gdGhpcy5sZW5ndGgKICBzdGFydCA9IH5+c3RhcnQKICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kCgogIGlmIChzdGFydCA8IDApIHsKICAgIHN0YXJ0ICs9IGxlbgogICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwCiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikgewogICAgc3RhcnQgPSBsZW4KICB9CgogIGlmIChlbmQgPCAwKSB7CiAgICBlbmQgKz0gbGVuCiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMAogIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7CiAgICBlbmQgPSBsZW4KICB9CgogIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQKCiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkKICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZQogIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlCiAgcmV0dXJuIG5ld0J1Zgp9CgovKgogKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy4KICovCmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7CiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JykKICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpCgogIHZhciB2YWwgPSB0aGlzW29mZnNldF0KICB2YXIgbXVsID0gMQogIHZhciBpID0gMAogIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bAogIH0KCiAgcmV0dXJuIHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKQogIH0KCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXQogIHZhciBtdWwgPSAxCiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsCiAgfQoKICByZXR1cm4gdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCkKICByZXR1cm4gdGhpc1tvZmZzZXRdCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCkKICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfAogICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8CiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgKwogICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKQoKICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgKwogICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8CiAgICB0aGlzW29mZnNldCArIDNdKQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XQogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsCiAgfQogIG11bCAqPSAweDgwCgogIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpCgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpCgogIHZhciBpID0gYnl0ZUxlbmd0aAogIHZhciBtdWwgPSAxCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXQogIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bAogIH0KICBtdWwgKj0gMHg4MAoKICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKQoKICByZXR1cm4gdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpCiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKQogIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KQogIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCkKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCkKICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAodGhpc1tvZmZzZXRdKSB8CiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8CiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfAogICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8CiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfAogICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfAogICAgKHRoaXNbb2Zmc2V0ICsgM10pCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCkKICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCkKICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KQp9CgpmdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7CiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignImJ1ZmZlciIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpCiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJykKICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMQogICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApCiAgfQoKICB2YXIgbXVsID0gMQogIHZhciBpID0gMAogIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRgogIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkYKICB9CgogIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMQogICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApCiAgfQoKICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxCiAgdmFyIG11bCA9IDEKICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkYKICB9CgogIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDEKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpCiAgcmV0dXJuIG9mZnNldCArIDIKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDIKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApCiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpCgogICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpCiAgfQoKICB2YXIgaSA9IDAKICB2YXIgbXVsID0gMQogIHZhciBzdWIgPSAwCiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7CiAgICAgIHN1YiA9IDEKICAgIH0KICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkYKICB9CgogIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSkKCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCkKICB9CgogIHZhciBpID0gYnl0ZUxlbmd0aCAtIDEKICB2YXIgbXVsID0gMQogIHZhciBzdWIgPSAwCiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRgogIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHsKICAgICAgc3ViID0gMQogICAgfQogICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCkKICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDEKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHJldHVybiBvZmZzZXQgKyAxCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDIKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCkKICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKQogIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpCiAgcmV0dXJuIG9mZnNldCArIDQKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCkKICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEKICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KQogIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KQogIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpCiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDQKfQoKZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKQp9CgpmdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KQogIH0KICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCkKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCkKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KQp9CgpmdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KQogIH0KICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCkKICByZXR1cm4gb2Zmc2V0ICsgOAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCkKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KQp9CgovLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpCkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKQogIGlmICghc3RhcnQpIHN0YXJ0ID0gMAogIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGgKICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoCiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwCiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0CgogIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZQogIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMAogIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMAoKICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zCiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKQogIH0KICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJykKCiAgLy8gQXJlIHdlIG9vYj8KICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoCiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7CiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydAogIH0KCiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0CgogIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHsKICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTEKICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkKICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7CiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmQKICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkgewogICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XQogICAgfQogIH0gZWxzZSB7CiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCgKICAgICAgdGFyZ2V0LAogICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLAogICAgICB0YXJnZXRTdGFydAogICAgKQogIH0KCiAgcmV0dXJuIGxlbgp9CgovLyBVc2FnZToKLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pCi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKQovLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSkKQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykgewogIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6CiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7CiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykgewogICAgICBlbmNvZGluZyA9IHN0YXJ0CiAgICAgIHN0YXJ0ID0gMAogICAgICBlbmQgPSB0aGlzLmxlbmd0aAogICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykgewogICAgICBlbmNvZGluZyA9IGVuZAogICAgICBlbmQgPSB0aGlzLmxlbmd0aAogICAgfQogICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJykKICAgIH0KICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKQogICAgfQogICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHsKICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKQogICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHwKICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykgewogICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuCiAgICAgICAgdmFsID0gY29kZQogICAgICB9CiAgICB9CiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykgewogICAgdmFsID0gdmFsICYgMjU1CiAgfQoKICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS4KICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKQogIH0KCiAgaWYgKGVuZCA8PSBzdGFydCkgewogICAgcmV0dXJuIHRoaXMKICB9CgogIHN0YXJ0ID0gc3RhcnQgPj4+IDAKICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwCgogIGlmICghdmFsKSB2YWwgPSAwCgogIHZhciBpCiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7CiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7CiAgICAgIHRoaXNbaV0gPSB2YWwKICAgIH0KICB9IGVsc2UgewogICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbCkKICAgICAgPyB2YWwKICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpCiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoCiAgICBpZiAobGVuID09PSAwKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSAiJyArIHZhbCArCiAgICAgICAgJyIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgInZhbHVlIicpCiAgICB9CiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkgewogICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXQogICAgfQogIH0KCiAgcmV0dXJuIHRoaXMKfQoKLy8gSEVMUEVSIEZVTkNUSU9OUwovLyA9PT09PT09PT09PT09PT09Cgp2YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nCgpmdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7CiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZwogIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdCiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxuIGFuZCBcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdAogIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpCiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJwogIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnCiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90CiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7CiAgICBzdHIgPSBzdHIgKyAnPScKICB9CiAgcmV0dXJuIHN0cgp9CgpmdW5jdGlvbiB0b0hleCAobikgewogIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KQogIHJldHVybiBuLnRvU3RyaW5nKDE2KQp9CgpmdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykgewogIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHkKICB2YXIgY29kZVBvaW50CiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgKICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGwKICB2YXIgYnl0ZXMgPSBbXQoKICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKQoKICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnQKICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7CiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkCiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkgewogICAgICAgIC8vIG5vIGxlYWQgeWV0CiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikgewogICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbAogICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICAgICAgICBjb250aW51ZQogICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkgewogICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZAogICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICAgICAgICBjb250aW51ZQogICAgICAgIH0KCiAgICAgICAgLy8gdmFsaWQgbGVhZAogICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQKCiAgICAgICAgY29udGludWUKICAgICAgfQoKICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvdwogICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7CiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludAogICAgICAgIGNvbnRpbnVlCiAgICAgIH0KCiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyCiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDAKICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkgewogICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkCiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKQogICAgfQoKICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsCgogICAgLy8gZW5jb2RlIHV0ZjgKICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7CiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVhawogICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCkKICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHsKICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsCiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODAKICAgICAgKQogICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7CiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVhawogICAgICBieXRlcy5wdXNoKAogICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLAogICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwKICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MAogICAgICApCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7CiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVhawogICAgICBieXRlcy5wdXNoKAogICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCwKICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsCiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLAogICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwCiAgICAgICkKICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JykKICAgIH0KICB9CgogIHJldHVybiBieXRlcwp9CgpmdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikgewogIHZhciBieXRlQXJyYXkgPSBbXQogIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi4KICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRikKICB9CiAgcmV0dXJuIGJ5dGVBcnJheQp9CgpmdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykgewogIHZhciBjLCBoaSwgbG8KICB2YXIgYnl0ZUFycmF5ID0gW10KICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrCgogICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpCiAgICBoaSA9IGMgPj4gOAogICAgbG8gPSBjICUgMjU2CiAgICBieXRlQXJyYXkucHVzaChsbykKICAgIGJ5dGVBcnJheS5wdXNoKGhpKQogIH0KCiAgcmV0dXJuIGJ5dGVBcnJheQp9CgpmdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHsKICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpCn0KCmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkgewogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWsKICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXQogIH0KICByZXR1cm4gaQp9CgovLyBBcnJheUJ1ZmZlcnMgZnJvbSBhbm90aGVyIGNvbnRleHQgKGkuZS4gYW4gaWZyYW1lKSBkbyBub3QgcGFzcyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrCi8vIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjYKZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7CiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8CiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiYKICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykKfQoKZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikgewogIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZQp9Cgp9LHsiYmFzZTY0LWpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYXNlNjQtanNAMS4zLjBAYmFzZTY0LWpzL2luZGV4LmpzIiwiaWVlZTc1NCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9faWVlZTc1NEAxLjEuMTFAaWVlZTc1NC9pbmRleC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jbG9uZUAyLjEuMUBjbG9uZS9jbG9uZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKEJ1ZmZlcil7CnZhciBjbG9uZSA9IChmdW5jdGlvbigpIHsKJ3VzZSBzdHJpY3QnOwoKZnVuY3Rpb24gX2luc3RhbmNlb2Yob2JqLCB0eXBlKSB7CiAgcmV0dXJuIHR5cGUgIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiB0eXBlOwp9Cgp2YXIgbmF0aXZlTWFwOwp0cnkgewogIG5hdGl2ZU1hcCA9IE1hcDsKfSBjYXRjaChfKSB7CiAgLy8gbWF5YmUgYSByZWZlcmVuY2UgZXJyb3IgYmVjYXVzZSBubyBgTWFwYC4gR2l2ZSBpdCBhIGR1bW15IHZhbHVlIHRoYXQgbm8KICAvLyB2YWx1ZSB3aWxsIGV2ZXIgYmUgYW4gaW5zdGFuY2VvZi4KICBuYXRpdmVNYXAgPSBmdW5jdGlvbigpIHt9Owp9Cgp2YXIgbmF0aXZlU2V0Owp0cnkgewogIG5hdGl2ZVNldCA9IFNldDsKfSBjYXRjaChfKSB7CiAgbmF0aXZlU2V0ID0gZnVuY3Rpb24oKSB7fTsKfQoKdmFyIG5hdGl2ZVByb21pc2U7CnRyeSB7CiAgbmF0aXZlUHJvbWlzZSA9IFByb21pc2U7Cn0gY2F0Y2goXykgewogIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbigpIHt9Owp9CgovKioKICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuCiAqCiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluCiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZQogKiBieSBjYWxsaW5nIGNsb25lKG9iaiwgZmFsc2UpLgogKgogKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLAogKiB5b3VyIHByb2dyYW0gbWF5IGVudGVyIGFuIGluZmluaXRlIGxvb3AgYW5kIGNyYXNoLgogKgogKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZAogKiBAcGFyYW0gYGNpcmN1bGFyYCAtIHNldCB0byB0cnVlIGlmIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkIG1heSBjb250YWluCiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdCkKICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0bwogKiAgICBhIHBhcnRpY3VsYXIgZGVwdGguIChvcHRpb25hbCAtIGRlZmF1bHRzIHRvIEluZmluaXR5KQogKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LgogKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS4KICogQHBhcmFtIGBpbmNsdWRlTm9uRW51bWVyYWJsZWAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcwogKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZQogKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpCiovCmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUsIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7CiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHsKICAgIGRlcHRoID0gY2lyY3VsYXIuZGVwdGg7CiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7CiAgICBpbmNsdWRlTm9uRW51bWVyYWJsZSA9IGNpcmN1bGFyLmluY2x1ZGVOb25FbnVtZXJhYmxlOwogICAgY2lyY3VsYXIgPSBjaXJjdWxhci5jaXJjdWxhcjsKICB9CiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzCiAgLy8gYW5kIGNoaWxkcmVuIGhhdmUgdGhlIHNhbWUgaW5kZXgKICB2YXIgYWxsUGFyZW50cyA9IFtdOwogIHZhciBhbGxDaGlsZHJlbiA9IFtdOwoKICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJzsKCiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PSAndW5kZWZpbmVkJykKICAgIGNpcmN1bGFyID0gdHJ1ZTsKCiAgaWYgKHR5cGVvZiBkZXB0aCA9PSAndW5kZWZpbmVkJykKICAgIGRlcHRoID0gSW5maW5pdHk7CgogIC8vIHJlY3Vyc2UgdGhpcyBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNldCBhbGxQYXJlbnRzIGFuZCBhbGxDaGlsZHJlbgogIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7CiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbAogICAgaWYgKHBhcmVudCA9PT0gbnVsbCkKICAgICAgcmV0dXJuIG51bGw7CgogICAgaWYgKGRlcHRoID09PSAwKQogICAgICByZXR1cm4gcGFyZW50OwoKICAgIHZhciBjaGlsZDsKICAgIHZhciBwcm90bzsKICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7CiAgICAgIHJldHVybiBwYXJlbnQ7CiAgICB9CgogICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlTWFwKSkgewogICAgICBjaGlsZCA9IG5ldyBuYXRpdmVNYXAoKTsKICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7CiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVNldCgpOwogICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVByb21pc2UpKSB7CiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgewogICAgICAgIHBhcmVudC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7CiAgICAgICAgICByZXNvbHZlKF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKSk7CiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICByZWplY3QoX2Nsb25lKGVyciwgZGVwdGggLSAxKSk7CiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzQXJyYXkocGFyZW50KSkgewogICAgICBjaGlsZCA9IFtdOwogICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHsKICAgICAgY2hpbGQgPSBuZXcgUmVnRXhwKHBhcmVudC5zb3VyY2UsIF9fZ2V0UmVnRXhwRmxhZ3MocGFyZW50KSk7CiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4OwogICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7CiAgICAgIGNoaWxkID0gbmV3IERhdGUocGFyZW50LmdldFRpbWUoKSk7CiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkgewogICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7CiAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTsKICAgICAgcmV0dXJuIGNoaWxkOwogICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkgewogICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTsKICAgIH0gZWxzZSB7CiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTsKICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG8pOwogICAgICB9CiAgICAgIGVsc2UgewogICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpOwogICAgICAgIHByb3RvID0gcHJvdG90eXBlOwogICAgICB9CiAgICB9CgogICAgaWYgKGNpcmN1bGFyKSB7CiAgICAgIHZhciBpbmRleCA9IGFsbFBhcmVudHMuaW5kZXhPZihwYXJlbnQpOwoKICAgICAgaWYgKGluZGV4ICE9IC0xKSB7CiAgICAgICAgcmV0dXJuIGFsbENoaWxkcmVuW2luZGV4XTsKICAgICAgfQogICAgICBhbGxQYXJlbnRzLnB1c2gocGFyZW50KTsKICAgICAgYWxsQ2hpbGRyZW4ucHVzaChjaGlsZCk7CiAgICB9CgogICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlTWFwKSkgewogICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7CiAgICAgICAgdmFyIGtleUNoaWxkID0gX2Nsb25lKGtleSwgZGVwdGggLSAxKTsKICAgICAgICB2YXIgdmFsdWVDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTsKICAgICAgICBjaGlsZC5zZXQoa2V5Q2hpbGQsIHZhbHVlQ2hpbGQpOwogICAgICB9KTsKICAgIH0KICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHsKICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICB2YXIgZW50cnlDaGlsZCA9IF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKTsKICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7CiAgICAgIH0pOwogICAgfQoKICAgIGZvciAodmFyIGkgaW4gcGFyZW50KSB7CiAgICAgIHZhciBhdHRyczsKICAgICAgaWYgKHByb3RvKSB7CiAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTsKICAgICAgfQoKICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnNldCA9PSBudWxsKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpOwogICAgfQoKICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7CiAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwYXJlbnQpOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGNsb25pbmcgYSBzeW1ib2wgYmVjYXVzZSBpdCBpcyBhIHByaW1pdGl2ZSwKICAgICAgICAvLyBsaWtlIGEgbnVtYmVyIG9yIHN0cmluZy4KICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTsKICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBzeW1ib2wpOwogICAgICAgIGlmIChkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLmVudW1lcmFibGUgJiYgIWluY2x1ZGVOb25FbnVtZXJhYmxlKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgY2hpbGRbc3ltYm9sXSA9IF9jbG9uZShwYXJlbnRbc3ltYm9sXSwgZGVwdGggLSAxKTsKICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkgewogICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBzeW1ib2wsIHsKICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIGlmIChpbmNsdWRlTm9uRW51bWVyYWJsZSkgewogICAgICB2YXIgYWxsUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudCk7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsUHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBhbGxQcm9wZXJ0eU5hbWVzW2ldOwogICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7CiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7CiAgICAgICAgICBjb250aW51ZTsKICAgICAgICB9CiAgICAgICAgY2hpbGRbcHJvcGVydHlOYW1lXSA9IF9jbG9uZShwYXJlbnRbcHJvcGVydHlOYW1lXSwgZGVwdGggLSAxKTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hpbGQsIHByb3BlcnR5TmFtZSwgewogICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UKICAgICAgICB9KTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBjaGlsZDsKICB9CgogIHJldHVybiBfY2xvbmUocGFyZW50LCBkZXB0aCk7Cn0KCi8qKgogKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eQogKiBvdmVycmlkZSBvbiBGTEFUIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChubyBuZXN0ZWQgcHJvcHMpLgogKgogKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpcwogKiB3b3Jrcy4KICovCmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7CiAgaWYgKHBhcmVudCA9PT0gbnVsbCkKICAgIHJldHVybiBudWxsOwoKICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9OwogIGMucHJvdG90eXBlID0gcGFyZW50OwogIHJldHVybiBuZXcgYygpOwp9OwoKLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9ucwoKZnVuY3Rpb24gX19vYmpUb1N0cihvKSB7CiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTsKfQpjbG9uZS5fX29ialRvU3RyID0gX19vYmpUb1N0cjsKCmZ1bmN0aW9uIF9faXNEYXRlKG8pIHsKICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IERhdGVdJzsKfQpjbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlOwoKZnVuY3Rpb24gX19pc0FycmF5KG8pIHsKICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7Cn0KY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5OwoKZnVuY3Rpb24gX19pc1JlZ0V4cChvKSB7CiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJzsKfQpjbG9uZS5fX2lzUmVnRXhwID0gX19pc1JlZ0V4cDsKCmZ1bmN0aW9uIF9fZ2V0UmVnRXhwRmxhZ3MocmUpIHsKICB2YXIgZmxhZ3MgPSAnJzsKICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7CiAgaWYgKHJlLmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJzsKICBpZiAocmUubXVsdGlsaW5lKSBmbGFncyArPSAnbSc7CiAgcmV0dXJuIGZsYWdzOwp9CmNsb25lLl9fZ2V0UmVnRXhwRmxhZ3MgPSBfX2dldFJlZ0V4cEZsYWdzOwoKcmV0dXJuIGNsb25lOwp9KSgpOwoKaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7CiAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZTsKfQoKfSkuY2FsbCh0aGlzLF9kZXJlcV8oImJ1ZmZlciIpLkJ1ZmZlcikKCn0seyJidWZmZXIiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2J1ZmZlckA1LjEuMEBidWZmZXIvaW5kZXguanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnkuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGNvcmUgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJyk7CnZhciAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0geyBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5IH0pOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzCiAgcmV0dXJuICRKU09OLnN0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJndW1lbnRzKTsKfTsKCn0seyIuLi8uLi9tb2R1bGVzL19jb3JlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24uanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduOwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpOwp2YXIgJE9iamVjdCA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHsKICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7Cn07Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7CnZhciAkT2JqZWN0ID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7CiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7Cn07Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mOwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mOwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpOwpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpOwpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmciOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCIuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIi4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvciI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwiLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7Cgp9LHsiLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIi4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvciI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwiLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTsKICByZXR1cm4gaXQ7Cn07Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTsKICByZXR1cm4gaXQ7Cn07Cgp9LHsiLi9faXMtb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZgovLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlcwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgdG9MZW5ndGggPSBfZGVyZXFfKCcuL190by1sZW5ndGgnKTsKdmFyIHRvQWJzb2x1dGVJbmRleCA9IF9kZXJlcV8oJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7CiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkgewogICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpOwogICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTsKICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7CiAgICB2YXIgdmFsdWU7CiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtCiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlCiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkgewogICAgICB2YWx1ZSA9IE9baW5kZXgrK107CiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUKICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTsKICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3QKICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHsKICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7CiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7CiAgfTsKfTsKCn0seyIuL190by1hYnNvbHV0ZS1pbmRleCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCIuL190by1pb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwiLi9fdG8tbGVuZ3RoIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nOwoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpOwp9OwoKfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjcnIH07CmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmCgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nCnZhciBhRnVuY3Rpb24gPSBfZGVyZXFfKCcuL19hLWZ1bmN0aW9uJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHsKICBhRnVuY3Rpb24oZm4pOwogIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjsKICBzd2l0Y2ggKGxlbmd0aCkgewogICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHsKICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7CiAgICB9OwogICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7CiAgICB9OwogICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHsKICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7CiAgICB9OwogIH0KICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHsKICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpOwogIH07Cn07Cgp9LHsiLi9fYS1mdW5jdGlvbiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIiArIGl0KTsKICByZXR1cm4gaXQ7Cn07Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5Cm1vZHVsZS5leHBvcnRzID0gIV9kZXJlcV8oJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgewogIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3Owp9KTsKCn0seyIuL19mYWlscyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKdmFyIGRvY3VtZW50ID0gX2RlcmVxXygnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7Ci8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRQp2YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTsKfTsKCn0seyIuL19nbG9iYWwiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIi4vX2lzLW9iamVjdCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5cwptb2R1bGUuZXhwb3J0cyA9ICgKICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJwopLnNwbGl0KCcsJyk7Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHMKdmFyIGdldEtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cycpOwp2YXIgZ09QUyA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BzJyk7CnZhciBwSUUgPSBfZGVyZXFfKCcuL19vYmplY3QtcGllJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpOwogIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mOwogIGlmIChnZXRTeW1ib2xzKSB7CiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpOwogICAgdmFyIGlzRW51bSA9IHBJRS5mOwogICAgdmFyIGkgPSAwOwogICAgdmFyIGtleTsKICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTsKICB9IHJldHVybiByZXN1bHQ7Cn07Cgp9LHsiLi9fb2JqZWN0LWdvcHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwiLi9fb2JqZWN0LWtleXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwiLi9fb2JqZWN0LXBpZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgY29yZSA9IF9kZXJlcV8oJy4vX2NvcmUnKTsKdmFyIGN0eCA9IF9kZXJlcV8oJy4vX2N0eCcpOwp2YXIgaGlkZSA9IF9kZXJlcV8oJy4vX2hpZGUnKTsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7Cgp2YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHsKICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjsKICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRzsKICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUzsKICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QOwogIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjsKICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7CiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTsKICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07CiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07CiAgdmFyIGtleSwgb3duLCBvdXQ7CiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTsKICBmb3IgKGtleSBpbiBzb3VyY2UpIHsKICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZQogICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDsKICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlOwogICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWQKICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07CiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXMKICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldCiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dAogICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkKICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5CiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7CiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsKICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHsKICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkgewogICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpOwogICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTsKICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7CiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTsKICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgIH07CiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTsKICAgICAgcmV0dXJuIEY7CiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHMKICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDsKICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJQogICAgaWYgKElTX1BST1RPKSB7CiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDsKICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSUKICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTsKICAgIH0KICB9Cn07Ci8vIHR5cGUgYml0bWFwCiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkCiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsCiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljCiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG8KJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kCiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcAokZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmUKJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgCm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsKCn0seyIuL19jb3JlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwiLi9fY3R4IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCIuL19nbG9iYWwiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIi4vX2hhcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwiLi9faGlkZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7CiAgdHJ5IHsKICAgIHJldHVybiAhIWV4ZWMoKTsKICB9IGNhdGNoIChlKSB7CiAgICByZXR1cm4gdHJ1ZTsKICB9Cn07Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjgKdmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoCiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMKICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7CmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkgewogIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpOwp9OwoKfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZFAgPSBfZGVyZXFfKCcuL19vYmplY3QtZHAnKTsKdmFyIGNyZWF0ZURlc2MgPSBfZGVyZXFfKCcuL19wcm9wZXJ0eS1kZXNjJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHsKICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpOwp9IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkgewogIG9iamVjdFtrZXldID0gdmFsdWU7CiAgcmV0dXJuIG9iamVjdDsKfTsKCn0seyIuL19kZXNjcmlwdG9ycyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCIuL19vYmplY3QtZHAiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4vX3Byb3BlcnR5LWRlc2MiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZG9jdW1lbnQgPSBfZGVyZXFfKCcuL19nbG9iYWwnKS5kb2N1bWVudDsKbW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7Cgp9LHsiLi9fZ2xvYmFsIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSAhX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSAmJiAhX2RlcmVxXygnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZGVyZXFfKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNzsKfSk7Cgp9LHsiLi9fZGVzY3JpcHRvcnMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwiLi9fZG9tLWNyZWF0ZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIi4vX2ZhaWxzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzCnZhciBjb2YgPSBfZGVyZXFfKCcuL19jb2YnKTsKLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucwptb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpOwp9OwoKfSx7Ii4vX2NvZiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpCnZhciBjb2YgPSBfZGVyZXFfKCcuL19jb2YnKTsKbW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7CiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7Cn07Cgp9LHsiLi9fY29mIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJzsKfTsKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKdmFyIGNyZWF0ZSA9IF9kZXJlcV8oJy4vX29iamVjdC1jcmVhdGUnKTsKdmFyIGRlc2NyaXB0b3IgPSBfZGVyZXFfKCcuL19wcm9wZXJ0eS1kZXNjJyk7CnZhciBzZXRUb1N0cmluZ1RhZyA9IF9kZXJlcV8oJy4vX3NldC10by1zdHJpbmctdGFnJyk7CnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OwoKLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKCkKX2RlcmVxXygnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCBfZGVyZXFfKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkgewogIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pOwogIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpOwp9OwoKfSx7Ii4vX2hpZGUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCIuL19vYmplY3QtY3JlYXRlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLi9fcHJvcGVydHktZGVzYyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIi4vX3NldC10by1zdHJpbmctdGFnIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIi4vX3drcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKdmFyIExJQlJBUlkgPSBfZGVyZXFfKCcuL19saWJyYXJ5Jyk7CnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CnZhciByZWRlZmluZSA9IF9kZXJlcV8oJy4vX3JlZGVmaW5lJyk7CnZhciBoaWRlID0gX2RlcmVxXygnLi9faGlkZScpOwp2YXIgSXRlcmF0b3JzID0gX2RlcmVxXygnLi9faXRlcmF0b3JzJyk7CnZhciAkaXRlckNyZWF0ZSA9IF9kZXJlcV8oJy4vX2l0ZXItY3JlYXRlJyk7CnZhciBzZXRUb1N0cmluZ1RhZyA9IF9kZXJlcV8oJy4vX3NldC10by1zdHJpbmctdGFnJyk7CnZhciBnZXRQcm90b3R5cGVPZiA9IF9kZXJlcV8oJy4vX29iamVjdC1ncG8nKTsKdmFyIElURVJBVE9SID0gX2RlcmVxXygnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7CnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YAp2YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7CnZhciBLRVlTID0gJ2tleXMnOwp2YXIgVkFMVUVTID0gJ3ZhbHVlcyc7Cgp2YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHsKICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7CiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7CiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTsKICAgIHN3aXRjaCAoa2luZCkgewogICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9OwogICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTsKICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07CiAgfTsKICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InOwogIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7CiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTsKICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTsKICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTsKICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTsKICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkOwogIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTsKICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTsKICAvLyBGaXggbmF0aXZlCiAgaWYgKCRhbnlOYXRpdmUpIHsKICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTsKICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7CiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnMKICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7CiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lcwogICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7CiAgICB9CiAgfQogIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkYKICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7CiAgICBWQUxVRVNfQlVHID0gdHJ1ZTsKICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9OwogIH0KICAvLyBEZWZpbmUgaXRlcmF0b3IKICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHsKICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7CiAgfQogIC8vIFBsdWcgZm9yIGxpYnJhcnkKICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDsKICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7CiAgaWYgKERFRkFVTFQpIHsKICAgIG1ldGhvZHMgPSB7CiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksCiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLAogICAgICBlbnRyaWVzOiAkZW50cmllcwogICAgfTsKICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHsKICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTsKICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7CiAgfQogIHJldHVybiBtZXRob2RzOwp9OwoKfSx7Ii4vX2V4cG9ydCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi9faGlkZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIi4vX2l0ZXItY3JlYXRlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi4vX2l0ZXJhdG9ycyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwiLi9fbGlicmFyeSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIi4vX29iamVjdC1ncG8iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCIuL19yZWRlZmluZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCIuL19zZXQtdG8tc3RyaW5nLXRhZyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCIuL193a3MiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHsKICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9Owp9OwoKfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0ge307Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gdHJ1ZTsKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIE1FVEEgPSBfZGVyZXFfKCcuL191aWQnKSgnbWV0YScpOwp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgc2V0RGVzYyA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmY7CnZhciBpZCA9IDA7CnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHsKICByZXR1cm4gdHJ1ZTsKfTsKdmFyIEZSRUVaRSA9ICFfZGVyZXFfKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsKICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpOwp9KTsKdmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHsKICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7CiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSUQKICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzCiAgfSB9KTsKfTsKdmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkgewogIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXgKICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDsKICBpZiAoIWhhcyhpdCwgTUVUQSkpIHsKICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0CiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7CiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YQogICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7CiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YQogICAgc2V0TWV0YShpdCk7CiAgLy8gcmV0dXJuIG9iamVjdCBJRAogIH0gcmV0dXJuIGl0W01FVEFdLmk7Cn07CnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHsKICBpZiAoIWhhcyhpdCwgTUVUQSkpIHsKICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0CiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlOwogICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGEKICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7CiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YQogICAgc2V0TWV0YShpdCk7CiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHMKICB9IHJldHVybiBpdFtNRVRBXS53Owp9OwovLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmcKdmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7CiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7CiAgcmV0dXJuIGl0Owp9Owp2YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0gewogIEtFWTogTUVUQSwKICBORUVEOiBmYWxzZSwKICBmYXN0S2V5OiBmYXN0S2V5LAogIGdldFdlYWs6IGdldFdlYWssCiAgb25GcmVlemU6IG9uRnJlZXplCn07Cgp9LHsiLi9fZmFpbHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwiLi9faGFzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCIuL19pcy1vYmplY3QiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIi4vX29iamVjdC1kcCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwiLi9fdWlkIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Ci8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLikKdmFyIGdldEtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cycpOwp2YXIgZ09QUyA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BzJyk7CnZhciBwSUUgPSBfZGVyZXFfKCcuL19vYmplY3QtcGllJyk7CnZhciB0b09iamVjdCA9IF9kZXJlcV8oJy4vX3RvLW9iamVjdCcpOwp2YXIgSU9iamVjdCA9IF9kZXJlcV8oJy4vX2lvYmplY3QnKTsKdmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduOwoKLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpCm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgX2RlcmVxXygnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7CiAgdmFyIEEgPSB7fTsKICB2YXIgQiA9IHt9OwogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZgogIHZhciBTID0gU3ltYm9sKCk7CiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnOwogIEFbU10gPSA3OwogIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pOwogIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLOwp9KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzCiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpOwogIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDsKICB2YXIgaW5kZXggPSAxOwogIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mOwogIHZhciBpc0VudW0gPSBwSUUuZjsKICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7CiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTsKICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTsKICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDsKICAgIHZhciBqID0gMDsKICAgIHZhciBrZXk7CiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTsKICB9IHJldHVybiBUOwp9IDogJGFzc2lnbjsKCn0seyIuL19mYWlscyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanMiLCIuL19pb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwiLi9fb2JqZWN0LWdvcHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwiLi9fb2JqZWN0LWtleXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwiLi9fb2JqZWN0LXBpZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIi4vX3RvLW9iamVjdCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pCnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgZFBzID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwcycpOwp2YXIgZW51bUJ1Z0tleXMgPSBfZGVyZXFfKCcuL19lbnVtLWJ1Zy1rZXlzJyk7CnZhciBJRV9QUk9UTyA9IF9kZXJlcV8oJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTsKdmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9Owp2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7CgovLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlCnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkgewogIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnCiAgdmFyIGlmcmFtZSA9IF9kZXJlcV8oJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7CiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7CiAgdmFyIGx0ID0gJzwnOwogIHZhciBndCA9ICc+JzsKICB2YXIgaWZyYW1lRG9jdW1lbnQ7CiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CiAgX2RlcmVxXygnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7CiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybAogIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7CiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpOwogIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7CiAgaWZyYW1lRG9jdW1lbnQub3BlbigpOwogIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTsKICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpOwogIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GOwogIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dOwogIHJldHVybiBjcmVhdGVEaWN0KCk7Cn07Cgptb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHsKICB2YXIgcmVzdWx0OwogIGlmIChPICE9PSBudWxsKSB7CiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7CiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTsKICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsOwogICAgLy8gYWRkICJfX3Byb3RvX18iIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGwKICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPOwogIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7CiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpOwp9OwoKfSx7Ii4vX2FuLW9iamVjdCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwiLi9fZG9tLWNyZWF0ZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIi4vX2VudW0tYnVnLWtleXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCIuL19odG1sIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwiLi9fb2JqZWN0LWRwcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIi4vX3NoYXJlZC1rZXkiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgSUU4X0RPTV9ERUZJTkUgPSBfZGVyZXFfKCcuL19pZTgtZG9tLWRlZmluZScpOwp2YXIgdG9QcmltaXRpdmUgPSBfZGVyZXFfKCcuL190by1wcmltaXRpdmUnKTsKdmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5OwoKZXhwb3J0cy5mID0gX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHsKICBhbk9iamVjdChPKTsKICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7CiAgYW5PYmplY3QoQXR0cmlidXRlcyk7CiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkgewogICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpOwogIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfQogIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7CiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7CiAgcmV0dXJuIE87Cn07Cgp9LHsiLi9fYW4tb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCIuL19kZXNjcmlwdG9ycyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCIuL19pZTgtZG9tLWRlZmluZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCIuL190by1wcmltaXRpdmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBkUCA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpOwp2YXIgYW5PYmplY3QgPSBfZGVyZXFfKCcuL19hbi1vYmplY3QnKTsKdmFyIGdldEtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cycpOwoKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHsKICBhbk9iamVjdChPKTsKICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7CiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoOwogIHZhciBpID0gMDsKICB2YXIgUDsKICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTsKICByZXR1cm4gTzsKfTsKCn0seyIuL19hbi1vYmplY3QiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIi4vX2Rlc2NyaXB0b3JzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4vX29iamVjdC1kcCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwiLi9fb2JqZWN0LWtleXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBwSUUgPSBfZGVyZXFfKCcuL19vYmplY3QtcGllJyk7CnZhciBjcmVhdGVEZXNjID0gX2RlcmVxXygnLi9fcHJvcGVydHktZGVzYycpOwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgdG9QcmltaXRpdmUgPSBfZGVyZXFfKCcuL190by1wcmltaXRpdmUnKTsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgSUU4X0RPTV9ERUZJTkUgPSBfZGVyZXFfKCcuL19pZTgtZG9tLWRlZmluZScpOwp2YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CgpleHBvcnRzLmYgPSBfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7CiAgTyA9IHRvSU9iamVjdChPKTsKICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7CiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkgewogICAgcmV0dXJuIGdPUEQoTywgUCk7CiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9CiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pOwp9OwoKfSx7Ii4vX2Rlc2NyaXB0b3JzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4vX2hhcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwiLi9faWU4LWRvbS1kZWZpbmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwiLi9fb2JqZWN0LXBpZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIi4vX3Byb3BlcnR5LWRlc2MiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuL190by1pb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwiLi9fdG8tcHJpbWl0aXZlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3cKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKdmFyIGdPUE4gPSBfZGVyZXFfKCcuL19vYmplY3QtZ29wbicpLmY7CnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nOwoKdmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMKICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTsKCnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkgewogIHRyeSB7CiAgICByZXR1cm4gZ09QTihpdCk7CiAgfSBjYXRjaCAoZSkgewogICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7CiAgfQp9OwoKbW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHsKICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpOwp9OwoKfSx7Ii4vX29iamVjdC1nb3BuIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIi4vX3RvLWlvYmplY3QiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKQp2YXIgJGtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpOwp2YXIgaGlkZGVuS2V5cyA9IF9kZXJlcV8oJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTsKCmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykgewogIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTsKfTsKCn0seyIuL19lbnVtLWJ1Zy1rZXlzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwiLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pCnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIHRvT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8tb2JqZWN0Jyk7CnZhciBJRV9QUk9UTyA9IF9kZXJlcV8oJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTsKdmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTsKCm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7CiAgTyA9IHRvT2JqZWN0KE8pOwogIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107CiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHsKICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTsKICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsOwp9OwoKfSx7Ii4vX2hhcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwiLi9fc2hhcmVkLWtleSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIi4vX3RvLW9iamVjdCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKdmFyIGFycmF5SW5kZXhPZiA9IF9kZXJlcV8oJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpOwp2YXIgSUVfUFJPVE8gPSBfZGVyZXFfKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7CiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTsKICB2YXIgaSA9IDA7CiAgdmFyIHJlc3VsdCA9IFtdOwogIHZhciBrZXk7CiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTsKICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzCiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHsKICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn07Cgp9LHsiLi9fYXJyYXktaW5jbHVkZXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwiLi9faGFzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCIuL19zaGFyZWQta2V5IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwiLi9fdG8taW9iamVjdCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTykKdmFyICRrZXlzID0gX2RlcmVxXygnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTsKdmFyIGVudW1CdWdLZXlzID0gX2RlcmVxXygnLi9fZW51bS1idWcta2V5cycpOwoKbW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHsKICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpOwp9OwoKfSx7Ii4vX2VudW0tYnVnLWtleXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCIuL19vYmplY3Qta2V5cy1pbnRlcm5hbCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzCnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CnZhciBjb3JlID0gX2RlcmVxXygnLi9fY29yZScpOwp2YXIgZmFpbHMgPSBfZGVyZXFfKCcuL19mYWlscycpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHsKICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07CiAgdmFyIGV4cCA9IHt9OwogIGV4cFtLRVldID0gZXhlYyhmbik7CiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7Cn07Cgp9LHsiLi9fY29yZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIi4vX2V4cG9ydCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi9fZmFpbHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkgewogIHJldHVybiB7CiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLAogICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLAogICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksCiAgICB2YWx1ZTogdmFsdWUKICB9Owp9OwoKfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL19oaWRlJyk7Cgp9LHsiLi9faGlkZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuCi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovCnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vX2lzLW9iamVjdCcpOwp2YXIgYW5PYmplY3QgPSBfZGVyZXFfKCcuL19hbi1vYmplY3QnKTsKdmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7CiAgYW5PYmplY3QoTyk7CiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArICI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhIik7Cn07Cm1vZHVsZS5leHBvcnRzID0gewogIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7CiAgICAgIHRyeSB7CiAgICAgICAgc2V0ID0gX2RlcmVxXygnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgX2RlcmVxXygnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpOwogICAgICAgIHNldCh0ZXN0LCBbXSk7CiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9CiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykgewogICAgICAgIGNoZWNrKE8sIHByb3RvKTsKICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87CiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pOwogICAgICAgIHJldHVybiBPOwogICAgICB9OwogICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSwKICBjaGVjazogY2hlY2sKfTsKCn0seyIuL19hbi1vYmplY3QiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIi4vX2N0eCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwiLi9faXMtb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCIuL19vYmplY3QtZ29wZCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGRlZiA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmY7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIFRBRyA9IF9kZXJlcV8oJy4vX3drcycpKCd0b1N0cmluZ1RhZycpOwoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkgewogIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7Cn07Cgp9LHsiLi9faGFzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oYXMuanMiLCIuL19vYmplY3QtZHAiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4vX3drcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHNoYXJlZCA9IF9kZXJlcV8oJy4vX3NoYXJlZCcpKCdrZXlzJyk7CnZhciB1aWQgPSBfZGVyZXFfKCcuL191aWQnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7CiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTsKfTsKCn0seyIuL19zaGFyZWQiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIi4vX3VpZCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgY29yZSA9IF9kZXJlcV8oJy4vX2NvcmUnKTsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7CnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTsKCihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7CiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7Cn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHsKICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sCiAgbW9kZTogX2RlcmVxXygnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsCiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScKfSk7Cgp9LHsiLi9fY29yZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIi4vX2dsb2JhbCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwiLi9fbGlicmFyeSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHRvSW50ZWdlciA9IF9kZXJlcV8oJy4vX3RvLWludGVnZXInKTsKdmFyIGRlZmluZWQgPSBfZGVyZXFfKCcuL19kZWZpbmVkJyk7Ci8vIHRydWUgIC0+IFN0cmluZyNhdAovLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXQKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7CiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHsKICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpOwogICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTsKICAgIHZhciBsID0gcy5sZW5ndGg7CiAgICB2YXIgYSwgYjsKICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDsKICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7CiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZgogICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYQogICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDsKICB9Owp9OwoKfSx7Ii4vX2RlZmluZWQiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCIuL190by1pbnRlZ2VyIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB0b0ludGVnZXIgPSBfZGVyZXFfKCcuL190by1pbnRlZ2VyJyk7CnZhciBtYXggPSBNYXRoLm1heDsKdmFyIG1pbiA9IE1hdGgubWluOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7CiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpOwogIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpOwp9OwoKfSx7Ii4vX3RvLWludGVnZXIiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjEuNCBUb0ludGVnZXIKdmFyIGNlaWwgPSBNYXRoLmNlaWw7CnZhciBmbG9vciA9IE1hdGguZmxvb3I7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7Cn07Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5ncwp2YXIgSU9iamVjdCA9IF9kZXJlcV8oJy4vX2lvYmplY3QnKTsKdmFyIGRlZmluZWQgPSBfZGVyZXFfKCcuL19kZWZpbmVkJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpOwp9OwoKfSx7Ii4vX2RlZmluZWQiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanMiLCIuL19pb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjEuMTUgVG9MZW5ndGgKdmFyIHRvSW50ZWdlciA9IF9kZXJlcV8oJy4vX3RvLWludGVnZXInKTsKdmFyIG1pbiA9IE1hdGgubWluOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxCn07Cgp9LHsiLi9fdG8taW50ZWdlciI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KQp2YXIgZGVmaW5lZCA9IF9kZXJlcV8oJy4vX2RlZmluZWQnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTsKfTsKCn0seyIuL19kZWZpbmVkIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSkKdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7Ci8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlCi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7CiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDsKICB2YXIgZm4sIHZhbDsKICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDsKICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDsKICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7CiAgdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKTsKfTsKCn0seyIuL19pcy1vYmplY3QiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGlkID0gMDsKdmFyIHB4ID0gTWF0aC5yYW5kb20oKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7CiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTsKfTsKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgY29yZSA9IF9kZXJlcV8oJy4vX2NvcmUnKTsKdmFyIExJQlJBUlkgPSBfZGVyZXFfKCcuL19saWJyYXJ5Jyk7CnZhciB3a3NFeHQgPSBfZGVyZXFfKCcuL193a3MtZXh0Jyk7CnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmY7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHsKICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pOwogIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTsKfTsKCn0seyIuL19jb3JlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb3JlLmpzIiwiLi9fZ2xvYmFsIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCIuL19saWJyYXJ5IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwiLi9fb2JqZWN0LWRwIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCIuL193a3MtZXh0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cy5mID0gX2RlcmVxXygnLi9fd2tzJyk7Cgp9LHsiLi9fd2tzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBzdG9yZSA9IF9kZXJlcV8oJy4vX3NoYXJlZCcpKCd3a3MnKTsKdmFyIHVpZCA9IF9kZXJlcV8oJy4vX3VpZCcpOwp2YXIgU3ltYm9sID0gX2RlcmVxXygnLi9fZ2xvYmFsJykuU3ltYm9sOwp2YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJzsKCnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHsKICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID0KICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7Cn07CgokZXhwb3J0cy5zdG9yZSA9IHN0b3JlOwoKfSx7Ii4vX2dsb2JhbCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwiLi9fc2hhcmVkIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCIuL191aWQiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7CnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX2RlcmVxXygnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7CnZhciBzdGVwID0gX2RlcmVxXygnLi9faXRlci1zdGVwJyk7CnZhciBJdGVyYXRvcnMgPSBfZGVyZXFfKCcuL19pdGVyYXRvcnMnKTsKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKCi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKCkKLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKCkKLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKQovLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKCkKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHsKICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0CiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXgKICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZAovLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KCkKfSwgZnVuY3Rpb24gKCkgewogIHZhciBPID0gdGhpcy5fdDsKICB2YXIga2luZCA9IHRoaXMuX2s7CiAgdmFyIGluZGV4ID0gdGhpcy5faSsrOwogIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkgewogICAgdGhpcy5fdCA9IHVuZGVmaW5lZDsKICAgIHJldHVybiBzdGVwKDEpOwogIH0KICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTsKICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pOwogIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTsKfSwgJ3ZhbHVlcycpOwoKLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KQpJdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5OwoKYWRkVG9VbnNjb3BhYmxlcygna2V5cycpOwphZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTsKYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOwoKfSx7Ii4vX2FkZC10by11bnNjb3BhYmxlcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwiLi9faXRlci1kZWZpbmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwiLi9faXRlci1zdGVwIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCIuL19pdGVyYXRvcnMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIi4vX3RvLWlvYmplY3QiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKQp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwoKJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogX2RlcmVxXygnLi9fb2JqZWN0LWFzc2lnbicpIH0pOwoKfSx7Ii4vX2V4cG9ydCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi9fb2JqZWN0LWFzc2lnbiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7Ci8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKQokZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiBfZGVyZXFfKCcuL19vYmplY3QtY3JlYXRlJykgfSk7Cgp9LHsiLi9fZXhwb3J0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCIuL19vYmplY3QtY3JlYXRlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykKJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmYgfSk7Cgp9LHsiLi9fZGVzY3JpcHRvcnMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwiLi9fZXhwb3J0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCIuL19vYmplY3QtZHAiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTykKdmFyIHRvT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8tb2JqZWN0Jyk7CnZhciAkZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCcuL19vYmplY3QtZ3BvJyk7CgpfZGVyZXFfKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkgewogIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkgewogICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpOwogIH07Cn0pOwoKfSx7Ii4vX29iamVjdC1ncG8iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCIuL19vYmplY3Qtc2FwIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwiLi9fdG8tb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bykKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiBfZGVyZXFfKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7Cgp9LHsiLi9fZXhwb3J0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCIuL19zZXQtcHJvdG8iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmFyZ3VtZW50c1s0XVsiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19icm93c2VyLXJlc29sdmVAMS4xMS4yQGJyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKQp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwp2YXIgJGF0ID0gX2RlcmVxXygnLi9fc3RyaW5nLWF0JykodHJ1ZSk7CgovLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpCl9kZXJlcV8oJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7CiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldAogIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4Ci8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KCkKfSwgZnVuY3Rpb24gKCkgewogIHZhciBPID0gdGhpcy5fdDsKICB2YXIgaW5kZXggPSB0aGlzLl9pOwogIHZhciBwb2ludDsKICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTsKICBwb2ludCA9ICRhdChPLCBpbmRleCk7CiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7CiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9Owp9KTsKCn0seyIuL19pdGVyLWRlZmluZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCIuL19zdHJpbmctYXQiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwovLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltCnZhciBnbG9iYWwgPSBfZGVyZXFfKCcuL19nbG9iYWwnKTsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgREVTQ1JJUFRPUlMgPSBfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpOwp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwp2YXIgcmVkZWZpbmUgPSBfZGVyZXFfKCcuL19yZWRlZmluZScpOwp2YXIgTUVUQSA9IF9kZXJlcV8oJy4vX21ldGEnKS5LRVk7CnZhciAkZmFpbHMgPSBfZGVyZXFfKCcuL19mYWlscycpOwp2YXIgc2hhcmVkID0gX2RlcmVxXygnLi9fc2hhcmVkJyk7CnZhciBzZXRUb1N0cmluZ1RhZyA9IF9kZXJlcV8oJy4vX3NldC10by1zdHJpbmctdGFnJyk7CnZhciB1aWQgPSBfZGVyZXFfKCcuL191aWQnKTsKdmFyIHdrcyA9IF9kZXJlcV8oJy4vX3drcycpOwp2YXIgd2tzRXh0ID0gX2RlcmVxXygnLi9fd2tzLWV4dCcpOwp2YXIgd2tzRGVmaW5lID0gX2RlcmVxXygnLi9fd2tzLWRlZmluZScpOwp2YXIgZW51bUtleXMgPSBfZGVyZXFfKCcuL19lbnVtLWtleXMnKTsKdmFyIGlzQXJyYXkgPSBfZGVyZXFfKCcuL19pcy1hcnJheScpOwp2YXIgYW5PYmplY3QgPSBfZGVyZXFfKCcuL19hbi1vYmplY3QnKTsKdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7CnZhciB0b0lPYmplY3QgPSBfZGVyZXFfKCcuL190by1pb2JqZWN0Jyk7CnZhciB0b1ByaW1pdGl2ZSA9IF9kZXJlcV8oJy4vX3RvLXByaW1pdGl2ZScpOwp2YXIgY3JlYXRlRGVzYyA9IF9kZXJlcV8oJy4vX3Byb3BlcnR5LWRlc2MnKTsKdmFyIF9jcmVhdGUgPSBfZGVyZXFfKCcuL19vYmplY3QtY3JlYXRlJyk7CnZhciBnT1BORXh0ID0gX2RlcmVxXygnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7CnZhciAkR09QRCA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BkJyk7CnZhciAkRFAgPSBfZGVyZXFfKCcuL19vYmplY3QtZHAnKTsKdmFyICRrZXlzID0gX2RlcmVxXygnLi9fb2JqZWN0LWtleXMnKTsKdmFyIGdPUEQgPSAkR09QRC5mOwp2YXIgZFAgPSAkRFAuZjsKdmFyIGdPUE4gPSBnT1BORXh0LmY7CnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDsKdmFyICRKU09OID0gZ2xvYmFsLkpTT047CnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5Owp2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7CnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTsKdmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTsKdmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOwp2YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpOwp2YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpOwp2YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7CnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdOwp2YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7CnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7Ci8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3Mwp2YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDsKCi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4Nwp2YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywgewogICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfQogIH0pKS5hICE9IDc7Cn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHsKICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTsKICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTsKICBkUChpdCwga2V5LCBEKTsKICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTsKfSA6IGRQOwoKdmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7CiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTsKICBzeW0uX2sgPSB0YWc7CiAgcmV0dXJuIHN5bTsKfTsKCnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnOwp9IDogZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDsKfTsKCnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7CiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTsKICBhbk9iamVjdChpdCk7CiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTsKICBhbk9iamVjdChEKTsKICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHsKICAgIGlmICghRC5lbnVtZXJhYmxlKSB7CiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7CiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7CiAgICB9IGVsc2UgewogICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7CiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7CiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpOwogIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpOwp9Owp2YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7CiAgYW5PYmplY3QoaXQpOwogIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7CiAgdmFyIGkgPSAwOwogIHZhciBsID0ga2V5cy5sZW5ndGg7CiAgdmFyIGtleTsKICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pOwogIHJldHVybiBpdDsKfTsKdmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHsKICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7Cn07CnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHsKICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpOwogIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlOwogIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTsKfTsKdmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkgewogIGl0ID0gdG9JT2JqZWN0KGl0KTsKICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpOwogIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjsKICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7CiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTsKICByZXR1cm4gRDsKfTsKdmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkgewogIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7CiAgdmFyIHJlc3VsdCA9IFtdOwogIHZhciBpID0gMDsKICB2YXIga2V5OwogIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7CiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpOwogIH0gcmV0dXJuIHJlc3VsdDsKfTsKdmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHsKICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87CiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpOwogIHZhciByZXN1bHQgPSBbXTsKICB2YXIgaSA9IDA7CiAgdmFyIGtleTsKICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgewogICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTsKICB9IHJldHVybiByZXN1bHQ7Cn07CgovLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSkKaWYgKCFVU0VfTkFUSVZFKSB7CiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHsKICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7CiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsKICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpOwogICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTsKICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTsKICAgIH07CiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7CiAgICByZXR1cm4gd3JhcCh0YWcpOwogIH07CiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHsKICAgIHJldHVybiB0aGlzLl9rOwogIH0pOwoKICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjsKICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTsKICBfZGVyZXFfKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lczsKICBfZGVyZXFfKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTsKICBfZGVyZXFfKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzOwoKICBpZiAoREVTQ1JJUFRPUlMgJiYgIV9kZXJlcV8oJy4vX2xpYnJhcnknKSkgewogICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7CiAgfQoKICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpOwogIH07Cn0KCiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pOwoKZm9yICh2YXIgZXM2U3ltYm9scyA9ICgKICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNAogICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcycKKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTsKCmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7CgokZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywgewogIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KQogICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7CiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpCiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XQogICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7CiAgfSwKICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSkKICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHsKICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpOwogICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5OwogIH0sCiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sCiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9Cn0pOwoKJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHsKICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pCiAgY3JlYXRlOiAkY3JlYXRlLAogIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKQogIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksCiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykKICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcywKICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApCiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLAogIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pCiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsCiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKQogIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9scwp9KTsKCi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKQokSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkgewogIHZhciBTID0gJFN5bWJvbCgpOwogIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9CiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsCiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHMKICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7Cn0pKSwgJ0pTT04nLCB7CiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsKICAgIHZhciBhcmdzID0gW2l0XTsKICAgIHZhciBpID0gMTsKICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyOwogICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pOwogICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdOwogICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZAogICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgewogICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpOwogICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlOwogICAgfTsKICAgIGFyZ3NbMV0gPSByZXBsYWNlcjsKICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTsKICB9Cn0pOwoKLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KQokU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCBfZGVyZXFfKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTsKLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXQpzZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7Ci8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ10Kc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTsKLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ10Kc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7Cgp9LHsiLi9fYW4tb2JqZWN0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCIuL19kZXNjcmlwdG9ycyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCIuL19lbnVtLWtleXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIi4vX2V4cG9ydCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi9fZmFpbHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwiLi9fZ2xvYmFsIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCIuL19oYXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIi4vX2hpZGUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCIuL19pcy1hcnJheSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCIuL19pcy1vYmplY3QiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIi4vX2xpYnJhcnkiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCIuL19tZXRhIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwiLi9fb2JqZWN0LWNyZWF0ZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIi4vX29iamVjdC1kcCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwiLi9fb2JqZWN0LWdvcGQiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwiLi9fb2JqZWN0LWdvcG4iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwiLi9fb2JqZWN0LWdvcG4tZXh0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCIuL19vYmplY3QtZ29wcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCIuL19vYmplY3Qta2V5cyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCIuL19vYmplY3QtcGllIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwiLi9fcHJvcGVydHktZGVzYyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIi4vX3JlZGVmaW5lIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIi4vX3NldC10by1zdHJpbmctdGFnIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIi4vX3NoYXJlZCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzIiwiLi9fdG8taW9iamVjdCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi4vX3RvLXByaW1pdGl2ZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwiLi9fdWlkIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCIuL193a3MiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIi4vX3drcy1kZWZpbmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMiLCIuL193a3MtZXh0IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTsKCn0seyIuL193a3MtZGVmaW5lIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpOwoKfSx7Ii4vX3drcy1kZWZpbmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS1qc0AyLjUuN0Bjb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7CnZhciBnbG9iYWwgPSBfZGVyZXFfKCcuL19nbG9iYWwnKTsKdmFyIGhpZGUgPSBfZGVyZXFfKCcuL19oaWRlJyk7CnZhciBJdGVyYXRvcnMgPSBfZGVyZXFfKCcuL19pdGVyYXRvcnMnKTsKdmFyIFRPX1NUUklOR19UQUcgPSBfZGVyZXFfKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTsKCnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArCiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArCiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArCiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgKwogICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7Cgpmb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykgewogIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldOwogIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdOwogIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7CiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7CiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5Owp9Cgp9LHsiLi9fZ2xvYmFsIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCIuL19oaWRlIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwiLi9faXRlcmF0b3JzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCIuL193a3MiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtanNAMi41LjdAY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIi4vZXM2LmFycmF5Lml0ZXJhdG9yIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLWpzQDIuNS43QGNvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLXV0aWwtaXNAMS4wLjJAY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoQnVmZmVyKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgCi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLgoKZnVuY3Rpb24gaXNBcnJheShhcmcpIHsKICBpZiAoQXJyYXkuaXNBcnJheSkgewogICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTsKICB9CiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7Cn0KZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTsKCmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nOwp9CmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuOwoKZnVuY3Rpb24gaXNOdWxsKGFyZykgewogIHJldHVybiBhcmcgPT09IG51bGw7Cn0KZXhwb3J0cy5pc051bGwgPSBpc051bGw7CgpmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09IG51bGw7Cn0KZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkOwoKZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInOwp9CmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjsKCmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJzsKfQpleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7CgpmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7Cn0KZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sOwoKZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwOwp9CmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDsKCmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7CiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7Cn0KZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwOwoKZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDsKfQpleHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7CgpmdW5jdGlvbiBpc0RhdGUoZCkgewogIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nOwp9CmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlOwoKZnVuY3Rpb24gaXNFcnJvcihlKSB7CiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpOwp9CmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7CgpmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nOwp9CmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247CgpmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHsKICByZXR1cm4gYXJnID09PSBudWxsIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbAogICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJzsKfQpleHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7CgpleHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyOwoKZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykgewogIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7Cn0KCn0pLmNhbGwodGhpcyx7ImlzQnVmZmVyIjpfZGVyZXFfKCIuLi8uLi8uLi8uLi9faXMtYnVmZmVyQDEuMS42QGlzLWJ1ZmZlci9pbmRleC5qcyIpfSkKCn0seyIuLi8uLi8uLi8uLi9faXMtYnVmZmVyQDEuMS42QGlzLWJ1ZmZlci9pbmRleC5qcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svX2lzLWJ1ZmZlckAxLjEuNkBpcy1idWZmZXIvaW5kZXguanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fZW5kLW9mLXN0cmVhbUAxLjQuMUBlbmQtb2Ytc3RyZWFtL2luZGV4LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBvbmNlID0gX2RlcmVxXygnb25jZScpOwoKdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9OwoKdmFyIGlzUmVxdWVzdCA9IGZ1bmN0aW9uKHN0cmVhbSkgewoJcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJzsKfTsKCnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkgewoJcmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gMwp9OwoKdmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHsKCWlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpOwoJaWYgKCFvcHRzKSBvcHRzID0ge307CgoJY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwoKCXZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKCXZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKCXZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgKG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZSk7Cgl2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpOwoKCXZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkgewoJCWlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpOwoJfTsKCgl2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHsKCQl3cml0YWJsZSA9IGZhbHNlOwoJCWlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTsKCX07CgoJdmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7CgkJcmVhZGFibGUgPSBmYWxzZTsKCQlpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7Cgl9OwoKCXZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkgewoJCWNhbGxiYWNrLmNhbGwoc3RyZWFtLCBleGl0Q29kZSA/IG5ldyBFcnJvcignZXhpdGVkIHdpdGggZXJyb3IgY29kZTogJyArIGV4aXRDb2RlKSA6IG51bGwpOwoJfTsKCgl2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikgewoJCWNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpOwoJfTsKCgl2YXIgb25jbG9zZSA9IGZ1bmN0aW9uKCkgewoJCWlmIChyZWFkYWJsZSAmJiAhKHJzICYmIHJzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTsKCQlpZiAod3JpdGFibGUgJiYgISh3cyAmJiB3cy5lbmRlZCkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7Cgl9OwoKCXZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHsKCQlzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7Cgl9OwoKCWlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgewoJCXN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7CgkJc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpOwoJCWlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTsKCQllbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7Cgl9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3cykgeyAvLyBsZWdhY3kgc3RyZWFtcwoJCXN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpOwoJCXN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7Cgl9CgoJaWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7CgoJc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7CglzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCWlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpOwoJc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpOwoKCXJldHVybiBmdW5jdGlvbigpIHsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpOwoJCWlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbmV4aXQpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7Cgl9Owp9OwoKbW9kdWxlLmV4cG9ydHMgPSBlb3M7Cgp9LHsib25jZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fb25jZUAxLjQuMEBvbmNlL29uY2UuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fZXZlbnRzQDIuMS4wQGV2ZW50cy9ldmVudHMuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKdmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGwKdmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGwKdmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbAoKZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkgewogIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkgewogICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwOwogIH0KCiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDsKfQptb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjsKCi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueApFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyOwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkOwpFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7CgovLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmUKLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy4KdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDsKCnZhciBoYXNEZWZpbmVQcm9wZXJ0eTsKdHJ5IHsKICB2YXIgbyA9IHt9OwogIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7CiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7Cn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH0KaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7CiAgICB9LAogICAgc2V0OiBmdW5jdGlvbihhcmcpIHsKICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3IKICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS4KICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpCiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImRlZmF1bHRNYXhMaXN0ZW5lcnMiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTsKICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZzsKICAgIH0KICB9KTsKfSBlbHNlIHsKICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7Cn0KCi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93cwovLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC4KRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikgewogIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpCiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibiIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpOwogIHRoaXMuX21heExpc3RlbmVycyA9IG47CiAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHsKICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpCiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7CiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVyczsKfQoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7CiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7Cn07CgovLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50Ci8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2YKLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmUKLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZQovLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuCmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHsKICBpZiAoaXNGbikKICAgIGhhbmRsZXIuY2FsbChzZWxmKTsKICBlbHNlIHsKICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDsKICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKQogICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTsKICB9Cn0KZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7CiAgaWYgKGlzRm4pCiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7CiAgZWxzZSB7CiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7CiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkKICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7CiAgfQp9CmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikgewogIGlmIChpc0ZuKQogICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpOwogIGVsc2UgewogICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoOwogICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpCiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpOwogIH0KfQpmdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykgewogIGlmIChpc0ZuKQogICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpOwogIGVsc2UgewogICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoOwogICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpCiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpOwogIH0KfQoKZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykgewogIGlmIChpc0ZuKQogICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTsKICBlbHNlIHsKICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDsKICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKQogICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7CiAgfQp9CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHsKICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzOwogIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpOwoKICBldmVudHMgPSB0aGlzLl9ldmVudHM7CiAgaWYgKGV2ZW50cykKICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7CiAgZWxzZSBpZiAoIWRvRXJyb3IpCiAgICByZXR1cm4gZmFsc2U7CgogIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy4KICBpZiAoZG9FcnJvcikgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKQogICAgICBlciA9IGFyZ3VtZW50c1sxXTsKICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudAogICAgfSBlbHNlIHsKICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlcgogICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgImVycm9yIiBldmVudC4gKCcgKyBlciArICcpJyk7CiAgICAgIGVyci5jb250ZXh0ID0gZXI7CiAgICAgIHRocm93IGVycjsKICAgIH0KICAgIHJldHVybiBmYWxzZTsKICB9CgogIGhhbmRsZXIgPSBldmVudHNbdHlwZV07CgogIGlmICghaGFuZGxlcikKICAgIHJldHVybiBmYWxzZTsKCiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJzsKICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOwogIHN3aXRjaCAobGVuKSB7CiAgICAgIC8vIGZhc3QgY2FzZXMKICAgIGNhc2UgMToKICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAyOgogICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAzOgogICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTsKICAgICAgYnJlYWs7CiAgICBjYXNlIDQ6CiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTsKICAgICAgYnJlYWs7CiAgICAgIC8vIHNsb3dlcgogICAgZGVmYXVsdDoKICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsKICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKQogICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldOwogICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTsKICB9CgogIHJldHVybiB0cnVlOwp9OwoKZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHsKICB2YXIgbTsKICB2YXIgZXZlbnRzOwogIHZhciBleGlzdGluZzsKCiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0ZW5lciIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgogIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzOwogIGlmICghZXZlbnRzKSB7CiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTsKICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwOwogIH0gZWxzZSB7CiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSAibmV3TGlzdGVuZXIiISBCZWZvcmUKICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0ICJuZXdMaXN0ZW5lciIuCiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7CiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsCiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpOwoKICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZQogICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0CiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzOwogICAgfQogICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07CiAgfQoKICBpZiAoIWV4aXN0aW5nKSB7CiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC4KICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7CiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7CiAgfSBlbHNlIHsKICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHsKICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuCiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0KICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdOwogICAgfSBlbHNlIHsKICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLgogICAgICBpZiAocHJlcGVuZCkgewogICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpOwogICAgICB9IGVsc2UgewogICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpOwogICAgICB9CiAgICB9CgogICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWsKICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7CiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7CiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHsKICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlOwogICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgKwogICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICInICsgU3RyaW5nKHR5cGUpICsgJyIgbGlzdGVuZXJzICcgKwogICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKwogICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7CiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7CiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0OwogICAgICAgIHcudHlwZSA9IHR5cGU7CiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDsKICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2FybikgewogICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gdGFyZ2V0Owp9CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0KICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTsKICAgIH07CgpmdW5jdGlvbiBvbmNlV3JhcHBlcigpIHsKICBpZiAoIXRoaXMuZmlyZWQpIHsKICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pOwogICAgdGhpcy5maXJlZCA9IHRydWU7CiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHsKICAgICAgY2FzZSAwOgogICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpOwogICAgICBjYXNlIDE6CiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTsKICAgICAgY2FzZSAyOgogICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTsKICAgICAgY2FzZSAzOgogICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLAogICAgICAgICAgICBhcmd1bWVudHNbMl0pOwogICAgICBkZWZhdWx0OgogICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkKICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07CiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikgewogIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9OwogIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7CiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyOwogIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7CiAgcmV0dXJuIHdyYXBwZWQ7Cn0KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHsKICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKQogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3RlbmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpOwogIHJldHVybiB0aGlzOwp9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0KICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdGVuZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpOwogICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC4KRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9CiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjsKCiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpCiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3RlbmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKCiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKICAgICAgaWYgKCFldmVudHMpCiAgICAgICAgcmV0dXJuIHRoaXM7CgogICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdOwogICAgICBpZiAoIWxpc3QpCiAgICAgICAgcmV0dXJuIHRoaXM7CgogICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHsKICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkKICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTsKICAgICAgICBlbHNlIHsKICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07CiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKQogICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgcG9zaXRpb24gPSAtMTsKCiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7CiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyOwogICAgICAgICAgICBwb3NpdGlvbiA9IGk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkKICAgICAgICAgIHJldHVybiB0aGlzOwoKICAgICAgICBpZiAocG9zaXRpb24gPT09IDApCiAgICAgICAgICBsaXN0LnNoaWZ0KCk7CiAgICAgICAgZWxzZQogICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTsKCiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKQogICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTsKCiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikKICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPQogICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHsKICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpOwoKICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzOwogICAgICBpZiAoIWV2ZW50cykKICAgICAgICByZXR1cm4gdGhpczsKCiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXQKICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7CiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkKICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQoKICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzCiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7CiAgICAgICAgdmFyIGtleTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkgewogICAgICAgICAga2V5ID0ga2V5c1tpXTsKICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlOwogICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTsKICAgICAgICB9CiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7CiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQoKICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdOwoKICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7CiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7CiAgICAgICAgLy8gTElGTyBvcmRlcgogICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkgewogIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50czsKCiAgaWYgKCFldmVudHMpCiAgICByZXR1cm4gW107CgogIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdOwogIGlmICghZXZsaXN0ZW5lcikKICAgIHJldHVybiBbXTsKCiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKQogICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdOwoKICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7Cn0KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHsKICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTsKfTsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHsKICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7Cn07CgpFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHsKICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykgewogICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTsKICB9IGVsc2UgewogICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTsKICB9Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50OwpmdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHsKICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzOwoKICBpZiAoZXZlbnRzKSB7CiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTsKCiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHsKICAgICAgcmV0dXJuIDE7CiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHsKICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoOwogICAgfQogIH0KCiAgcmV0dXJuIDA7Cn0KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7CiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107Cn07CgovLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuCmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkgewogIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkKICAgIGxpc3RbaV0gPSBsaXN0W2tdOwogIGxpc3QucG9wKCk7Cn0KCmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7CiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpCiAgICBjb3B5W2ldID0gYXJyW2ldOwogIHJldHVybiBjb3B5Owp9CgpmdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7CiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsKICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkgewogICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTsKICB9CiAgcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHsKICB2YXIgRiA9IGZ1bmN0aW9uKCkge307CiAgRi5wcm90b3R5cGUgPSBwcm90bzsKICByZXR1cm4gbmV3IEY7Cn0KZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikgewogIHZhciBrZXlzID0gW107CiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkgewogICAga2V5cy5wdXNoKGspOwogIH0KICByZXR1cm4gazsKfQpmdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7CiAgdmFyIGZuID0gdGhpczsKICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7CiAgfTsKfQoKfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9faWVlZTc1NEAxLjEuMTFAaWVlZTc1NC9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogIHZhciBlLCBtCiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMQogIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxCiAgdmFyIGVCaWFzID0gZU1heCA+PiAxCiAgdmFyIG5CaXRzID0gLTcKICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwCiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxCiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV0KCiAgaSArPSBkCgogIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpCiAgcyA+Pj0gKC1uQml0cykKICBuQml0cyArPSBlTGVuCiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKQogIGUgPj49ICgtbkJpdHMpCiAgbkJpdHMgKz0gbUxlbgogIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge30KCiAgaWYgKGUgPT09IDApIHsKICAgIGUgPSAxIC0gZUJpYXMKICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHsKICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KQogIH0gZWxzZSB7CiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pCiAgICBlID0gZSAtIGVCaWFzCiAgfQogIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pCn0KCmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICB2YXIgZSwgbSwgYwogIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDEKICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMQogIHZhciBlQmlhcyA9IGVNYXggPj4gMQogIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCkKICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpCiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xCiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDAKCiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSkKCiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHsKICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMAogICAgZSA9IGVNYXgKICB9IGVsc2UgewogICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpCiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7CiAgICAgIGUtLQogICAgICBjICo9IDIKICAgIH0KICAgIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICB2YWx1ZSArPSBydCAvIGMKICAgIH0gZWxzZSB7CiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKQogICAgfQogICAgaWYgKHZhbHVlICogYyA+PSAyKSB7CiAgICAgIGUrKwogICAgICBjIC89IDIKICAgIH0KCiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHsKICAgICAgbSA9IDAKICAgICAgZSA9IGVNYXgKICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbikKICAgICAgZSA9IGUgKyBlQmlhcwogICAgfSBlbHNlIHsKICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pCiAgICAgIGUgPSAwCiAgICB9CiAgfQoKICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fQoKICBlID0gKGUgPDwgbUxlbikgfCBtCiAgZUxlbiArPSBtTGVuCiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fQoKICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjgKfQoKfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9faW5oZXJpdHNAMi4wLjFAaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewppZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHsKICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZQogIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7CiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcgogICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHsKICAgICAgY29uc3RydWN0b3I6IHsKICAgICAgICB2YWx1ZTogY3RvciwKICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgICBjb25maWd1cmFibGU6IHRydWUKICAgICAgfQogICAgfSk7CiAgfTsKfSBlbHNlIHsKICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2VycwogIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7CiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcgogICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge30KICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGUKICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCkKICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcgogIH0KfQoKfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9faW5oZXJpdHNAMi4wLjNAaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewphcmd1bWVudHNbNF1bIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9faW5oZXJpdHNAMi4wLjFAaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKQp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19pc2FycmF5QDEuMC4wQGlzYXJyYXkvaW5kZXguanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7Cgptb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikgewogIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJzsKfTsKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2pzb24tcnBjLWVuZ2luZUAzLjcuM0Bqc29uLXJwYy1lbmdpbmUvc3JjL2dldFVuaXF1ZUlkLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCi8vIHVpbnQzMiAodHdvJ3MgY29tcGxlbWVudCkgbWF4Ci8vIG1vcmUgY29uc2VydmF0aXZlIHRoYW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIKdmFyIE1BWCA9IDQyOTQ5NjcyOTU7CnZhciBpZENvdW50ZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVgpOwoKbW9kdWxlLmV4cG9ydHMgPSBnZXRVbmlxdWVJZDsKCmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkgewogIGlkQ291bnRlciA9IChpZENvdW50ZXIgKyAxKSAlIE1BWDsKICByZXR1cm4gaWRDb3VudGVyOwp9Cgp9LHt9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19qc29uLXJwYy1lbmdpbmVAMy43LjNAanNvbi1ycGMtZW5naW5lL3NyYy9pZFJlbWFwTWlkZGxld2FyZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Cgp2YXIgZ2V0VW5pcXVlSWQgPSBfZGVyZXFfKCcuL2dldFVuaXF1ZUlkJyk7Cgptb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlOwoKZnVuY3Rpb24gY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUoKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCwgZW5kKSB7CiAgICB2YXIgb3JpZ2luYWxJZCA9IHJlcS5pZDsKICAgIHZhciBuZXdJZCA9IGdldFVuaXF1ZUlkKCk7CiAgICByZXEuaWQgPSBuZXdJZDsKICAgIHJlcy5pZCA9IG5ld0lkOwogICAgbmV4dChmdW5jdGlvbiAoZG9uZSkgewogICAgICByZXEuaWQgPSBvcmlnaW5hbElkOwogICAgICByZXMuaWQgPSBvcmlnaW5hbElkOwogICAgICBkb25lKCk7CiAgICB9KTsKICB9Owp9Cgp9LHsiLi9nZXRVbmlxdWVJZCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fanNvbi1ycGMtZW5naW5lQDMuNy4zQGpzb24tcnBjLWVuZ2luZS9zcmMvZ2V0VW5pcXVlSWQuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fanNvbi1ycGMtZW5naW5lQDMuNy4zQGpzb24tcnBjLWVuZ2luZS9zcmMvaW5kZXguanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwoKdmFyIF9zdHJpbmdpZnkgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnknKTsKCnZhciBfc3RyaW5naWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZ2lmeSk7Cgp2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpOwoKdmFyIF9jcmVhdGVDbGFzczIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTsKCnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9Cgp2YXIgYXN5bmMgPSBfZGVyZXFfKCdhc3luYycpOwp2YXIgY2xvbmUgPSBfZGVyZXFfKCdjbG9uZScpOwoKdmFyIFJwY0VuZ2luZSA9IGZ1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBScGNFbmdpbmUoKSB7CiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBScGNFbmdpbmUpOwoKICAgIHRoaXMuX21pZGRsZXdhcmUgPSBbXTsKICB9CgogIC8vCiAgLy8gUHVibGljCiAgLy8KCiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoUnBjRW5naW5lLCBbewogICAga2V5OiAncHVzaCcsCiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChtaWRkbGV3YXJlKSB7CiAgICAgIHRoaXMuX21pZGRsZXdhcmUucHVzaChtaWRkbGV3YXJlKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICdoYW5kbGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZShyZXEsIGNiKSB7CiAgICAgIC8vIGJhdGNoIHJlcXVlc3Qgc3VwcG9ydAogICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEpKSB7CiAgICAgICAgYXN5bmMubWFwKHJlcSwgdGhpcy5faGFuZGxlLmJpbmQodGhpcyksIGNiKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLl9oYW5kbGUocmVxLCBjYik7CiAgICAgIH0KICAgIH0KCiAgICAvLwogICAgLy8gUHJpdmF0ZQogICAgLy8KCiAgfSwgewogICAga2V5OiAnX2hhbmRsZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZShfcmVxLCBjYikgewogICAgICAvLyBjbG9uZSByZXF1ZXN0IG9iamVjdAogICAgICB2YXIgcmVxID0gY2xvbmUoX3JlcSk7CiAgICAgIC8vIGNyZWF0ZSByZXNwb25zZSBvYmoKICAgICAgdmFyIHJlcyA9IHsKICAgICAgICBpZDogcmVxLmlkLAogICAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjCiAgICAgICAgLy8gcHJvY2VzcyBhbGwgbWlkZGxld2FyZQogICAgICB9O3RoaXMuX3J1bk1pZGRsZXdhcmUocmVxLCByZXMsIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICAvLyByZXR1cm4gcmVzcG9uc2UKICAgICAgICBjYihlcnIsIHJlcyk7CiAgICAgIH0pOwogICAgfQogIH0sIHsKICAgIGtleTogJ19ydW5NaWRkbGV3YXJlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBfcnVuTWlkZGxld2FyZShyZXEsIHJlcywgb25Eb25lKSB7CiAgICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgICAvLyBmbG93CiAgICAgIGFzeW5jLndhdGVyZmFsbChbZnVuY3Rpb24gKGNiKSB7CiAgICAgICAgcmV0dXJuIF90aGlzLl9ydW5NaWRkbGV3YXJlRG93bihyZXEsIHJlcywgY2IpOwogICAgICB9LCBjaGVja0ZvckNvbXBsZXRpb24sIGZ1bmN0aW9uIChyZXR1cm5IYW5kbGVycywgY2IpIHsKICAgICAgICByZXR1cm4gX3RoaXMuX3J1blJldHVybkhhbmRsZXJzVXAocmV0dXJuSGFuZGxlcnMsIGNiKTsKICAgICAgfV0sIG9uRG9uZSk7CgogICAgICBmdW5jdGlvbiBjaGVja0ZvckNvbXBsZXRpb24oX3JlZiwgY2IpIHsKICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IF9yZWYuaXNDb21wbGV0ZSwKICAgICAgICAgICAgcmV0dXJuSGFuZGxlcnMgPSBfcmVmLnJldHVybkhhbmRsZXJzOwoKICAgICAgICAvLyBmYWlsIGlmIG5vdCBjb21wbGV0ZWQKICAgICAgICBpZiAoISgncmVzdWx0JyBpbiByZXMpICYmICEoJ2Vycm9yJyBpbiByZXMpKSB7CiAgICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkocmVxLCBudWxsLCAyKTsKICAgICAgICAgIHZhciBtZXNzYWdlID0gJ0pzb25ScGNFbmdpbmUgLSByZXNwb25zZSBoYXMgbm8gZXJyb3Igb3IgcmVzdWx0IGZvciByZXF1ZXN0OlxuJyArIHJlcXVlc3RCb2R5OwogICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihtZXNzYWdlKSk7CiAgICAgICAgfQogICAgICAgIGlmICghaXNDb21wbGV0ZSkgewogICAgICAgICAgdmFyIF9yZXF1ZXN0Qm9keSA9ICgwLCBfc3RyaW5naWZ5Mi5kZWZhdWx0KShyZXEsIG51bGwsIDIpOwogICAgICAgICAgdmFyIF9tZXNzYWdlID0gJ0pzb25ScGNFbmdpbmUgLSBub3RoaW5nIGVuZGVkIHJlcXVlc3Q6XG4nICsgX3JlcXVlc3RCb2R5OwogICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihfbWVzc2FnZSkpOwogICAgICAgIH0KICAgICAgICAvLyBjb250aW51ZQogICAgICAgIHJldHVybiBjYihudWxsLCByZXR1cm5IYW5kbGVycyk7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHJ1blJldHVybkhhbmRsZXJzKHJldHVybkhhbmRsZXJzLCBjYikgewogICAgICAgIGFzeW5jLmVhY2hTZXJpZXMocmV0dXJuSGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBuZXh0KSB7CiAgICAgICAgICByZXR1cm4gaGFuZGxlcihuZXh0KTsKICAgICAgICB9LCBvbkRvbmUpOwogICAgICB9CiAgICB9CgogICAgLy8gd2Fsa3MgZG93biBzdGFjayBvZiBtaWRkbGV3YXJlCgogIH0sIHsKICAgIGtleTogJ19ydW5NaWRkbGV3YXJlRG93bicsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1bk1pZGRsZXdhcmVEb3duKHJlcSwgcmVzLCBvbkRvbmUpIHsKICAgICAgLy8gZm9yIGNsaW1iaW5nIGJhY2sgdXAgdGhlIHN0YWNrCiAgICAgIHZhciBhbGxSZXR1cm5IYW5kbGVycyA9IFtdOwogICAgICAvLyBmbGFnIGZvciBzdGFjayByZXR1cm4KICAgICAgdmFyIGlzQ29tcGxldGUgPSBmYWxzZTsKCiAgICAgIC8vIGRvd24gc3RhY2sgb2YgbWlkZGxld2FyZSwgY2FsbCBhbmQgY29sbGVjdCBvcHRpb25hbCBhbGxSZXR1cm5IYW5kbGVycwogICAgICBhc3luYy5tYXBTZXJpZXModGhpcy5fbWlkZGxld2FyZSwgZWFjaE1pZGRsZXdhcmUsIGNvbXBsZXRlUmVxdWVzdCk7CgogICAgICAvLyBydW5zIGFuIGluZGl2aWR1YWwgbWlkZGxld2FyZQogICAgICBmdW5jdGlvbiBlYWNoTWlkZGxld2FyZShtaWRkbGV3YXJlLCBjYikgewogICAgICAgIC8vIHNraXAgbWlkZGxld2FyZSBpZiBjb21wbGV0ZWQKICAgICAgICBpZiAoaXNDb21wbGV0ZSkgcmV0dXJuIGNiKCk7CiAgICAgICAgLy8gcnVuIGluZGl2aWR1YWwgbWlkZGxld2FyZQogICAgICAgIG1pZGRsZXdhcmUocmVxLCByZXMsIG5leHQsIGVuZCk7CgogICAgICAgIGZ1bmN0aW9uIG5leHQocmV0dXJuSGFuZGxlcikgewogICAgICAgICAgLy8gYWRkIHJldHVybiBoYW5kbGVyCiAgICAgICAgICBhbGxSZXR1cm5IYW5kbGVycy5wdXNoKHJldHVybkhhbmRsZXIpOwogICAgICAgICAgY2IoKTsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZW5kKGVycikgewogICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7CiAgICAgICAgICAvLyBtYXJrIGFzIGNvbXBsZXRlZAogICAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7CiAgICAgICAgICBjYigpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgLy8gcmV0dXJucywgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBpdCBlbmRlZAogICAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoZXJyKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgLy8gcHJlcGFyZSBlcnJvciBtZXNzYWdlCiAgICAgICAgICByZXMuZXJyb3IgPSB7CiAgICAgICAgICAgIGNvZGU6IGVyci5jb2RlIHx8IC0zMjYwMywKICAgICAgICAgICAgbWVzc2FnZTogZXJyLnN0YWNrCiAgICAgICAgICAgIC8vIHJldHVybiBlcnJvci1maXJzdCBhbmQgcmVzIHdpdGggZXJyCiAgICAgICAgICB9O3JldHVybiBvbkRvbmUoZXJyLCByZXMpOwogICAgICAgIH0KICAgICAgICB2YXIgcmV0dXJuSGFuZGxlcnMgPSBhbGxSZXR1cm5IYW5kbGVycy5maWx0ZXIoQm9vbGVhbikucmV2ZXJzZSgpOwogICAgICAgIG9uRG9uZShudWxsLCB7IGlzQ29tcGxldGU6IGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzOiByZXR1cm5IYW5kbGVycyB9KTsKICAgICAgfQogICAgfQoKICAgIC8vIGNsaW1icyB0aGUgc3RhY2sgY2FsbGluZyByZXR1cm4gaGFuZGxlcnMKCiAgfSwgewogICAga2V5OiAnX3J1blJldHVybkhhbmRsZXJzVXAnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW5SZXR1cm5IYW5kbGVyc1VwKHJldHVybkhhbmRsZXJzLCBjYikgewogICAgICBhc3luYy5lYWNoU2VyaWVzKHJldHVybkhhbmRsZXJzLCBmdW5jdGlvbiAoaGFuZGxlciwgbmV4dCkgewogICAgICAgIHJldHVybiBoYW5kbGVyKG5leHQpOwogICAgICB9LCBjYik7CiAgICB9CiAgfV0pOwogIHJldHVybiBScGNFbmdpbmU7Cn0oKTsKCm1vZHVsZS5leHBvcnRzID0gUnBjRW5naW5lOwoKfSx7ImFzeW5jIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19hc3luY0AyLjYuMUBhc3luYy9kaXN0L2FzeW5jLmpzIiwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5IjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvanNvbi9zdHJpbmdpZnkuanMiLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2siOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwiY2xvbmUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2Nsb25lQDIuMS4xQGNsb25lL2Nsb25lLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2pzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtQDEuMC4xQGpzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtL2luZGV4LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmNvbnN0IER1cGxleFN0cmVhbSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleAoKbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlCgpmdW5jdGlvbiBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCkgewogIGNvbnN0IGlkTWFwID0ge30KICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4U3RyZWFtKHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZCwgd3JpdGUgfSkKCiAgY29uc3QgbWlkZGxld2FyZSA9IChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7CiAgICAvLyB3cml0ZSByZXEgdG8gc3RyZWFtCiAgICBzdHJlYW0ucHVzaChyZXEpCiAgICAvLyByZWdpc3RlciByZXF1ZXN0IG9uIGlkIG1hcAogICAgaWRNYXBbcmVxLmlkXSA9IHsgcmVxLCByZXMsIG5leHQsIGVuZCB9CiAgfQoKICBtaWRkbGV3YXJlLnN0cmVhbSA9IHN0cmVhbQogIAogIHJldHVybiBtaWRkbGV3YXJlCgogIGZ1bmN0aW9uIHJlYWQgKCkgewogICAgcmV0dXJuIGZhbHNlCiAgfQoKICBmdW5jdGlvbiB3cml0ZSAocmVzLCBlbmNvZGluZywgY2IpIHsKICAgIC8vIGNvbnNvbGUubG9nKHJlcywgZW5jb2RpbmcsIGNiKQogICAgY29uc3QgY29udGV4dCA9IGlkTWFwW3Jlcy5pZF0KICAgIGlmICghY29udGV4dCkgY2IobmV3IEVycm9yKGBTdHJlYW1NaWRkbGV3YXJlIC0gVW5rbm93biByZXNwb25zZSBpZCAke3Jlcy5pZH1gKSkKICAgIGRlbGV0ZSBpZE1hcFtyZXMuaWRdCiAgICAvLyBjb3B5IHdob2xlIHJlcyBvbnRvIG9yaWdpbmFsIHJlcwogICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LnJlcywgcmVzKQogICAgLy8gcnVuIGNhbGxiYWNrIG9uIGVtcHR5IHN0YWNrLAogICAgLy8gcHJldmVudCBpbnRlcm5hbCBzdHJlYW0taGFuZGxlciBmcm9tIGNhdGNoaW5nIGVycm9ycwogICAgc2V0VGltZW91dChjb250ZXh0LmVuZCkKICAgIC8vIGNvbnRpbnVlIHByb2Nlc3Npbmcgc3RyZWFtCiAgICBjYigpCiAgfQoKfQp9LHsicmVhZGFibGUtc3RyZWFtIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fbG9nbGV2ZWxAMS42LjFAbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8qCiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwKKgoqIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnkKKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuCiovCihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikgewogICAgInVzZSBzdHJpY3QiOwogICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgewogICAgICAgIGRlZmluZShkZWZpbml0aW9uKTsKICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHsKICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTsKICAgIH0gZWxzZSB7CiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7CiAgICB9Cn0odGhpcywgZnVuY3Rpb24gKCkgewogICAgInVzZSBzdHJpY3QiOwoKICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemUKICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTsKICAgIHZhciB1bmRlZmluZWRUeXBlID0gInVuZGVmaW5lZCI7CgogICAgdmFyIGxvZ01ldGhvZHMgPSBbCiAgICAgICAgInRyYWNlIiwKICAgICAgICAiZGVidWciLAogICAgICAgICJpbmZvIiwKICAgICAgICAid2FybiIsCiAgICAgICAgImVycm9yIgogICAgXTsKCiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2CiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkgewogICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07CiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nCiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pOwogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnYKICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlcwogICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7CiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHsKICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnOwogICAgICAgIH0KCiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcwogICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpOwogICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIG5vb3A7CiAgICAgICAgfQogICAgfQoKICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHkKCiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHsKICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqLwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07CiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/CiAgICAgICAgICAgICAgICBub29wIDoKICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7CiAgICAgICAgfQoKICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnCiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnOwogICAgfQoKICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC4KICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzCiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7CiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7CiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgIH0KICAgICAgICB9OwogICAgfQoKICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kCiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLgogICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHsKICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqLwogICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8CiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7CiAgICAgIHZhciBzZWxmID0gdGhpczsKICAgICAgdmFyIGN1cnJlbnRMZXZlbDsKICAgICAgdmFyIHN0b3JhZ2VLZXkgPSAibG9nbGV2ZWwiOwogICAgICBpZiAobmFtZSkgewogICAgICAgIHN0b3JhZ2VLZXkgKz0gIjoiICsgbmFtZTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkgewogICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTsKCiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuOwoKICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlCiAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fQoKICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFjawogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0KICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArICI9IiArIGxldmVsTmFtZSArICI7IjsKICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge30KICAgICAgfQoKICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7CiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7CgogICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjsKCiAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTsKICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge30KCiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZwogICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llOwogICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZigKICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArICI9Iik7CiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHsKICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fQogICAgICAgICAgfQoKICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuCiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7CiAgICAgIH0KCiAgICAgIC8qCiAgICAgICAqCiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlscwogICAgICAgKgogICAgICAgKi8KCiAgICAgIHNlbGYubmFtZSA9IG5hbWU7CgogICAgICBzZWxmLmxldmVscyA9IHsgIlRSQUNFIjogMCwgIkRFQlVHIjogMSwgIklORk8iOiAyLCAiV0FSTiI6IDMsCiAgICAgICAgICAiRVJST1IiOiA0LCAiU0lMRU5UIjogNX07CgogICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5OwoKICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7CiAgICAgIH07CgogICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7CiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSAic3RyaW5nIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTsKICAgICAgICAgIH0KICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICJudW1iZXIiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7CiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7CiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlCiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiAiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmciOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhyb3cgImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6ICIgKyBsZXZlbDsKICAgICAgICAgIH0KICAgICAgfTsKCiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7CiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHsKICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7CiAgICAgICAgICB9CiAgICAgIH07CgogICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHsKICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpOwogICAgICB9OwoKICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkgewogICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpOwogICAgICB9OwoKICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbAogICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTsKICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7CiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/ICJXQVJOIiA6IGRlZmF1bHRMZXZlbDsKICAgICAgfQogICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpOwogICAgfQoKICAgIC8qCiAgICAgKgogICAgICogVG9wLWxldmVsIEFQSQogICAgICoKICAgICAqLwoKICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpOwoKICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9OwogICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkgewogICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gInN0cmluZyIgfHwgbmFtZSA9PT0gIiIpIHsKICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci4iKTsKICAgICAgICB9CgogICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTsKICAgICAgICBpZiAoIWxvZ2dlcikgewogICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKAogICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBsb2dnZXI7CiAgICB9OwoKICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZQogICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkOwogICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7CiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiYKICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikgewogICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZzsKICAgICAgICB9CgogICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyOwogICAgfTsKCiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkgewogICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTsKICAgIH07CgogICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7Cn0pKTsKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX29iai1tdWx0aXBsZXhAMS4wLjBAb2JqLW11bHRpcGxleC9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpjb25zdCB7IER1cGxleCB9ID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtJykKY29uc3QgZW5kT2ZTdHJlYW0gPSBfZGVyZXFfKCdlbmQtb2Ytc3RyZWFtJykKY29uc3Qgb25jZSA9IF9kZXJlcV8oJ29uY2UnKQpjb25zdCBub29wID0gKCkgPT4ge30KCmNvbnN0IElHTk9SRV9TVUJTVFJFQU0gPSB7fQoKCmNsYXNzIE9iamVjdE11bHRpcGxleCBleHRlbmRzIER1cGxleCB7CgogIGNvbnN0cnVjdG9yKF9vcHRzID0ge30pIHsKICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBfb3B0cywgewogICAgICBvYmplY3RNb2RlOiB0cnVlLAogICAgfSkKICAgIHN1cGVyKG9wdHMpCgogICAgdGhpcy5fc3Vic3RyZWFtcyA9IHt9CiAgfQoKICBjcmVhdGVTdHJlYW0gKG5hbWUpIHsKICAgIC8vIHZhbGlkYXRlIG5hbWUKICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5JykKICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSAiJHtuYW1lfSIgYWxyZWFkeSBleGlzdHMnKQoKICAgIC8vIGNyZWF0ZSBzdWJzdHJlYW0KICAgIGNvbnN0IHN1YnN0cmVhbSA9IG5ldyBTdWJzdHJlYW0oeyBwYXJlbnQ6IHRoaXMsIG5hbWU6IG5hbWUgfSkKICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBzdWJzdHJlYW0KCiAgICAvLyBsaXN0ZW4gZm9yIHBhcmVudCBzdHJlYW0gdG8gZW5kCiAgICBhbnlTdHJlYW1FbmQodGhpcywgKGVycikgPT4gewogICAgICBzdWJzdHJlYW0uZGVzdHJveShlcnIpCiAgICB9KQoKICAgIHJldHVybiBzdWJzdHJlYW0KICB9CgogIC8vIGlnbm9yZSBzdHJlYW1zIChkb250IGRpc3BsYXkgb3JwaGFuZWQgZGF0YSB3YXJuaW5nKQogIGlnbm9yZVN0cmVhbSAobmFtZSkgewogICAgLy8gdmFsaWRhdGUgbmFtZQogICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdE11bHRpcGxleCAtIG5hbWUgbXVzdCBub3QgYmUgZW1wdHknKQogICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lICIke25hbWV9IiBhbHJlYWR5IGV4aXN0cycpCiAgICAvLyBzZXQKICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBJR05PUkVfU1VCU1RSRUFNCiAgfQoKICAvLyBzdHJlYW0gcGx1bWJpbmcKCiAgX3JlYWQgKCkge30KCiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHsKICAgIC8vIHBhcnNlIG1lc3NhZ2UKICAgIGNvbnN0IG5hbWUgPSBjaHVuay5uYW1lCiAgICBjb25zdCBkYXRhID0gY2h1bmsuZGF0YQogICAgaWYgKCFuYW1lKSB7CiAgICAgIGNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gbWFsZm9ybWVkIGNodW5rIHdpdGhvdXQgbmFtZSAiJHtjaHVua30iYCkKICAgICAgcmV0dXJuIGNhbGxiYWNrKCkKICAgIH0KCiAgICAvLyBnZXQgY29ycmVzcG9uZGluZyBzdWJzdHJlYW0KICAgIGNvbnN0IHN1YnN0cmVhbSA9IHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0KICAgIGlmICghc3Vic3RyZWFtKSB7CiAgICAgIGNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gb3JwaGFuZWQgZGF0YSBmb3Igc3RyZWFtICIke25hbWV9ImApCiAgICAgIHJldHVybiBjYWxsYmFjaygpCiAgICB9CgogICAgLy8gcHVzaCBkYXRhIGludG8gc3Vic3RyZWFtCiAgICBpZiAoc3Vic3RyZWFtICE9PSBJR05PUkVfU1VCU1RSRUFNKSB7CiAgICAgIHN1YnN0cmVhbS5wdXNoKGRhdGEpCiAgICB9CgogICAgY2FsbGJhY2soKQogIH0KCn0KCgpjbGFzcyBTdWJzdHJlYW0gZXh0ZW5kcyBEdXBsZXggewoKICBjb25zdHJ1Y3RvciAoeyBwYXJlbnQsIG5hbWUgfSkgewogICAgc3VwZXIoewogICAgICBvYmplY3RNb2RlOiB0cnVlLAogICAgfSkKCiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQKICAgIHRoaXMuX25hbWUgPSBuYW1lCiAgfQoKICBfcmVhZCAoKSB7fQoKICBfd3JpdGUgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7CiAgICB0aGlzLl9wYXJlbnQucHVzaCh7CiAgICAgIG5hbWU6IHRoaXMuX25hbWUsCiAgICAgIGRhdGE6IGNodW5rLAogICAgfSkKICAgIGNhbGxiYWNrKCkKICB9Cgp9Cgptb2R1bGUuZXhwb3J0cyA9IE9iamVjdE11bHRpcGxleAoKLy8gdXRpbAoKZnVuY3Rpb24gYW55U3RyZWFtRW5kKHN0cmVhbSwgX2NiKSB7CiAgY29uc3QgY2IgPSBvbmNlKF9jYikKICBlbmRPZlN0cmVhbShzdHJlYW0sIHsgcmVhZGFibGU6IGZhbHNlIH0sIGNiKQogIGVuZE9mU3RyZWFtKHN0cmVhbSwgeyB3cml0YWJsZTogZmFsc2UgfSwgY2IpCn0KfSx7ImVuZC1vZi1zdHJlYW0iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2VuZC1vZi1zdHJlYW1AMS40LjFAZW5kLW9mLXN0cmVhbS9pbmRleC5qcyIsIm9uY2UiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX29uY2VAMS40LjBAb25jZS9vbmNlLmpzIiwicmVhZGFibGUtc3RyZWFtIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fb2JzLXN0b3JlQDMuMC4wQG9icy1zdG9yZS9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Cgp2YXIgX2Fzc2lnbiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduJyk7Cgp2YXIgX2Fzc2lnbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3NpZ24pOwoKdmFyIF90eXBlb2YyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZicpOwoKdmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7Cgp2YXIgX2dldFByb3RvdHlwZU9mID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mJyk7Cgp2YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTsKCnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7Cgp2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7Cgp2YXIgX2NyZWF0ZUNsYXNzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpOwoKdmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpOwoKdmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuJyk7Cgp2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpOwoKdmFyIF9pbmhlcml0czIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTsKCnZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9Cgp2YXIgZXh0ZW5kID0gX2RlcmVxXygneHRlbmQnKTsKdmFyIEV2ZW50RW1pdHRlciA9IF9kZXJlcV8oJ2V2ZW50cycpOwoKdmFyIE9ic2VydmFibGVTdG9yZSA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7CiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoT2JzZXJ2YWJsZVN0b3JlLCBfRXZlbnRFbWl0dGVyKTsKCiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVN0b3JlKCkgewogICAgdmFyIGluaXRTdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307CiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBPYnNlcnZhYmxlU3RvcmUpOwoKICAgIC8vIHNldCBpbml0IHN0YXRlCiAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIChPYnNlcnZhYmxlU3RvcmUuX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKE9ic2VydmFibGVTdG9yZSkpLmNhbGwodGhpcykpOwoKICAgIF90aGlzLl9zdGF0ZSA9IGluaXRTdGF0ZTsKICAgIHJldHVybiBfdGhpczsKICB9CgogIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIGdldFN0YXRlCgoKICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShPYnNlcnZhYmxlU3RvcmUsIFt7CiAgICBrZXk6ICdnZXRTdGF0ZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGUoKSB7CiAgICAgIHJldHVybiB0aGlzLl9nZXRTdGF0ZSgpOwogICAgfQoKICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIHB1dFN0YXRlCgogIH0sIHsKICAgIGtleTogJ3B1dFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRTdGF0ZShuZXdTdGF0ZSkgewogICAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSk7CiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpOwogICAgfQogIH0sIHsKICAgIGtleTogJ3VwZGF0ZVN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShwYXJ0aWFsU3RhdGUpIHsKICAgICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZQogICAgICBpZiAocGFydGlhbFN0YXRlICYmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHBhcnRpYWxTdGF0ZSkpID09PSAnb2JqZWN0JykgewogICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTsKICAgICAgICB2YXIgbmV3U3RhdGUgPSAoMCwgX2Fzc2lnbjIuZGVmYXVsdCkoe30sIHN0YXRlLCBwYXJ0aWFsU3RhdGUpOwogICAgICAgIHRoaXMucHV0U3RhdGUobmV3U3RhdGUpOwogICAgICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWUKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnB1dFN0YXRlKHBhcnRpYWxTdGF0ZSk7CiAgICAgIH0KICAgIH0KCiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcwoKICB9LCB7CiAgICBrZXk6ICdzdWJzY3JpYmUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShoYW5kbGVyKSB7CiAgICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpOwogICAgfQoKICAgIC8vIHVuc3Vic2NyaWJlIHRvIGNoYW5nZXMKCiAgfSwgewogICAga2V5OiAndW5zdWJzY3JpYmUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGhhbmRsZXIpIHsKICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigndXBkYXRlJywgaGFuZGxlcik7CiAgICB9CgogICAgLy8KICAgIC8vIHByaXZhdGUKICAgIC8vCgogICAgLy8gcmVhZCBmcm9tIHBlcnNpc3RlbmNlCgogIH0sIHsKICAgIGtleTogJ19nZXRTdGF0ZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0YXRlKCkgewogICAgICByZXR1cm4gdGhpcy5fc3RhdGU7CiAgICB9CgogICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2UKCiAgfSwgewogICAga2V5OiAnX3B1dFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBfcHV0U3RhdGUobmV3U3RhdGUpIHsKICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTsKICAgIH0KICB9XSk7CiAgcmV0dXJuIE9ic2VydmFibGVTdG9yZTsKfShFdmVudEVtaXR0ZXIpOwoKbW9kdWxlLmV4cG9ydHMgPSBPYnNlcnZhYmxlU3RvcmU7Cgp9LHsiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2siOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzIiwiZXZlbnRzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19ldmVudHNAMi4xLjBAZXZlbnRzL2V2ZW50cy5qcyIsInh0ZW5kIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL194dGVuZEA0LjAuMUB4dGVuZC9pbW11dGFibGUuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fb2JzLXN0b3JlQDMuMC4wQG9icy1zdG9yZS9saWIvYXNTdHJlYW0uanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwoKdmFyIF9nZXRQcm90b3R5cGVPZiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZicpOwoKdmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7Cgp2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpOwoKdmFyIF9jcmVhdGVDbGFzczIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTsKCnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTsKCnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpOwoKdmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTsKCnZhciBfaW5oZXJpdHMyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7Cgp2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKdmFyIER1cGxleFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpLkR1cGxleDsKCm1vZHVsZS5leHBvcnRzID0gYXNTdHJlYW07CgpmdW5jdGlvbiBhc1N0cmVhbShvYnNTdG9yZSkgewogIHJldHVybiBuZXcgT2JzU3RvcmVTdHJlYW0ob2JzU3RvcmUpOwp9CgovLwovLwovLwovLwoKdmFyIE9ic1N0b3JlU3RyZWFtID0gZnVuY3Rpb24gKF9EdXBsZXhTdHJlYW0pIHsKICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShPYnNTdG9yZVN0cmVhbSwgX0R1cGxleFN0cmVhbSk7CgogIGZ1bmN0aW9uIE9ic1N0b3JlU3RyZWFtKG9ic1N0b3JlKSB7CiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBPYnNTdG9yZVN0cmVhbSk7CgogICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlcwogICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCAoT2JzU3RvcmVTdHJlYW0uX19wcm90b19fIHx8ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKE9ic1N0b3JlU3RyZWFtKSkuY2FsbCh0aGlzLCB7CiAgICAgIC8vIHBhc3MgdmFsdWVzLCBub3Qgc2VyaWFsaXphdGlvbnMKICAgICAgb2JqZWN0TW9kZTogdHJ1ZQogICAgfSkpOwoKICAgIF90aGlzLnJlc3VtZSgpOwogICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXMKICAgIF90aGlzLm9ic1N0b3JlID0gb2JzU3RvcmU7CiAgICBfdGhpcy5vYnNTdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0YXRlKSB7CiAgICAgIHJldHVybiBfdGhpcy5wdXNoKHN0YXRlKTsKICAgIH0pOwogICAgcmV0dXJuIF90aGlzOwogIH0KCiAgLy8gZW1pdCBjdXJyZW50IHN0YXRlIG9uIG5ldyBkZXN0aW5hdGlvbgoKCiAgKDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoT2JzU3RvcmVTdHJlYW0sIFt7CiAgICBrZXk6ICdwaXBlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBwaXBlKGRlc3QsIG9wdGlvbnMpIHsKICAgICAgdmFyIHJlc3VsdCA9IER1cGxleFN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHRoaXMsIGRlc3QsIG9wdGlvbnMpOwogICAgICBkZXN0LndyaXRlKHRoaXMub2JzU3RvcmUuZ2V0U3RhdGUoKSk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogICAgLy8gd3JpdGUgZnJvbSBpbmNvbW1pbmcgc3RyZWFtIHRvIHN0YXRlCgogIH0sIHsKICAgIGtleTogJ193cml0ZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHsKICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7CiAgICAgIGNhbGxiYWNrKCk7CiAgICB9CgogICAgLy8gbm9vcCAtIG91dGdvaW5nIHN0cmVhbSBpcyBhc2tpbmcgdXMgaWYgd2UgaGF2ZSBkYXRhIHdlIGFyZW50IGdpdmluZyBpdAoKICB9LCB7CiAgICBrZXk6ICdfcmVhZCcsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWQoc2l6ZSkge30KICB9XSk7CiAgcmV0dXJuIE9ic1N0b3JlU3RyZWFtOwp9KER1cGxleFN0cmVhbSk7Cgp9LHsiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanMiLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2siOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2JhYmVsLXJ1bnRpbWVANi4yNi4wQGJhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsImJhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19iYWJlbC1ydW50aW1lQDYuMjYuMEBiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYmFiZWwtcnVudGltZUA2LjI2LjBAYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJzdHJlYW0iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3N0cmVhbS1icm93c2VyaWZ5QDIuMC4xQHN0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX29uY2VAMS40LjBAb25jZS9vbmNlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB3cmFwcHkgPSBfZGVyZXFfKCd3cmFwcHknKQptb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKQptb2R1bGUuZXhwb3J0cy5zdHJpY3QgPSB3cmFwcHkob25jZVN0cmljdCkKCm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHsKICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBvbmNlKHRoaXMpCiAgICB9LAogICAgY29uZmlndXJhYmxlOiB0cnVlCiAgfSkKCiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2VTdHJpY3QnLCB7CiAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gb25jZVN0cmljdCh0aGlzKQogICAgfSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogIH0pCn0pCgpmdW5jdGlvbiBvbmNlIChmbikgewogIHZhciBmID0gZnVuY3Rpb24gKCkgewogICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZQogICAgZi5jYWxsZWQgPSB0cnVlCiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKICB9CiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCmZ1bmN0aW9uIG9uY2VTdHJpY3QgKGZuKSB7CiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7CiAgICBpZiAoZi5jYWxsZWQpCiAgICAgIHRocm93IG5ldyBFcnJvcihmLm9uY2VFcnJvcikKICAgIGYuY2FsbGVkID0gdHJ1ZQogICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpCiAgfQogIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCcKICBmLm9uY2VFcnJvciA9IG5hbWUgKyAiIHNob3VsZG4ndCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UiCiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCn0seyJ3cmFwcHkiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3dyYXBweUAxLjAuMkB3cmFwcHkvd3JhcHB5LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3Bvc3QtbWVzc2FnZS1zdHJlYW1AMy4wLjBAcG9zdC1tZXNzYWdlLXN0cmVhbS9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpjb25zdCBEdXBsZXhTdHJlYW0gPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0nKS5EdXBsZXgKY29uc3QgaW5oZXJpdHMgPSBfZGVyZXFfKCd1dGlsJykuaW5oZXJpdHMKCm1vZHVsZS5leHBvcnRzID0gUG9zdE1lc3NhZ2VTdHJlYW0KCmluaGVyaXRzKFBvc3RNZXNzYWdlU3RyZWFtLCBEdXBsZXhTdHJlYW0pCgpmdW5jdGlvbiBQb3N0TWVzc2FnZVN0cmVhbSAob3B0cykgewogIER1cGxleFN0cmVhbS5jYWxsKHRoaXMsIHsKICAgIG9iamVjdE1vZGU6IHRydWUsCiAgfSkKCiAgdGhpcy5fbmFtZSA9IG9wdHMubmFtZQogIHRoaXMuX3RhcmdldCA9IG9wdHMudGFyZ2V0CiAgdGhpcy5fdGFyZ2V0V2luZG93ID0gb3B0cy50YXJnZXRXaW5kb3cgfHwgd2luZG93CiAgdGhpcy5fb3JpZ2luID0gKG9wdHMudGFyZ2V0V2luZG93ID8gJyonIDogbG9jYXRpb24ub3JpZ2luKQoKICAvLyBpbml0aWFsaXphdGlvbiBmbGFncwogIHRoaXMuX2luaXQgPSBmYWxzZQogIHRoaXMuX2hhdmVTeW4gPSBmYWxzZQoKICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpLCBmYWxzZSkKICAvLyBzZW5kIHN5bmNvcml6YXRpb24gbWVzc2FnZQogIHRoaXMuX3dyaXRlKCdTWU4nLCBudWxsLCBub29wKQogIHRoaXMuY29yaygpCn0KCi8vIHByaXZhdGUKUG9zdE1lc3NhZ2VTdHJlYW0ucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICB2YXIgbXNnID0gZXZlbnQuZGF0YQoKICAvLyB2YWxpZGF0ZSBtZXNzYWdlCiAgaWYgKHRoaXMuX29yaWdpbiAhPT0gJyonICYmIGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5fb3JpZ2luKSByZXR1cm4KICBpZiAoZXZlbnQuc291cmNlICE9PSB0aGlzLl90YXJnZXRXaW5kb3cpIHJldHVybgogIGlmICh0eXBlb2YgbXNnICE9PSAnb2JqZWN0JykgcmV0dXJuCiAgaWYgKG1zZy50YXJnZXQgIT09IHRoaXMuX25hbWUpIHJldHVybgogIGlmICghbXNnLmRhdGEpIHJldHVybgoKICBpZiAoIXRoaXMuX2luaXQpIHsKICAgIGlmIChtc2cuZGF0YSA9PT0gJ1NZTicpIHsKICAgICAgdGhpcy5faGF2ZVN5biA9IHRydWUKICAgICAgdGhpcy5fd3JpdGUoJ0FDSycsIG51bGwsIG5vb3ApCiAgICB9IGVsc2UgaWYgKG1zZy5kYXRhID09PSAnQUNLJykgewogICAgICB0aGlzLl9pbml0ID0gdHJ1ZQogICAgICBpZiAoIXRoaXMuX2hhdmVTeW4pIHsKICAgICAgICB0aGlzLl93cml0ZSgnQUNLJywgbnVsbCwgbm9vcCkKICAgICAgfQogICAgICB0aGlzLnVuY29yaygpCiAgICB9CiAgfSBlbHNlIHsKICAgIC8vIGZvcndhcmQgbWVzc2FnZQogICAgdHJ5IHsKICAgICAgdGhpcy5wdXNoKG1zZy5kYXRhKQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpCiAgICB9CiAgfQp9CgovLyBzdHJlYW0gcGx1bWJpbmcKUG9zdE1lc3NhZ2VTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gbm9vcAoKUG9zdE1lc3NhZ2VTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHsKICB2YXIgbWVzc2FnZSA9IHsKICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LAogICAgZGF0YTogZGF0YSwKICB9CiAgdGhpcy5fdGFyZ2V0V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRoaXMuX29yaWdpbikKICBjYigpCn0KCi8vIHV0aWwKCmZ1bmN0aW9uIG5vb3AgKCkge30KCn0seyJyZWFkYWJsZS1zdHJlYW0iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsInV0aWwiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3V0aWxAMC4xMC4zQHV0aWwvdXRpbC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19wcm9jZXNzLW5leHRpY2stYXJnc0AyLjAuMEBwcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MpewondXNlIHN0cmljdCc7CgppZiAoIXByb2Nlc3MudmVyc2lvbiB8fAogICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8CiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHsKICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07Cn0gZWxzZSB7CiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzCn0KCmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7CiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImNhbGxiYWNrIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKICB9CiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgdmFyIGFyZ3MsIGk7CiAgc3dpdGNoIChsZW4pIHsKICBjYXNlIDA6CiAgY2FzZSAxOgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pOwogIGNhc2UgMjoKICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHsKICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTsKICAgIH0pOwogIGNhc2UgMzoKICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHsKICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTsKICAgIH0pOwogIGNhc2UgNDoKICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkgewogICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpOwogICAgfSk7CiAgZGVmYXVsdDoKICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7CiAgICBpID0gMDsKICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHsKICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldOwogICAgfQogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkgewogICAgICBmbi5hcHBseShudWxsLCBhcmdzKTsKICAgIH0pOwogIH0KfQoKCn0pLmNhbGwodGhpcyxfZGVyZXFfKCdfcHJvY2VzcycpKQoKfSx7Il9wcm9jZXNzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19wcm9jZXNzQDAuMTEuMTBAcHJvY2Vzcy9icm93c2VyLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3Byb2Nlc3NAMC4xMS4xMEBwcm9jZXNzL2Jyb3dzZXIuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyCnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTsKCi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdAovLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXMKLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYQovLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLgoKdmFyIGNhY2hlZFNldFRpbWVvdXQ7CnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7CgpmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkgewogICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7Cn0KZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpOwp9CihmdW5jdGlvbiAoKSB7CiAgICB0cnkgewogICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDsKICAgICAgICB9CiAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7CiAgICB9CiAgICB0cnkgewogICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0OwogICAgICAgIH0KICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0OwogICAgfQp9ICgpKQpmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikgewogICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHsKICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnMKICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApOwogICAgfQogICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWQKICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkgewogICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0OwogICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7CiAgICB9CiAgICB0cnkgewogICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3MKICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApOwogICAgfSBjYXRjaChlKXsKICAgICAgICB0cnkgewogICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHkKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApOwogICAgICAgIH0gY2F0Y2goZSl7CiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yCiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTsKICAgICAgICB9CiAgICB9CgoKfQpmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7CiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHsKICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnMKICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7CiAgICB9CiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkCiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHsKICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7CiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpOwogICAgfQogICAgdHJ5IHsKICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzCiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpOwogICAgfSBjYXRjaCAoZSl7CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseQogICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTsKICAgICAgICB9IGNhdGNoIChlKXsKICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuCiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXQKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7CiAgICAgICAgfQogICAgfQoKCgp9CnZhciBxdWV1ZSA9IFtdOwp2YXIgZHJhaW5pbmcgPSBmYWxzZTsKdmFyIGN1cnJlbnRRdWV1ZTsKdmFyIHF1ZXVlSW5kZXggPSAtMTsKCmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHsKICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkgewogICAgICAgIHJldHVybjsKICAgIH0KICAgIGRyYWluaW5nID0gZmFsc2U7CiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkgewogICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7CiAgICB9IGVsc2UgewogICAgICAgIHF1ZXVlSW5kZXggPSAtMTsKICAgIH0KICAgIGlmIChxdWV1ZS5sZW5ndGgpIHsKICAgICAgICBkcmFpblF1ZXVlKCk7CiAgICB9Cn0KCmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7CiAgICBpZiAoZHJhaW5pbmcpIHsKICAgICAgICByZXR1cm47CiAgICB9CiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTsKICAgIGRyYWluaW5nID0gdHJ1ZTsKCiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoOwogICAgd2hpbGUobGVuKSB7CiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7CiAgICAgICAgcXVldWUgPSBbXTsKICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7CiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHsKICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBxdWV1ZUluZGV4ID0gLTE7CiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoOwogICAgfQogICAgY3VycmVudFF1ZXVlID0gbnVsbDsKICAgIGRyYWluaW5nID0gZmFsc2U7CiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7Cn0KCnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7CiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7CiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTsKICAgICAgICB9CiAgICB9CiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpOwogICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHsKICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpOwogICAgfQp9OwoKLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0cwpmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHsKICAgIHRoaXMuZnVuID0gZnVuOwogICAgdGhpcy5hcnJheSA9IGFycmF5Owp9Ckl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpOwp9Owpwcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInOwpwcm9jZXNzLmJyb3dzZXIgPSB0cnVlOwpwcm9jZXNzLmVudiA9IHt9Owpwcm9jZXNzLmFyZ3YgPSBbXTsKcHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzCnByb2Nlc3MudmVyc2lvbnMgPSB7fTsKCmZ1bmN0aW9uIG5vb3AoKSB7fQoKcHJvY2Vzcy5vbiA9IG5vb3A7CnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLm9uY2UgPSBub29wOwpwcm9jZXNzLm9mZiA9IG5vb3A7CnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7CnByb2Nlc3MuZW1pdCA9IG5vb3A7CnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDsKcHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDsKCnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH0KCnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7Cn07Cgpwcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9Owpwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikgewogICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTsKfTsKcHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTsKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3B1bXBAMy4wLjBAcHVtcC9pbmRleC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3Mpewp2YXIgb25jZSA9IF9kZXJlcV8oJ29uY2UnKQp2YXIgZW9zID0gX2RlcmVxXygnZW5kLW9mLXN0cmVhbScpCnZhciBmcyA9IF9kZXJlcV8oJ2ZzJykgLy8gd2Ugb25seSBuZWVkIGZzIHRvIGdldCB0aGUgUmVhZFN0cmVhbSBhbmQgV3JpdGVTdHJlYW0gcHJvdG90eXBlcwoKdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fQp2YXIgYW5jaWVudCA9IC9edj9cLjAvLnRlc3QocHJvY2Vzcy52ZXJzaW9uKQoKdmFyIGlzRm4gPSBmdW5jdGlvbiAoZm4pIHsKICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nCn0KCnZhciBpc0ZTID0gZnVuY3Rpb24gKHN0cmVhbSkgewogIGlmICghYW5jaWVudCkgcmV0dXJuIGZhbHNlIC8vIG5ld2VyIG5vZGUgdmVyc2lvbiBkbyBub3QgbmVlZCB0byBjYXJlIGFib3V0IGZzIGlzIGEgc3BlY2lhbCB3YXkKICBpZiAoIWZzKSByZXR1cm4gZmFsc2UgLy8gYnJvd3NlcgogIHJldHVybiAoc3RyZWFtIGluc3RhbmNlb2YgKGZzLlJlYWRTdHJlYW0gfHwgbm9vcCkgfHwgc3RyZWFtIGluc3RhbmNlb2YgKGZzLldyaXRlU3RyZWFtIHx8IG5vb3ApKSAmJiBpc0ZuKHN0cmVhbS5jbG9zZSkKfQoKdmFyIGlzUmVxdWVzdCA9IGZ1bmN0aW9uIChzdHJlYW0pIHsKICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiBpc0ZuKHN0cmVhbS5hYm9ydCkKfQoKdmFyIGRlc3Ryb3llciA9IGZ1bmN0aW9uIChzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7CiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKQoKICB2YXIgY2xvc2VkID0gZmFsc2UKICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkgewogICAgY2xvc2VkID0gdHJ1ZQogIH0pCgogIGVvcyhzdHJlYW0sIHtyZWFkYWJsZTogcmVhZGluZywgd3JpdGFibGU6IHdyaXRpbmd9LCBmdW5jdGlvbiAoZXJyKSB7CiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKQogICAgY2xvc2VkID0gdHJ1ZQogICAgY2FsbGJhY2soKQogIH0pCgogIHZhciBkZXN0cm95ZWQgPSBmYWxzZQogIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7CiAgICBpZiAoY2xvc2VkKSByZXR1cm4KICAgIGlmIChkZXN0cm95ZWQpIHJldHVybgogICAgZGVzdHJveWVkID0gdHJ1ZQoKICAgIGlmIChpc0ZTKHN0cmVhbSkpIHJldHVybiBzdHJlYW0uY2xvc2Uobm9vcCkgLy8gdXNlIGNsb3NlIGZvciBmcyBzdHJlYW1zIHRvIGF2b2lkIGZkIGxlYWtzCiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKSAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudAoKICAgIGlmIChpc0ZuKHN0cmVhbS5kZXN0cm95KSkgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCkKCiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVycm9yKCdzdHJlYW0gd2FzIGRlc3Ryb3llZCcpKQogIH0KfQoKdmFyIGNhbGwgPSBmdW5jdGlvbiAoZm4pIHsKICBmbigpCn0KCnZhciBwaXBlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7CiAgcmV0dXJuIGZyb20ucGlwZSh0bykKfQoKdmFyIHB1bXAgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0cmVhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpCiAgdmFyIGNhbGxiYWNrID0gaXNGbihzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gfHwgbm9vcCkgJiYgc3RyZWFtcy5wb3AoKSB8fCBub29wCgogIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXQogIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHRocm93IG5ldyBFcnJvcigncHVtcCByZXF1aXJlcyB0d28gc3RyZWFtcyBwZXIgbWluaW11bScpCgogIHZhciBlcnJvcgogIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHsKICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMQogICAgdmFyIHdyaXRpbmcgPSBpID4gMAogICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnIKICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKQogICAgICBpZiAocmVhZGluZykgcmV0dXJuCiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCkKICAgICAgY2FsbGJhY2soZXJyb3IpCiAgICB9KQogIH0pCgogIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKQp9Cgptb2R1bGUuZXhwb3J0cyA9IHB1bXAKCn0pLmNhbGwodGhpcyxfZGVyZXFfKCdfcHJvY2VzcycpKQoKfSx7Il9wcm9jZXNzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19wcm9jZXNzQDAuMTEuMTBAcHJvY2Vzcy9icm93c2VyLmpzIiwiZW5kLW9mLXN0cmVhbSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fZW5kLW9mLXN0cmVhbUAxLjQuMUBlbmQtb2Ytc3RyZWFtL2luZGV4LmpzIiwiZnMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2Jyb3dzZXItcmVzb2x2ZUAxLjExLjJAYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwib25jZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fb25jZUAxLjQuMEBvbmNlL29uY2UuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7Cgp9LHsiLi9saWIvX3N0cmVhbV9kdXBsZXguanMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuCi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzCi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb20KLy8gV3JpdGFibGUuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIHBuYSA9IF9kZXJlcV8oJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7CiAgdmFyIGtleXMgPSBbXTsKICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7CiAgICBrZXlzLnB1c2goa2V5KTsKICB9cmV0dXJuIGtleXM7Cn07Ci8qPC9yZXBsYWNlbWVudD4qLwoKbW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpOwp1dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKLyo8L3JlcGxhY2VtZW50PiovCgp2YXIgUmVhZGFibGUgPSBfZGVyZXFfKCcuL19zdHJlYW1fcmVhZGFibGUnKTsKdmFyIFdyaXRhYmxlID0gX2RlcmVxXygnLi9fc3RyZWFtX3dyaXRhYmxlJyk7Cgp1dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpOwoKewogIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWQKICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTsKICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHsKICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdOwogICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdOwogIH0KfQoKZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7CgogIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7CiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTsKCiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTsKCiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTsKCiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTsKICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTsKCiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7Cn0KCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgewogIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlCiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluCiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsCiAgZW51bWVyYWJsZTogZmFsc2UsCiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrOwogIH0KfSk7CgovLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyCmZ1bmN0aW9uIG9uZW5kKCkgewogIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsCiAgLy8gdGhlbiB3ZSdyZSBvay4KICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsKCiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLgogIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLgogIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTsKfQoKZnVuY3Rpb24gb25FbmROVChzZWxmKSB7CiAgc2VsZi5lbmQoKTsKfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7CiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgfSwKICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtCiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0CiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseQogICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkCiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICB9Cn0pOwoKRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7CiAgdGhpcy5wdXNoKG51bGwpOwogIHRoaXMuZW5kKCk7CgogIHBuYS5uZXh0VGljayhjYiwgZXJyKTsKfTsKfSx7Ii4vX3N0cmVhbV9yZWFkYWJsZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIi4vX3N0cmVhbV93cml0YWJsZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsImNvcmUtdXRpbC1pcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS11dGlsLWlzQDEuMC4yQGNvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsImluaGVyaXRzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19pbmhlcml0c0AyLjAuM0Bpbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3Byb2Nlc3MtbmV4dGljay1hcmdzQDIuMC4wQHByb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uCi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLgovLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLgoKJ3VzZSBzdHJpY3QnOwoKbW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDsKCnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpOwp1dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKLyo8L3JlcGxhY2VtZW50PiovCgp1dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pOwoKZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykgewogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7CgogIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpOwp9CgpQYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgY2IobnVsbCwgY2h1bmspOwp9Owp9LHsiLi9fc3RyZWFtX3RyYW5zZm9ybSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJjb3JlLXV0aWwtaXMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2NvcmUtdXRpbC1pc0AxLjAuMkBjb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJpbmhlcml0cyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9faW5oZXJpdHNAMi4wLjNAaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIHBuYSA9IF9kZXJlcV8oJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKbW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBEdXBsZXg7Ci8qPC9yZXBsYWNlbWVudD4qLwoKUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7Cgp2YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHsKICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoOwp9OwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBTdHJlYW0gPSBfZGVyZXFfKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KCnZhciBCdWZmZXIgPSBfZGVyZXFfKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjsKdmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTsKZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykgewogIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7Cn0KZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHsKICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTsKfQoKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpOwp1dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgZGVidWdVdGlsID0gX2RlcmVxXygndXRpbCcpOwp2YXIgZGVidWcgPSB2b2lkIDA7CmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7CiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpOwp9IGVsc2UgewogIGRlYnVnID0gZnVuY3Rpb24gKCkge307Cn0KLyo8L3JlcGxhY2VtZW50PiovCgp2YXIgQnVmZmVyTGlzdCA9IF9kZXJlcV8oJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7CnZhciBkZXN0cm95SW1wbCA9IF9kZXJlcV8oJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7CnZhciBTdHJpbmdEZWNvZGVyOwoKdXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTsKCnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107CgpmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7CiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd24KICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS4KICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsKCiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueQogIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkcwogIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGUKICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suCiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07Cn0KCmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7CiAgRHVwbGV4ID0gRHVwbGV4IHx8IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTsKCiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CgogIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlCiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuCiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnQKICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLgogIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLgogIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsKCiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG8KICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheQogIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlOwoKICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOwoKICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlcgogIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXIiCiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyazsKICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyazsKICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0OwoKICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTsKCiAgLy8gY2FzdCB0byBpbnRzLgogIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTsKCiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGUKICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhbgogIC8vIGFycmF5LnNoaWZ0KCkKICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7CiAgdGhpcy5sZW5ndGggPSAwOwogIHRoaXMucGlwZXMgPSBudWxsOwogIHRoaXMucGlwZXNDb3VudCA9IDA7CiAgdGhpcy5mbG93aW5nID0gbnVsbDsKICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7CiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7CgogIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWQKICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZQogIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCAibGF0ZXIiIHNob3VsZCBnZW5lcmFsbHkgYWxzbwogIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuCiAgdGhpcy5zeW5jID0gdHJ1ZTsKCiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXkKICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi4KICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlOwogIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7CiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlOwogIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7CgogIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZAogIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7CgogIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmcKICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuCiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLgogIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOwoKICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpcwogIHRoaXMuYXdhaXREcmFpbiA9IDA7CgogIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWQKICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7CgogIHRoaXMuZGVjb2RlciA9IG51bGw7CiAgdGhpcy5lbmNvZGluZyA9IG51bGw7CiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHsKICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IF9kZXJlcV8oJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7CiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTsKICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwogIH0KfQoKZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykgewogIER1cGxleCA9IER1cGxleCB8fCBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7CgogIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTsKCiAgLy8gbGVnYWN5CiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7CgogIGlmIChvcHRpb25zKSB7CiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDsKCiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTsKICB9CgogIFN0cmVhbS5jYWxsKHRoaXMpOwp9CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywgewogIGdldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgfSwKICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtCiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0CiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHkKICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZAogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICB9Cn0pOwoKUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95OwpSZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTsKUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHsKICB0aGlzLnB1c2gobnVsbCk7CiAgY2IoZXJyKTsKfTsKCi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLgovLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCwKLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZAovLyB3cml0ZSgpIHNvbWUgbW9yZS4KUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgc2tpcENodW5rQ2hlY2s7CgogIGlmICghc3RhdGUub2JqZWN0TW9kZSkgewogICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHsKICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7CiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHsKICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgZW5jb2RpbmcgPSAnJzsKICAgICAgfQogICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7CiAgICB9CiAgfSBlbHNlIHsKICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTsKICB9CgogIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTsKfTsKCi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpClJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7CiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTsKfTsKCmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIGlmIChjaHVuayA9PT0gbnVsbCkgewogICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTsKICB9IGVsc2UgewogICAgdmFyIGVyOwogICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTsKICAgIGlmIChlcikgewogICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkgewogICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7CiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTsKICAgICAgfQoKICAgICAgaWYgKGFkZFRvRnJvbnQpIHsKICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTsKICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkgewogICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykgewogICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsKICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7CiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKICAgIH0KICB9CgogIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpOwp9CgpmdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkgewogIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykgewogICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICB9IGVsc2UgewogICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby4KICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7CgogICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7CiAgfQogIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7Cn0KCmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHsKICB2YXIgZXI7CiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHsKICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpOwogIH0KICByZXR1cm4gZXI7Cn0KCi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuCi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lCi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLAovLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYQovLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXQKLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXIKLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC4KZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7CiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTsKfQoKUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkgewogIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlOwp9OwoKLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuClJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHsKICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSBfZGVyZXFfKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyOwogIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7CiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYzsKICByZXR1cm4gdGhpczsKfTsKCi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUIKdmFyIE1BWF9IV00gPSAweDgwMDAwMDsKZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikgewogIGlmIChuID49IE1BWF9IV00pIHsKICAgIG4gPSBNQVhfSFdNOwogIH0gZWxzZSB7CiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW4KICAgIC8vIHRpbnkgYW1vdW50cwogICAgbi0tOwogICAgbiB8PSBuID4+PiAxOwogICAgbiB8PSBuID4+PiAyOwogICAgbiB8PSBuID4+PiA0OwogICAgbiB8PSBuID4+PiA4OwogICAgbiB8PSBuID4+PiAxNjsKICAgIG4rKzsKICB9CiAgcmV0dXJuIG47Cn0KCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHsKICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7CiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxOwogIGlmIChuICE9PSBuKSB7CiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWUKICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDsKICB9CiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uCiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7CiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsKICAvLyBEb24ndCBoYXZlIGVub3VnaAogIGlmICghc3RhdGUuZW5kZWQpIHsKICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICByZXR1cm4gMDsKICB9CiAgcmV0dXJuIHN0YXRlLmxlbmd0aDsKfQoKLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy4KUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikgewogIGRlYnVnKCdyZWFkJywgbik7CiAgbiA9IHBhcnNlSW50KG4sIDEwKTsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIHZhciBuT3JpZyA9IG47CgogIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKCiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZQogIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXIKICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi4KICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkgewogICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpOwogICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsKCiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLgogIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7CiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTsKICAgIHJldHVybiBudWxsOwogIH0KCiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZQogIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpbgogIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWQKICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlCiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW4KICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC4KICAvLwogIC8vIFNvLCB0aGUgc3RlcHMgYXJlOgogIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG8KICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLgogIC8vCiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC4KICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXMKICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW4KICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlCiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy4KICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGwKICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0CiAgLy8gJ3JlYWRhYmxlJyBldGMuCiAgLy8KICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uCgogIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy4KICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlOwogIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsKCiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykgewogICAgZG9SZWFkID0gdHJ1ZTsKICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7CiAgfQoKICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeQogIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS4KICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykgewogICAgZG9SZWFkID0gZmFsc2U7CiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7CiAgfSBlbHNlIGlmIChkb1JlYWQpIHsKICAgIGRlYnVnKCdkbyByZWFkJyk7CiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTsKICAgIHN0YXRlLnN5bmMgPSB0cnVlOwogICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC4KICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kCiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspOwogICAgc3RhdGUuc3luYyA9IGZhbHNlOwogICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSwKICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci4KICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTsKICB9CgogIHZhciByZXQ7CiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsOwoKICBpZiAocmV0ID09PSBudWxsKSB7CiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgbiA9IDA7CiAgfSBlbHNlIHsKICAgIHN0YXRlLmxlbmd0aCAtPSBuOwogIH0KCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93CiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuCiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoKICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay4KICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7CiAgfQoKICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpOwoKICByZXR1cm4gcmV0Owp9OwoKZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47CiAgaWYgKHN0YXRlLmRlY29kZXIpIHsKICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7CiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7CiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTsKICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgfQogIH0KICBzdGF0ZS5lbmRlZCA9IHRydWU7CgogIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLgogIGVtaXRSZWFkYWJsZShzdHJlYW0pOwp9CgovLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXIKLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyCi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC4KZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkgewogIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTsKICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkgewogICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpOwogICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTsKICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTsKICB9Cn0KCmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7CiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTsKICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTsKICBmbG93KHN0cmVhbSk7Cn0KCi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsCi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWQKLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWYKLy8gaXQncyBpbiBwcm9ncmVzcy4KLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSwKLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS4KZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkgewogICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlOwogICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTsKICB9Cn0KCmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHsKICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoOwogIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykgewogICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkKICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy4KICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7CiAgfQogIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7Cn0KCi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy4KLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC4KLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsICJsZW5ndGgiIGlzIHNvbWV3aGF0Ci8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC4KUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTsKfTsKClJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7CiAgdmFyIHNyYyA9IHRoaXM7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKCiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7CiAgICBjYXNlIDA6CiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDsKICAgICAgYnJlYWs7CiAgICBjYXNlIDE6CiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTsKICAgICAgYnJlYWs7CiAgICBkZWZhdWx0OgogICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpOwogICAgICBicmVhazsKICB9CiAgc3RhdGUucGlwZXNDb3VudCArPSAxOwogIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7CgogIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7CgogIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7CiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pOwoKICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7CiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHsKICAgIGRlYnVnKCdvbnVucGlwZScpOwogICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHsKICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkgewogICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7CiAgICAgICAgY2xlYW51cCgpOwogICAgICB9CiAgICB9CiAgfQoKICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgIGRlYnVnKCdvbmVuZCcpOwogICAgZGVzdC5lbmQoKTsKICB9CgogIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXIKICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKCkKICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpcwogIC8vIHRvbyBzbG93LgogIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTsKICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pOwoKICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7CiAgZnVuY3Rpb24gY2xlYW51cCgpIHsKICAgIGRlYnVnKCdjbGVhbnVwJyk7CiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuCiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7CiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7CgogICAgY2xlYW5lZFVwID0gdHJ1ZTsKCiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzCiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnQKICAgIC8vIGZsb3dpbmcgYWdhaW4uCiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuCiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuCiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7CiAgfQoKICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cAogIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlCiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy4KICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uCiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTsKICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpOwogIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykgewogICAgZGVidWcoJ29uZGF0YScpOwogICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlOwogICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspOwogICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHsKICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlCiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlCiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuCiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLgogICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7CiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTsKICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrOwogICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlOwogICAgICB9CiAgICAgIHNyYy5wYXVzZSgpOwogICAgfQogIH0KCiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuCiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLgogIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHsKICAgIGRlYnVnKCdvbmVycm9yJywgZXIpOwogICAgdW5waXBlKCk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwogICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTsKICB9CgogIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy4KICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7CgogIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuCiAgZnVuY3Rpb24gb25jbG9zZSgpIHsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKICAgIHVucGlwZSgpOwogIH0KICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7CiAgZnVuY3Rpb24gb25maW5pc2goKSB7CiAgICBkZWJ1Zygnb25maW5pc2gnKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7CiAgICB1bnBpcGUoKTsKICB9CiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7CgogIGZ1bmN0aW9uIHVucGlwZSgpIHsKICAgIGRlYnVnKCd1bnBpcGUnKTsKICAgIHNyYy51bnBpcGUoZGVzdCk7CiAgfQoKICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0bwogIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7CgogIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS4KICBpZiAoIXN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpOwogICAgc3JjLnJlc3VtZSgpOwogIH0KCiAgcmV0dXJuIGRlc3Q7Cn07CgpmdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHsKICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlOwogICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7CiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tOwogICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkgewogICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsKICAgICAgZmxvdyhzcmMpOwogICAgfQogIH07Cn0KClJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkgewogIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07CgogIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy4KICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7CgogIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS4KICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgewogICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuCiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7CgogICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7CgogICAgLy8gZ290IGEgbWF0Y2guCiAgICBzdGF0ZS5waXBlcyA9IG51bGw7CiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDsKICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLgoKICBpZiAoIWRlc3QpIHsKICAgIC8vIHJlbW92ZSBhbGwuCiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlczsKICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50OwogICAgc3RhdGUucGlwZXMgPSBudWxsOwogICAgc3RhdGUucGlwZXNDb3VudCA9IDA7CiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTsKICAgIH1yZXR1cm4gdGhpczsKICB9CgogIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuCiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7CiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7CgogIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7CiAgc3RhdGUucGlwZXNDb3VudCAtPSAxOwogIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdOwoKICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwoKICByZXR1cm4gdGhpczsKfTsKCi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3IKLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmcKUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikgewogIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTsKCiAgaWYgKGV2ID09PSAnZGF0YScpIHsKICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZAogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7CiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykgewogICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHsKICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7CiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpOwogICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkgewogICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIHJlczsKfTsKUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uOwoKZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7CiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpOwogIHNlbGYucmVhZCgwKTsKfQoKLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSQovLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuClJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICBpZiAoIXN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdyZXN1bWUnKTsKICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOwogICAgcmVzdW1lKHRoaXMsIHN0YXRlKTsKICB9CiAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkgewogIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7CiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlOwogICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpOwogIH0KfQoKZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7CiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpOwogICAgc3RyZWFtLnJlYWQoMCk7CiAgfQoKICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTsKICBzdGF0ZS5hd2FpdERyYWluID0gMDsKICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7CiAgZmxvdyhzdHJlYW0pOwogIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTsKfQoKUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgewogIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpOwogIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7CiAgICBkZWJ1ZygncGF1c2UnKTsKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlOwogICAgdGhpcy5lbWl0KCdwYXVzZScpOwogIH0KICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7CiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge30KfQoKLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS4KLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLgovLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS4KUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgdmFyIF90aGlzID0gdGhpczsKCiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgcGF1c2VkID0gZmFsc2U7CgogIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkgewogICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7CiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHsKICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTsKICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7CiAgICB9CgogICAgX3RoaXMucHVzaChudWxsKTsKICB9KTsKCiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7CiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7CiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsKCiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGUKICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjsKCiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7CiAgICBpZiAoIXJldCkgewogICAgICBwYXVzZWQgPSB0cnVlOwogICAgICBzdHJlYW0ucGF1c2UoKTsKICAgIH0KICB9KTsKCiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLgogIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLgogIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7CiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHsKICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTsKICAgICAgICB9OwogICAgICB9KGkpOwogICAgfQogIH0KCiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLgogIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7CiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTsKICB9CgogIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGUKICAvLyB1bmRlcmx5aW5nIHN0cmVhbS4KICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7CiAgICBpZiAocGF1c2VkKSB7CiAgICAgIHBhdXNlZCA9IGZhbHNlOwogICAgICBzdHJlYW0ucmVzdW1lKCk7CiAgICB9CiAgfTsKCiAgcmV0dXJuIHRoaXM7Cn07CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgewogIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlCiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluCiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsCiAgZW51bWVyYWJsZTogZmFsc2UsCiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrOwogIH0KfSk7CgovLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuClJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0OwoKLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLgovLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LgovLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwovLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgpmdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkgewogIC8vIG5vdGhpbmcgYnVmZmVyZWQKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDsKCiAgdmFyIHJldDsKICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHsKICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdAogICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpOwogICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7CiAgfSBlbHNlIHsKICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0CiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC4KLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHsKICB2YXIgcmV0OwogIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7CiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncwogICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7CiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pOwogIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7CiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2gKICAgIHJldCA9IGxpc3Quc2hpZnQoKTsKICB9IGVsc2UgewogICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyCiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTsKICB9CiAgcmV0dXJuIHJldDsKfQoKLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YQovLyBjaHVua3MuCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHsKICB2YXIgcCA9IGxpc3QuaGVhZDsKICB2YXIgYyA9IDE7CiAgdmFyIHJldCA9IHAuZGF0YTsKICBuIC09IHJldC5sZW5ndGg7CiAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgIHZhciBzdHIgPSBwLmRhdGE7CiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuOwogICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTsKICAgIG4gLT0gbmI7CiAgICBpZiAobiA9PT0gMCkgewogICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHsKICAgICAgICArK2M7CiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDsKICAgICAgfSBlbHNlIHsKICAgICAgICBsaXN0LmhlYWQgPSBwOwogICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7CiAgICAgIH0KICAgICAgYnJlYWs7CiAgICB9CiAgICArK2M7CiAgfQogIGxpc3QubGVuZ3RoIC09IGM7CiAgcmV0dXJuIHJldDsKfQoKLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLgovLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwovLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgpmdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7CiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTsKICB2YXIgcCA9IGxpc3QuaGVhZDsKICB2YXIgYyA9IDE7CiAgcC5kYXRhLmNvcHkocmV0KTsKICBuIC09IHAuZGF0YS5sZW5ndGg7CiAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgIHZhciBidWYgPSBwLmRhdGE7CiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuOwogICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpOwogICAgbiAtPSBuYjsKICAgIGlmIChuID09PSAwKSB7CiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkgewogICAgICAgICsrYzsKICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsOwogICAgICB9IGVsc2UgewogICAgICAgIGxpc3QuaGVhZCA9IHA7CiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTsKICAgICAgfQogICAgICBicmVhazsKICAgIH0KICAgICsrYzsKICB9CiAgbGlzdC5sZW5ndGggLT0gYzsKICByZXR1cm4gcmV0Owp9CgpmdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CgogIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGEKICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uCiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignImVuZFJlYWRhYmxlKCkiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7CgogIGlmICghc3RhdGUuZW5kRW1pdHRlZCkgewogICAgc3RhdGUuZW5kZWQgPSB0cnVlOwogICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pOwogIH0KfQoKZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7CiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuCiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7CiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTsKICAgIHN0cmVhbS5lbWl0KCdlbmQnKTsKICB9Cn0KCmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHsKICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTsKICB9CiAgcmV0dXJuIC0xOwp9Cn0pLmNhbGwodGhpcyxfZGVyZXFfKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCgp9LHsiLi9fc3RyZWFtX2R1cGxleCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0iOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJfcHJvY2VzcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcHJvY2Vzc0AwLjExLjEwQHByb2Nlc3MvYnJvd3Nlci5qcyIsImNvcmUtdXRpbC1pcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fY29yZS11dGlsLWlzQDEuMC4yQGNvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsImV2ZW50cyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fZXZlbnRzQDIuMS4wQGV2ZW50cy9ldmVudHMuanMiLCJpbmhlcml0cyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9faW5oZXJpdHNAMi4wLjNAaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsImlzYXJyYXkiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2lzYXJyYXlAMS4wLjBAaXNhcnJheS9pbmRleC5qcyIsInByb2Nlc3MtbmV4dGljay1hcmdzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19wcm9jZXNzLW5leHRpY2stYXJnc0AyLjAuMEBwcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsInNhZmUtYnVmZmVyIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19zYWZlLWJ1ZmZlckA1LjEuMkBzYWZlLWJ1ZmZlci9pbmRleC5qcyIsInN0cmluZ19kZWNvZGVyLyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fc3RyaW5nX2RlY29kZXJAMS4xLjFAc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwidXRpbCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYnJvd3Nlci1yZXNvbHZlQDEuMTEuMkBicm93c2VyLXJlc29sdmUvZW1wdHkuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkbwovLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhICJmaWx0ZXIiLAovLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZQovLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkCi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLikKLy8KLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYQovLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSwKLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuCi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS4KLy8KLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOgovLwovLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGUKLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKQovLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzCi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWwKLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLgovLwovLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlbgovLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZQovLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGUKLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3QKLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvCi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS4KLy8KLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLAovLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLAovLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nCi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzCi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnkKLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpbgovLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGwKLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJbgovLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGwKLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGQKLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS4KLy8KLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVuawovLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsCi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLgoKJ3VzZSBzdHJpY3QnOwoKbW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07Cgp2YXIgRHVwbGV4ID0gX2RlcmVxXygnLi9fc3RyZWFtX2R1cGxleCcpOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTsKdXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKdXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7CgpmdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkgewogIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlOwogIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlOwoKICB2YXIgY2IgPSB0cy53cml0ZWNiOwoKICBpZiAoIWNiKSB7CiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpOwogIH0KCiAgdHMud3JpdGVjaHVuayA9IG51bGw7CiAgdHMud3JpdGVjYiA9IG51bGw7CgogIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYAogICAgdGhpcy5wdXNoKGRhdGEpOwoKICBjYihlcik7CgogIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgcnMucmVhZGluZyA9IGZhbHNlOwogIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgewogICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTsKICB9Cn0KCmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpOwoKICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTsKCiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7CiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSwKICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLAogICAgdHJhbnNmb3JtaW5nOiBmYWxzZSwKICAgIHdyaXRlY2I6IG51bGwsCiAgICB3cml0ZWNodW5rOiBudWxsLAogICAgd3JpdGVlbmNvZGluZzogbnVsbAogIH07CgogIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLgogIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKCiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzCiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZQogIC8vIHN5bmMgZ3VhcmQgZmxhZy4KICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTsKCiAgaWYgKG9wdGlvbnMpIHsKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtOwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoOwogIH0KCiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLgogIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7Cn0KCmZ1bmN0aW9uIHByZWZpbmlzaCgpIHsKICB2YXIgX3RoaXMgPSB0aGlzOwoKICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7CiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHsKICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpOwogICAgfSk7CiAgfSBlbHNlIHsKICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7CiAgfQp9CgpUcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7CiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlOwogIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpOwp9OwoKLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhCi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy4KLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay4KLy8KLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0Ci8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuCi8vCi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzCi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3UKLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay4KVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTsKfTsKClRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTsKICB0cy53cml0ZWNiID0gY2I7CiAgdHMud3JpdGVjaHVuayA9IGNodW5rOwogIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZzsKICBpZiAoIXRzLnRyYW5zZm9ybWluZykgewogICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspOwogIH0KfTsKCi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuCi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuCi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuClRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikgewogIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlOwoKICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHsKICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7CiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pOwogIH0gZWxzZSB7CiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluCiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC4KICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlOwogIH0KfTsKClRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikgewogIHZhciBfdGhpczIgPSB0aGlzOwoKICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikgewogICAgY2IoZXJyMik7CiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTsKICB9KTsKfTsKCmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkgewogIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKCiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgCiAgICBzdHJlYW0ucHVzaChkYXRhKTsKCiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFucwogIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZAogIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpOwoKICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpOwoKICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7Cn0KfSx7Ii4vX3N0cmVhbV9kdXBsZXgiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiY29yZS11dGlsLWlzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLXV0aWwtaXNAMS4wLjJAY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwiaW5oZXJpdHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2luaGVyaXRzQDIuMC4zQGluaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLHNldEltbWVkaWF0ZSl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLgovLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGwKLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIHBuYSA9IF9kZXJlcV8oJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKbW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTsKCi8qIDxyZXBsYWNlbWVudD4gKi8KZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHRoaXMuY2h1bmsgPSBjaHVuazsKICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7CiAgdGhpcy5jYWxsYmFjayA9IGNiOwogIHRoaXMubmV4dCA9IG51bGw7Cn0KCi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdAovLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW0KZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIHRoaXMubmV4dCA9IG51bGw7CiAgdGhpcy5lbnRyeSA9IG51bGw7CiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7CiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpOwogIH07Cn0KLyogPC9yZXBsYWNlbWVudD4gKi8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIER1cGxleDsKLyo8L3JlcGxhY2VtZW50PiovCgpXcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBpbnRlcm5hbFV0aWwgPSB7CiAgZGVwcmVjYXRlOiBfZGVyZXFfKCd1dGlsLWRlcHJlY2F0ZScpCn07Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIFN0cmVhbSA9IF9kZXJlcV8oJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwp2YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9OwpmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7CiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTsKfQpmdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikgewogIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5Owp9CgovKjwvcmVwbGFjZW1lbnQ+Ki8KCnZhciBkZXN0cm95SW1wbCA9IF9kZXJlcV8oJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7Cgp1dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pOwoKZnVuY3Rpb24gbm9wKCkge30KCmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7CiAgRHVwbGV4ID0gRHVwbGV4IHx8IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTsKCiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CgogIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlCiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuCiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnQKICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLgogIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLgogIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsKCiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtCiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLgogIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlOwoKICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOwoKICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlCiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWYKICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpCiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyazsKICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyazsKICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0OwoKICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTsKCiAgLy8gY2FzdCB0byBpbnRzLgogIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTsKCiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZAogIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsKCiAgLy8gZHJhaW4gZXZlbnQgZmxhZy4KICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOwogIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpCiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsKICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkCiAgdGhpcy5lbmRlZCA9IGZhbHNlOwogIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZAogIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsKCiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkCiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsKCiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/CiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nCiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC4KICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlOwogIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsKCiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZwogIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS4KICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guCiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7CgogIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50CiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZwogIC8vIHNvY2tldCBvciBmaWxlLgogIHRoaXMubGVuZ3RoID0gMDsKCiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS4KICB0aGlzLndyaXRpbmcgPSBmYWxzZTsKCiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbAogIHRoaXMuY29ya2VkID0gMDsKCiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksCiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnkKICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCAibGF0ZXIiIHNob3VsZCBnZW5lcmFsbHkgYWxzbwogIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLgogIHRoaXMuc3luYyA9IHRydWU7CgogIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2gKICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndAogIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLgogIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOwoKICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpCiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7CiAgICBvbndyaXRlKHN0cmVhbSwgZXIpOwogIH07CgogIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKQogIHRoaXMud3JpdGVjYiA9IG51bGw7CgogIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC4KICB0aGlzLndyaXRlbGVuID0gMDsKCiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsOwogIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CgogIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzCiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkCiAgdGhpcy5wZW5kaW5nY2IgPSAwOwoKICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzCiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXMKICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7CgogIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluCiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsKCiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHMKICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsKCiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5cwogIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d28KICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpOwp9CgpXcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7CiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDsKICB2YXIgb3V0ID0gW107CiAgd2hpbGUgKGN1cnJlbnQpIHsKICAgIG91dC5wdXNoKGN1cnJlbnQpOwogICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDsKICB9CiAgcmV0dXJuIG91dDsKfTsKCihmdW5jdGlvbiAoKSB7CiAgdHJ5IHsKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHsKICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTsKICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpCiAgICB9KTsKICB9IGNhdGNoIChfKSB7fQp9KSgpOwoKLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsCi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS4KdmFyIHJlYWxIYXNJbnN0YW5jZTsKaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykgewogIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdOwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7CiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkgewogICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7CiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlOwoKICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlOwogICAgfQogIH0pOwp9IGVsc2UgewogIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHsKICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzOwogIH07Cn0KCmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHsKICBEdXBsZXggPSBEdXBsZXggfHwgX2RlcmVxXygnLi9fc3RyZWFtX2R1cGxleCcpOwoKICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby4KICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmAKICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuCgogIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZQogIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvcgogIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi4KICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7CiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpOwogIH0KCiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpOwoKICAvLyBsZWdhY3kuCiAgdGhpcy53cml0YWJsZSA9IHRydWU7CgogIGlmIChvcHRpb25zKSB7CiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTsKCiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjsKCiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTsKCiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDsKICB9CgogIFN0cmVhbS5jYWxsKHRoaXMpOwp9CgovLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuCldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkgewogIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7Cn07CgpmdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHsKICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpOwogIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiCiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwogIHBuYS5uZXh0VGljayhjYiwgZXIpOwp9CgovLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyCi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWQKLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLgpmdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikgewogIHZhciB2YWxpZCA9IHRydWU7CiAgdmFyIGVyID0gZmFsc2U7CgogIGlmIChjaHVuayA9PT0gbnVsbCkgewogICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpOwogIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7CiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTsKICB9CiAgaWYgKGVyKSB7CiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTsKICAgIHZhbGlkID0gZmFsc2U7CiAgfQogIHJldHVybiB2YWxpZDsKfQoKV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlOwogIHZhciByZXQgPSBmYWxzZTsKICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTsKCiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7CiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspOwogIH0KCiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykgewogICAgY2IgPSBlbmNvZGluZzsKICAgIGVuY29kaW5nID0gbnVsbDsKICB9CgogIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nOwoKICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDsKCiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7CiAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTsKICB9CgogIHJldHVybiByZXQ7Cn07CgpXcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlOwoKICBzdGF0ZS5jb3JrZWQrKzsKfTsKCldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKCiAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgc3RhdGUuY29ya2VkLS07CgogICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpOwogIH0KfTsKCldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHsKICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS4KICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpOwogIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7CiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZzsKICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHsKICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykgewogICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpOwogIH0KICByZXR1cm4gY2h1bms7Cn0KCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7CiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGUKICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW4KICAvLyB1c2VybGFuZCB3aWxsIGZhaWwKICBlbnVtZXJhYmxlOiBmYWxzZSwKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7CiAgfQp9KTsKCi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpcwovLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZQovLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLgpmdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgaWYgKCFpc0J1ZikgewogICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7CiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7CiAgICAgIGlzQnVmID0gdHJ1ZTsKICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJzsKICAgICAgY2h1bmsgPSBuZXdDaHVuazsKICAgIH0KICB9CiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwoKICBzdGF0ZS5sZW5ndGggKz0gbGVuOwoKICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsKICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS4KICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTsKCiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7CiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7CiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gewogICAgICBjaHVuazogY2h1bmssCiAgICAgIGVuY29kaW5nOiBlbmNvZGluZywKICAgICAgaXNCdWY6IGlzQnVmLAogICAgICBjYWxsYmFjazogY2IsCiAgICAgIG5leHQ6IG51bGwKICAgIH07CiAgICBpZiAobGFzdCkgewogICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwogICAgfSBlbHNlIHsKICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKICAgIH0KICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7CiAgfSBlbHNlIHsKICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgfQoKICByZXR1cm4gcmV0Owp9CgpmdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgc3RhdGUud3JpdGVsZW4gPSBsZW47CiAgc3RhdGUud3JpdGVjYiA9IGNiOwogIHN0YXRlLndyaXRpbmcgPSB0cnVlOwogIHN0YXRlLnN5bmMgPSB0cnVlOwogIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTsKICBzdGF0ZS5zeW5jID0gZmFsc2U7Cn0KCmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHsKICAtLXN0YXRlLnBlbmRpbmdjYjsKCiAgaWYgKHN5bmMpIHsKICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHkKICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrCiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTsKICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuCiAgICAvLyBhZnRlciBlcnJvcgogICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTsKICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlOwogICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwogIH0gZWxzZSB7CiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWYKICAgIC8vIGl0IGlzIGFzeW5jCiAgICBjYihlcik7CiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTsKICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3QKICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3IKICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwogIH0KfQoKZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7CiAgc3RhdGUud3JpdGluZyA9IGZhbHNlOwogIHN0YXRlLndyaXRlY2IgPSBudWxsOwogIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjsKICBzdGF0ZS53cml0ZWxlbiA9IDA7Cn0KCmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikgewogIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7CiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjsKCiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTsKCiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHsKICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0CiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTsKCiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7CiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpOwogICAgfQoKICAgIGlmIChzeW5jKSB7CiAgICAgIC8qPHJlcGxhY2VtZW50PiovCiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTsKICAgICAgLyo8L3JlcGxhY2VtZW50PiovCiAgICB9IGVsc2UgewogICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikgewogIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTsKICBzdGF0ZS5wZW5kaW5nY2ItLTsKICBjYigpOwogIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwp9CgovLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndAovLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuCi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuCmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHsKICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlOwogICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7CiAgfQp9CgovLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdApmdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7CiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7CiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0OwoKICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkgewogICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKQogICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDsKICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7CiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlOwogICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7CgogICAgdmFyIGNvdW50ID0gMDsKICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTsKICAgIHdoaWxlIChlbnRyeSkgewogICAgICBidWZmZXJbY291bnRdID0gZW50cnk7CiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTsKICAgICAgZW50cnkgPSBlbnRyeS5uZXh0OwogICAgICBjb3VudCArPSAxOwogICAgfQogICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzOwoKICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsKCiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZQogICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlCiAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOwogICAgaWYgKGhvbGRlci5uZXh0KSB7CiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0OwogICAgICBob2xkZXIubmV4dCA9IG51bGw7CiAgICB9IGVsc2UgewogICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7CiAgICB9CiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7CiAgfSBlbHNlIHsKICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmUKICAgIHdoaWxlIChlbnRyeSkgewogICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuazsKICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7CiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrOwogICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CgogICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpOwogICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07CiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuCiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuCiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHkKICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uCiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KCiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOwogIH0KCiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7CiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOwp9CgpXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTsKfTsKCldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDsKCldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CgogIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHsKICAgIGNiID0gY2h1bms7CiAgICBjaHVuayA9IG51bGw7CiAgICBlbmNvZGluZyA9IG51bGw7CiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHsKICAgIGNiID0gZW5jb2Rpbmc7CiAgICBlbmNvZGluZyA9IG51bGw7CiAgfQoKICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOwoKICAvLyAuZW5kKCkgZnVsbHkgdW5jb3JrcwogIGlmIChzdGF0ZS5jb3JrZWQpIHsKICAgIHN0YXRlLmNvcmtlZCA9IDE7CiAgICB0aGlzLnVuY29yaygpOwogIH0KCiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLgogIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTsKfTsKCmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHsKICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nOwp9CmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7CiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7CiAgICBzdGF0ZS5wZW5kaW5nY2ItLTsKICAgIGlmIChlcnIpIHsKICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTsKICAgIH0KICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTsKICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTsKICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwogIH0pOwp9CmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHsKICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlOwogICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTsKICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpOwogICAgfQogIH0KfQoKZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkgewogIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7CiAgaWYgKG5lZWQpIHsKICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTsKICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHsKICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlOwogICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7CiAgICB9CiAgfQogIHJldHVybiBuZWVkOwp9CgpmdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikgewogIHN0YXRlLmVuZGluZyA9IHRydWU7CiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgaWYgKGNiKSB7CiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpOwogIH0KICBzdGF0ZS5lbmRlZCA9IHRydWU7CiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7Cn0KCmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHsKICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5OwogIGNvcmtSZXEuZW50cnkgPSBudWxsOwogIHdoaWxlIChlbnRyeSkgewogICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7CiAgICBzdGF0ZS5wZW5kaW5nY2ItLTsKICAgIGNiKGVycik7CiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CiAgfQogIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHsKICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTsKICB9IGVsc2UgewogICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTsKICB9Cn0KCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7CiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKICB9LAogIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW0KICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQKICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseQogICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkCiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogIH0KfSk7CgpXcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7CldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95OwpXcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikgewogIHRoaXMuZW5kKCk7CiAgY2IoZXJyKTsKfTsKfSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSxfZGVyZXFfKCJ0aW1lcnMiKS5zZXRJbW1lZGlhdGUpCgp9LHsiLi9fc3RyZWFtX2R1cGxleCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIl9wcm9jZXNzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19wcm9jZXNzQDAuMTEuMTBAcHJvY2Vzcy9icm93c2VyLmpzIiwiY29yZS11dGlsLWlzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19jb3JlLXV0aWwtaXNAMS4wLjJAY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwiaW5oZXJpdHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2luaGVyaXRzQDIuMC4zQGluaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJwcm9jZXNzLW5leHRpY2stYXJncyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcHJvY2Vzcy1uZXh0aWNrLWFyZ3NAMi4wLjBAcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJzYWZlLWJ1ZmZlciI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fc2FmZS1idWZmZXJANS4xLjJAc2FmZS1idWZmZXIvaW5kZXguanMiLCJ0aW1lcnMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3RpbWVycy1icm93c2VyaWZ5QDEuNC4yQHRpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ1dGlsLWRlcHJlY2F0ZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fdXRpbC1kZXByZWNhdGVAMS4wLjJAdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwoKZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsgfSB9Cgp2YXIgQnVmZmVyID0gX2RlcmVxXygnc2FmZS1idWZmZXInKS5CdWZmZXI7CnZhciB1dGlsID0gX2RlcmVxXygndXRpbCcpOwoKZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7CiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpOwp9Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpOwoKICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICB0aGlzLnRhaWwgPSBudWxsOwogICAgdGhpcy5sZW5ndGggPSAwOwogIH0KCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikgewogICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07CiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7CiAgICB0aGlzLnRhaWwgPSBlbnRyeTsKICAgICsrdGhpcy5sZW5ndGg7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikgewogICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7CiAgICB0aGlzLmhlYWQgPSBlbnRyeTsKICAgICsrdGhpcy5sZW5ndGg7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOwogICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhOwogICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7CiAgICAtLXRoaXMubGVuZ3RoOwogICAgcmV0dXJuIHJldDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkgewogICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDsKICAgIHRoaXMubGVuZ3RoID0gMDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJzsKICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgdmFyIHJldCA9ICcnICsgcC5kYXRhOwogICAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7CiAgICB9cmV0dXJuIHJldDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikgewogICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApOwogICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7CiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApOwogICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICB2YXIgaSA9IDA7CiAgICB3aGlsZSAocCkgewogICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTsKICAgICAgaSArPSBwLmRhdGEubGVuZ3RoOwogICAgICBwID0gcC5uZXh0OwogICAgfQogICAgcmV0dXJuIHJldDsKICB9OwoKICByZXR1cm4gQnVmZmVyTGlzdDsKfSgpOwoKaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHsKICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7CiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTsKICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7CiAgfTsKfQp9LHsic2FmZS1idWZmZXIiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3NhZmUtYnVmZmVyQDUuMS4yQHNhZmUtYnVmZmVyL2luZGV4LmpzIiwidXRpbCI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fYnJvd3Nlci1yZXNvbHZlQDEuMTEuMkBicm93c2VyLXJlc29sdmUvZW1wdHkuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcG5hID0gX2RlcmVxXygncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJCmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKCiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7CiAgICBpZiAoY2IpIHsKICAgICAgY2IoZXJyKTsKICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7CiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTsKICAgIH0KICAgIHJldHVybiB0aGlzOwogIH0KCiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyCiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzCgogIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7CiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7CiAgfQoKICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsCiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTsKICB9CgogIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHsKICAgIGlmICghY2IgJiYgZXJyKSB7CiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7CiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoY2IpIHsKICAgICAgY2IoZXJyKTsKICAgIH0KICB9KTsKCiAgcmV0dXJuIHRoaXM7Cn0KCmZ1bmN0aW9uIHVuZGVzdHJveSgpIHsKICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7CiAgfQoKICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlOwogIH0KfQoKZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7CiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7Cn0KCm1vZHVsZS5leHBvcnRzID0gewogIGRlc3Ryb3k6IGRlc3Ryb3ksCiAgdW5kZXN0cm95OiB1bmRlc3Ryb3kKfTsKfSx7InByb2Nlc3MtbmV4dGljay1hcmdzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19wcm9jZXNzLW5leHRpY2stYXJnc0AyLjAuMEBwcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyOwoKfSx7ImV2ZW50cyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fZXZlbnRzQDIuMS4wQGV2ZW50cy9ldmVudHMuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaAoKfSx7Ii4vcmVhZGFibGUiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpOwpleHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7CmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzOwpleHBvcnRzLldyaXRhYmxlID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpOwpleHBvcnRzLkR1cGxleCA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7CmV4cG9ydHMuVHJhbnNmb3JtID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTsKZXhwb3J0cy5QYXNzVGhyb3VnaCA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTsKCn0seyIuL2xpYi9fc3RyZWFtX2R1cGxleC5qcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtCgp9LHsiLi9yZWFkYWJsZSI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3JlYWRhYmxlLXN0cmVhbUAyLjMuNkByZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTsKCn0seyIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3NhZmUtYnVmZmVyQDUuMS4yQHNhZmUtYnVmZmVyL2luZGV4LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi8KdmFyIGJ1ZmZlciA9IF9kZXJlcV8oJ2J1ZmZlcicpCnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyCgovLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzCmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHsKICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7CiAgICBkc3Rba2V5XSA9IHNyY1trZXldCiAgfQp9CmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHsKICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlcgp9IGVsc2UgewogIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpCiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cykKICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXIKfQoKZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQp9CgovLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyCmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpCgpTYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJykKICB9CiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0KICB2YXIgYnVmID0gQnVmZmVyKHNpemUpCiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkgewogICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHsKICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpCiAgICB9IGVsc2UgewogICAgICBidWYuZmlsbChmaWxsKQogICAgfQogIH0gZWxzZSB7CiAgICBidWYuZmlsbCgwKQogIH0KICByZXR1cm4gYnVmCn0KClNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0KICByZXR1cm4gQnVmZmVyKHNpemUpCn0KClNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHsKICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJykKICB9CiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpCn0KCn0seyJidWZmZXIiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2J1ZmZlckA1LjEuMEBidWZmZXIvaW5kZXguanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fc3RyZWFtLWJyb3dzZXJpZnlAMi4wLjFAc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKbW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07Cgp2YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7CnZhciBpbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7Cgppbmhlcml0cyhTdHJlYW0sIEVFKTsKU3RyZWFtLlJlYWRhYmxlID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7ClN0cmVhbS5Xcml0YWJsZSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpOwpTdHJlYW0uRHVwbGV4ID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpOwpTdHJlYW0uVHJhbnNmb3JtID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpOwpTdHJlYW0uUGFzc1Rocm91Z2ggPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTsKCi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54ClN0cmVhbS5TdHJlYW0gPSBTdHJlYW07CgoKCi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnQKLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy4KCmZ1bmN0aW9uIFN0cmVhbSgpIHsKICBFRS5jYWxsKHRoaXMpOwp9CgpTdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7CiAgdmFyIHNvdXJjZSA9IHRoaXM7CgogIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykgewogICAgaWYgKGRlc3Qud3JpdGFibGUpIHsKICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHsKICAgICAgICBzb3VyY2UucGF1c2UoKTsKICAgICAgfQogICAgfQogIH0KCiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTsKCiAgZnVuY3Rpb24gb25kcmFpbigpIHsKICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkgewogICAgICBzb3VyY2UucmVzdW1lKCk7CiAgICB9CiAgfQoKICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pOwoKICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuCiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuCiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7CiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTsKICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTsKICB9CgogIHZhciBkaWRPbkVuZCA9IGZhbHNlOwogIGZ1bmN0aW9uIG9uZW5kKCkgewogICAgaWYgKGRpZE9uRW5kKSByZXR1cm47CiAgICBkaWRPbkVuZCA9IHRydWU7CgogICAgZGVzdC5lbmQoKTsKICB9CgoKICBmdW5jdGlvbiBvbmNsb3NlKCkgewogICAgaWYgKGRpZE9uRW5kKSByZXR1cm47CiAgICBkaWRPbkVuZCA9IHRydWU7CgogICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpOwogIH0KCiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLgogIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHsKICAgIGNsZWFudXAoKTsKICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7CiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuCiAgICB9CiAgfQoKICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7CiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTsKCiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC4KICBmdW5jdGlvbiBjbGVhbnVwKCkgewogICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7CgogICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7CiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7CgogICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTsKCiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApOwogICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApOwoKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7CiAgfQoKICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApOwogIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTsKCiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTsKCiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTsKCiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQykKICByZXR1cm4gZGVzdDsKfTsKCn0seyJldmVudHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2V2ZW50c0AyLjEuMEBldmVudHMvZXZlbnRzLmpzIiwiaW5oZXJpdHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2luaGVyaXRzQDIuMC4zQGluaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwicmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19yZWFkYWJsZS1zdHJlYW1AMi4zLjZAcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fcmVhZGFibGUtc3RyZWFtQDIuMy42QHJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3N0cmluZ19kZWNvZGVyQDEuMS4xQHN0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7CiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nOwogIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkgewogICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6CiAgICAgIHJldHVybiB0cnVlOwogICAgZGVmYXVsdDoKICAgICAgcmV0dXJuIGZhbHNlOwogIH0KfTsKCmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHsKICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JzsKICB2YXIgcmV0cmllZDsKICB3aGlsZSAodHJ1ZSkgewogICAgc3dpdGNoIChlbmMpIHsKICAgICAgY2FzZSAndXRmOCc6CiAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICByZXR1cm4gJ3V0ZjgnOwogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiAndXRmMTZsZSc7CiAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgcmV0dXJuICdsYXRpbjEnOwogICAgICBjYXNlICdiYXNlNjQnOgogICAgICBjYXNlICdhc2NpaSc6CiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGVuYzsKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWQKICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgcmV0cmllZCA9IHRydWU7CiAgICB9CiAgfQp9OwoKLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lCi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3MKZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7CiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTsKICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTsKICByZXR1cm4gbmVuYyB8fCBlbmM7Cn0KCi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2YKLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlCi8vIGNoYXJhY3RlcnMuCmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7CmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHsKICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpOwogIHZhciBuYjsKICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHsKICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7CiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7CiAgICAgIG5iID0gNDsKICAgICAgYnJlYWs7CiAgICBjYXNlICd1dGY4JzoKICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDsKICAgICAgbmIgPSA0OwogICAgICBicmVhazsKICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7CiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kOwogICAgICBuYiA9IDM7CiAgICAgIGJyZWFrOwogICAgZGVmYXVsdDoKICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlOwogICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDsKICAgICAgcmV0dXJuOwogIH0KICB0aGlzLmxhc3ROZWVkID0gMDsKICB0aGlzLmxhc3RUb3RhbCA9IDA7CiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7Cn0KClN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1ZikgewogIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7CiAgdmFyIHI7CiAgdmFyIGk7CiAgaWYgKHRoaXMubGFzdE5lZWQpIHsKICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7CiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7CiAgICBpID0gdGhpcy5sYXN0TmVlZDsKICAgIHRoaXMubGFzdE5lZWQgPSAwOwogIH0gZWxzZSB7CiAgICBpID0gMDsKICB9CiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpOwogIHJldHVybiByIHx8ICcnOwp9OwoKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDsKCi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyClN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDsKCi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7CiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewogICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTsKICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTsKICB9CiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTsKICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7Cn07CgovLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhCi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLgpmdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHsKICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDsKICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjsKfQoKLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhbgovLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KQovLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLgpmdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkgewogIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7CiAgaWYgKGogPCBpKSByZXR1cm4gMDsKICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgaWYgKG5iID49IDApIHsKICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7CiAgICByZXR1cm4gbmI7CiAgfQogIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7CiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgaWYgKG5iID49IDApIHsKICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7CiAgICByZXR1cm4gbmI7CiAgfQogIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7CiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgaWYgKG5iID49IDApIHsKICAgIGlmIChuYiA+IDApIHsKICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzOwogICAgfQogICAgcmV0dXJuIG5iOwogIH0KICByZXR1cm4gMDsKfQoKLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzCi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0Ci8vIG9uZSwgd2UgInJlcGxhY2UiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGgKLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2RpbmcKLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZQovLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLgovLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhCi8vIGxvb3AuCmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7CiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgc2VsZi5sYXN0TmVlZCA9IDA7CiAgICByZXR1cm4gJ1x1ZmZmZCc7CiAgfQogIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkgewogICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgICBzZWxmLmxhc3ROZWVkID0gMTsKICAgICAgcmV0dXJuICdcdWZmZmQnOwogICAgfQogICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7CiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHsKICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjsKICAgICAgICByZXR1cm4gJ1x1ZmZmZCc7CiAgICAgIH0KICAgIH0KICB9Cn0KCi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci4KZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1ZikgewogIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkOwogIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApOwogIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByOwogIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHsKICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpOwogICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpOwogIH0KICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTsKICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7Cn0KCi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYQovLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWQKLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuCmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkgewogIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTsKICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTsKICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsOwogIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7CiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTsKICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTsKfQoKLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWwKLy8gY2hhcmFjdGVyLgpmdW5jdGlvbiB1dGY4RW5kKGJ1ZikgewogIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJzsKICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXHVmZmZkJzsKICByZXR1cm4gcjsKfQoKLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW4KLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2gKLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvCi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuCmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHsKICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHsKICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7CiAgICBpZiAocikgewogICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpOwogICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHsKICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjsKICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7CiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07CiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gcjsKICB9CiAgdGhpcy5sYXN0TmVlZCA9IDE7CiAgdGhpcy5sYXN0VG90YWwgPSAyOwogIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwogIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7Cn0KCi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlCi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LgpmdW5jdGlvbiB1dGYxNkVuZChidWYpIHsKICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7CiAgaWYgKHRoaXMubGFzdE5lZWQpIHsKICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7CiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpOwogIH0KICByZXR1cm4gcjsKfQoKZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHsKICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzOwogIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTsKICB0aGlzLmxhc3ROZWVkID0gMyAtIG47CiAgdGhpcy5sYXN0VG90YWwgPSAzOwogIGlmIChuID09PSAxKSB7CiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICB9IGVsc2UgewogICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07CiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICB9CiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pOwp9CgpmdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7CiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwogIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTsKICByZXR1cm4gcjsKfQoKLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KQpmdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHsKICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOwp9CgpmdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7CiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7Cn0KfSx7InNhZmUtYnVmZmVyIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19zYWZlLWJ1ZmZlckA1LjEuMkBzYWZlLWJ1ZmZlci9pbmRleC5qcyJ9XSwiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL190aW1lcnMtYnJvd3NlcmlmeUAxLjQuMkB0aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoc2V0SW1tZWRpYXRlLGNsZWFySW1tZWRpYXRlKXsKdmFyIG5leHRUaWNrID0gX2RlcmVxXygncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7CnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTsKdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlOwp2YXIgaW1tZWRpYXRlSWRzID0ge307CnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwOwoKLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3MKCmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkgewogIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTsKfTsKZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkgewogIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpOwp9OwpleHBvcnRzLmNsZWFyVGltZW91dCA9CmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9OwoKZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikgewogIHRoaXMuX2lkID0gaWQ7CiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47Cn0KVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9OwpUaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkgewogIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTsKfTsKCi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLgpleHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7CiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpOwogIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7Cn07CgpleHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkgewogIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTsKICBpdGVtLl9pZGxlVGltZW91dCA9IC0xOwp9OwoKZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHsKICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7CgogIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0OwogIGlmIChtc2VjcyA+PSAwKSB7CiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7CiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpCiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7CiAgICB9LCBtc2Vjcyk7CiAgfQp9OwoKLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuCmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gImZ1bmN0aW9uIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7CiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7CiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwoKICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTsKCiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHsKICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7CiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2UKICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3UKICAgICAgaWYgKGFyZ3MpIHsKICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBmbi5jYWxsKG51bGwpOwogICAgICB9CiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZwogICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTsKICAgIH0KICB9KTsKCiAgcmV0dXJuIGlkOwp9OwoKZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gImZ1bmN0aW9uIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHsKICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTsKfTsKfSkuY2FsbCh0aGlzLF9kZXJlcV8oInRpbWVycyIpLnNldEltbWVkaWF0ZSxfZGVyZXFfKCJ0aW1lcnMiKS5jbGVhckltbWVkaWF0ZSkKCn0seyJwcm9jZXNzL2Jyb3dzZXIuanMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3Byb2Nlc3NAMC4xMS4xMEBwcm9jZXNzL2Jyb3dzZXIuanMiLCJ0aW1lcnMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3RpbWVycy1icm93c2VyaWZ5QDEuNC4yQHRpbWVycy1icm93c2VyaWZ5L21haW4uanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fdXRpbC1kZXByZWNhdGVAMS4wLjJAdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKGdsb2JhbCl7CgovKioKICogTW9kdWxlIGV4cG9ydHMuCiAqLwoKbW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7CgovKioKICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC4KICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC4KICoKICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuCiAqCiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9ucwogKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC4KICoKICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zCiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuCiAqCiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZQogKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZAogKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3ICJkZXByZWNhdGVkIiB2ZXJzaW9uIG9mIGBmbmAKICogQGFwaSBwdWJsaWMKICovCgpmdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHsKICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHsKICAgIHJldHVybiBmbjsKICB9CgogIHZhciB3YXJuZWQgPSBmYWxzZTsKICBmdW5jdGlvbiBkZXByZWNhdGVkKCkgewogICAgaWYgKCF3YXJuZWQpIHsKICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7CiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHsKICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7CiAgICAgIH0KICAgICAgd2FybmVkID0gdHJ1ZTsKICAgIH0KICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogIH0KCiAgcmV0dXJuIGRlcHJlY2F0ZWQ7Cn0KCi8qKgogKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLgogKgogKiBAcGFyYW0ge1N0cmluZ30gbmFtZQogKiBAcmV0dXJucyB7Qm9vbGVhbn0KICogQGFwaSBwcml2YXRlCiAqLwoKZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7CiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXMKICB0cnkgewogICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7CiAgfSBjYXRjaCAoXykgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTsKICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTsKICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnOwp9Cgp9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3V0aWxAMC4xMC4zQHV0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHsKICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnCiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbicKICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJwogICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7Cn0KfSx7fV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fdXRpbEAwLjEwLjNAdXRpbC91dGlsLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgp2YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZzsKZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7CiAgaWYgKCFpc1N0cmluZyhmKSkgewogICAgdmFyIG9iamVjdHMgPSBbXTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpOwogICAgfQogICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpOwogIH0KCiAgdmFyIGkgPSAxOwogIHZhciBhcmdzID0gYXJndW1lbnRzOwogIHZhciBsZW4gPSBhcmdzLmxlbmd0aDsKICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7CiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJzsKICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7CiAgICBzd2l0Y2ggKHgpIHsKICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7CiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pOwogICAgICBjYXNlICclaic6CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pOwogICAgICAgIH0gY2F0Y2ggKF8pIHsKICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7CiAgICAgICAgfQogICAgICBkZWZhdWx0OgogICAgICAgIHJldHVybiB4OwogICAgfQogIH0pOwogIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7CiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkgewogICAgICBzdHIgKz0gJyAnICsgeDsKICAgIH0gZWxzZSB7CiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpOwogICAgfQogIH0KICByZXR1cm4gc3RyOwp9OwoKCi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuCi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuCi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuCmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykgewogIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuCiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkgewogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH07CiAgfQoKICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7CiAgICByZXR1cm4gZm47CiAgfQoKICB2YXIgd2FybmVkID0gZmFsc2U7CiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHsKICAgIGlmICghd2FybmVkKSB7CiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTsKICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHsKICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpOwogICAgICB9CiAgICAgIHdhcm5lZCA9IHRydWU7CiAgICB9CiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICB9CgogIHJldHVybiBkZXByZWNhdGVkOwp9OwoKCnZhciBkZWJ1Z3MgPSB7fTsKdmFyIGRlYnVnRW52aXJvbjsKZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkgewogIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKQogICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJzsKICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTsKICBpZiAoIWRlYnVnc1tzZXRdKSB7CiAgICBpZiAobmV3IFJlZ0V4cCgnXFxiJyArIHNldCArICdcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkgewogICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7CiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7CiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7CiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7CiAgICAgIH07CiAgICB9IGVsc2UgewogICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307CiAgICB9CiAgfQogIHJldHVybiBkZWJ1Z3Nbc2V0XTsKfTsKCgovKioKICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dAogKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy4KICoKICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC4KICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC4KICovCi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi8KZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHsKICAvLyBkZWZhdWx0IG9wdGlvbnMKICB2YXIgY3R4ID0gewogICAgc2VlbjogW10sCiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvcgogIH07CiAgLy8gbGVnYWN5Li4uCiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdOwogIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107CiAgaWYgKGlzQm9vbGVhbihvcHRzKSkgewogICAgLy8gbGVnYWN5Li4uCiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7CiAgfSBlbHNlIGlmIChvcHRzKSB7CiAgICAvLyBnb3QgYW4gIm9wdGlvbnMiIG9iamVjdAogICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7CiAgfQogIC8vIHNldCBkZWZhdWx0IG9wdGlvbnMKICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlOwogIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyOwogIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlOwogIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTsKICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yOwogIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTsKfQpleHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0OwoKCi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljcwppbnNwZWN0LmNvbG9ycyA9IHsKICAnYm9sZCcgOiBbMSwgMjJdLAogICdpdGFsaWMnIDogWzMsIDIzXSwKICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sCiAgJ2ludmVyc2UnIDogWzcsIDI3XSwKICAnd2hpdGUnIDogWzM3LCAzOV0sCiAgJ2dyZXknIDogWzkwLCAzOV0sCiAgJ2JsYWNrJyA6IFszMCwgMzldLAogICdibHVlJyA6IFszNCwgMzldLAogICdjeWFuJyA6IFszNiwgMzldLAogICdncmVlbicgOiBbMzIsIDM5XSwKICAnbWFnZW50YScgOiBbMzUsIDM5XSwKICAncmVkJyA6IFszMSwgMzldLAogICd5ZWxsb3cnIDogWzMzLCAzOV0KfTsKCi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZQppbnNwZWN0LnN0eWxlcyA9IHsKICAnc3BlY2lhbCc6ICdjeWFuJywKICAnbnVtYmVyJzogJ3llbGxvdycsCiAgJ2Jvb2xlYW4nOiAneWVsbG93JywKICAndW5kZWZpbmVkJzogJ2dyZXknLAogICdudWxsJzogJ2JvbGQnLAogICdzdHJpbmcnOiAnZ3JlZW4nLAogICdkYXRlJzogJ21hZ2VudGEnLAogIC8vICJuYW1lIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZwogICdyZWdleHAnOiAncmVkJwp9OwoKCmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHsKICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdOwoKICBpZiAoc3R5bGUpIHsKICAgIHJldHVybiAnXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgKwogICAgICAgICAgICdcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJzsKICB9IGVsc2UgewogICAgcmV0dXJuIHN0cjsKICB9Cn0KCgpmdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkgewogIHJldHVybiBzdHI7Cn0KCgpmdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkgewogIHZhciBoYXNoID0ge307CgogIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHsKICAgIGhhc2hbdmFsXSA9IHRydWU7CiAgfSk7CgogIHJldHVybiBoYXNoOwp9CgoKZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7CiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLgogIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdAogIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJgogICAgICB2YWx1ZSAmJgogICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmCiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbAogICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiYKICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suCiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHsKICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTsKICAgIGlmICghaXNTdHJpbmcocmV0KSkgewogICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTsKICAgIH0KICAgIHJldHVybiByZXQ7CiAgfQoKICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllcwogIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7CiAgaWYgKHByaW1pdGl2ZSkgewogICAgcmV0dXJuIHByaW1pdGl2ZTsKICB9CgogIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC4KICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTsKICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTsKCiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7CiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpOwogIH0KCiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZQogIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4CiAgaWYgKGlzRXJyb3IodmFsdWUpCiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkgewogICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTsKICB9CgogIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC4KICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHsKICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkgewogICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnOwogICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpOwogICAgfQogICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkgewogICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpOwogICAgfQogICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpOwogICAgfQogICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7CiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7CiAgICB9CiAgfQoKICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddOwoKICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5CiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7CiAgICBhcnJheSA9IHRydWU7CiAgICBicmFjZXMgPSBbJ1snLCAnXSddOwogIH0KCiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zCiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7CiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnOwogICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7CiAgfQoKICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwcwogIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHsKICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpOwogIH0KCiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlCiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHsKICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTsKICB9CgogIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3IKICBpZiAoaXNFcnJvcih2YWx1ZSkpIHsKICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7CiAgfQoKICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHsKICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdOwogIH0KCiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHsKICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpOwogICAgfQogIH0KCiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7CgogIHZhciBvdXRwdXQ7CiAgaWYgKGFycmF5KSB7CiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTsKICB9IGVsc2UgewogICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7CiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTsKICAgIH0pOwogIH0KCiAgY3R4LnNlZW4ucG9wKCk7CgogIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7Cn0KCgpmdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkgewogIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpCiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTsKICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7CiAgICB2YXIgc2ltcGxlID0gJ1wnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eInwiJC9nLCAnJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgIlxcJyIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCIvZywgJyInKSArICdcJyc7CiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7CiAgfQogIGlmIChpc051bWJlcih2YWx1ZSkpCiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpOwogIGlmIChpc0Jvb2xlYW4odmFsdWUpKQogICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7CiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzICJvYmplY3QiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS4KICBpZiAoaXNOdWxsKHZhbHVlKSkKICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7Cn0KCgpmdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkgewogIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7Cn0KCgpmdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7CiAgdmFyIG91dHB1dCA9IFtdOwogIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7CiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHsKICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywKICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpOwogICAgfSBlbHNlIHsKICAgICAgb3V0cHV0LnB1c2goJycpOwogICAgfQogIH0KICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7CiAgICBpZiAoIWtleS5tYXRjaCgvXlxkKyQvKSkgewogICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLAogICAgICAgICAga2V5LCB0cnVlKSk7CiAgICB9CiAgfSk7CiAgcmV0dXJuIG91dHB1dDsKfQoKCmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHsKICB2YXIgbmFtZSwgc3RyLCBkZXNjOwogIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTsKICBpZiAoZGVzYy5nZXQpIHsKICAgIGlmIChkZXNjLnNldCkgewogICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTsKICAgIH0gZWxzZSB7CiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7CiAgICB9CiAgfSBlbHNlIHsKICAgIGlmIChkZXNjLnNldCkgewogICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpOwogICAgfQogIH0KICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7CiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nOwogIH0KICBpZiAoIXN0cikgewogICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7CiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkgewogICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTsKICAgICAgfQogICAgICBpZiAoc3RyLmluZGV4T2YoJ1xuJykgPiAtMSkgewogICAgICAgIGlmIChhcnJheSkgewogICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7CiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTsKICAgICAgICAgIH0pLmpvaW4oJ1xuJykuc3Vic3RyKDIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzdHIgPSAnXG4nICsgc3RyLnNwbGl0KCdcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7CiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7CiAgICAgICAgICB9KS5qb2luKCdcbicpOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpOwogICAgfQogIH0KICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHsKICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cZCskLykpIHsKICAgICAgcmV0dXJuIHN0cjsKICAgIH0KICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7CiAgICBpZiAobmFtZS5tYXRjaCgvXiIoW2EtekEtWl9dW2EtekEtWl8wLTldKikiJC8pKSB7CiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpOwogICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTsKICAgIH0gZWxzZSB7CiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgIlxcJyIpCiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcIi9nLCAnIicpCiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheInwiJCkvZywgIiciKTsKICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTsKICAgIH0KICB9CgogIHJldHVybiBuYW1lICsgJzogJyArIHN0cjsKfQoKCmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7CiAgdmFyIG51bUxpbmVzRXN0ID0gMDsKICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHsKICAgIG51bUxpbmVzRXN0Kys7CiAgICBpZiAoY3VyLmluZGV4T2YoJ1xuJykgPj0gMCkgbnVtTGluZXNFc3QrKzsKICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1x1MDAxYlxbXGRcZD9tL2csICcnKS5sZW5ndGggKyAxOwogIH0sIDApOwoKICBpZiAobGVuZ3RoID4gNjApIHsKICAgIHJldHVybiBicmFjZXNbMF0gKwogICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcbiAnKSArCiAgICAgICAgICAgJyAnICsKICAgICAgICAgICBvdXRwdXQuam9pbignLFxuICAnKSArCiAgICAgICAgICAgJyAnICsKICAgICAgICAgICBicmFjZXNbMV07CiAgfQoKICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdOwp9CgoKLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgCi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLgpmdW5jdGlvbiBpc0FycmF5KGFyKSB7CiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpOwp9CmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7CgpmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJzsKfQpleHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjsKCmZ1bmN0aW9uIGlzTnVsbChhcmcpIHsKICByZXR1cm4gYXJnID09PSBudWxsOwp9CmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsOwoKZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PSBudWxsOwp9CmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDsKCmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJzsKfQpleHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7CgpmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7Cn0KZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nOwoKZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnOwp9CmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDsKCmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT09IHZvaWQgMDsKfQpleHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7CgpmdW5jdGlvbiBpc1JlZ0V4cChyZSkgewogIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJzsKfQpleHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7CgpmdW5jdGlvbiBpc09iamVjdChhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsOwp9CmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDsKCmZ1bmN0aW9uIGlzRGF0ZShkKSB7CiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7Cn0KZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7CgpmdW5jdGlvbiBpc0Vycm9yKGUpIHsKICByZXR1cm4gaXNPYmplY3QoZSkgJiYKICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7Cn0KZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjsKCmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7Cn0KZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjsKCmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykgewogIHJldHVybiBhcmcgPT09IG51bGwgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sCiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnOwp9CmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTsKCmV4cG9ydHMuaXNCdWZmZXIgPSBfZGVyZXFfKCcuL3N1cHBvcnQvaXNCdWZmZXInKTsKCmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHsKICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pOwp9CgoKZnVuY3Rpb24gcGFkKG4pIHsKICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTsKfQoKCnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywKICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTsKCi8vIDI2IEZlYiAxNjoxOTozNApmdW5jdGlvbiB0aW1lc3RhbXAoKSB7CiAgdmFyIGQgPSBuZXcgRGF0ZSgpOwogIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLAogICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksCiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpOwogIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7Cn0KCgovLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wCmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7CiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7Cn07CgoKLyoqCiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci4KICoKICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZQogKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWQKICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmUKICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzCiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLgogKgogKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlCiAqICAgICBwcm90b3R5cGUuCiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLgogKi8KZXhwb3J0cy5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7CgpleHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkgewogIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3QKICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjsKCiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpOwogIHZhciBpID0ga2V5cy5sZW5ndGg7CiAgd2hpbGUgKGktLSkgewogICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dOwogIH0KICByZXR1cm4gb3JpZ2luOwp9OwoKZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7CiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOwp9Cgp9KS5jYWxsKHRoaXMsX2RlcmVxXygnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQoKfSx7Ii4vc3VwcG9ydC9pc0J1ZmZlciI6Ii9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fdXRpbEAwLjEwLjNAdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIl9wcm9jZXNzIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19wcm9jZXNzQDAuMTEuMTBAcHJvY2Vzcy9icm93c2VyLmpzIiwiaW5oZXJpdHMiOiIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX2luaGVyaXRzQDIuMC4xQGluaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMifV0sIi9Vc2Vycy9nYW5saW56aGVuL0Rlc2t0b3AvMTAtZ2l0aHVi6aG555uuL3NoYXJlbWV0YW1hc2svc2hhcmVNYXNrL25vZGVfbW9kdWxlcy9fd2ViM0AwLjIwLjZAd2ViMy9kaXN0L3dlYjMubWluLmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsLEJ1ZmZlcil7Cl9kZXJlcV89ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24gdChlLHIsbil7ZnVuY3Rpb24gbyhhLHMpe2lmKCFyW2FdKXtpZighZVthXSl7dmFyIGM9ImZ1bmN0aW9uIj09dHlwZW9mIF9kZXJlcV8mJl9kZXJlcV87aWYoIXMmJmMpcmV0dXJuIGMoYSwhMCk7aWYoaSlyZXR1cm4gaShhLCEwKTt2YXIgdT1uZXcgRXJyb3IoIkNhbm5vdCBmaW5kIG1vZHVsZSAnIithKyInIik7dGhyb3cgdS5jb2RlPSJNT0RVTEVfTk9UX0ZPVU5EIix1fXZhciBmPXJbYV09e2V4cG9ydHM6e319O2VbYV1bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24odCl7dmFyIHI9ZVthXVsxXVt0XTtyZXR1cm4gbyhyfHx0KX0sZixmLmV4cG9ydHMsdCxlLHIsbil9cmV0dXJuIHJbYV0uZXhwb3J0c31mb3IodmFyIGk9ImZ1bmN0aW9uIj09dHlwZW9mIF9kZXJlcV8mJl9kZXJlcV8sYT0wO2E8bi5sZW5ndGg7YSsrKW8oblthXSk7cmV0dXJuIG99fSgpKHsxOltmdW5jdGlvbih0LGUscil7ZS5leHBvcnRzPVt7Y29uc3RhbnQ6ITAsaW5wdXRzOlt7bmFtZToiX293bmVyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6Im5hbWUiLG91dHB1dHM6W3tuYW1lOiJvX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITAsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToib3duZXIiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImFkZHJlc3MifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITAsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiY29udGVudCIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYnl0ZXMzMiJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJhZGRyIixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJhZGRyZXNzIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6InJlc2VydmUiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITAsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToic3ViUmVnaXN0cmFyIixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJhZGRyZXNzIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9uZXdPd25lciIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJ0cmFuc2ZlciIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfcmVnaXN0cmFyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6InNldFN1YlJlZ2lzdHJhciIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W10sbmFtZToiUmVnaXN0cmFyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9hIix0eXBlOiJhZGRyZXNzIn0se25hbWU6Il9wcmltYXJ5Iix0eXBlOiJib29sIn1dLG5hbWU6InNldEFkZHJlc3MiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX2NvbnRlbnQiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToic2V0Q29udGVudCIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJkaXNvd24iLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMSxuYW1lOiJfd2lubmVyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6IkF1Y3Rpb25FbmRlZCIsdHlwZToiZXZlbnQifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMSxuYW1lOiJfYmlkZGVyIix0eXBlOiJhZGRyZXNzIn0se2luZGV4ZWQ6ITEsbmFtZToiX3ZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6Ik5ld0JpZCIsdHlwZToiZXZlbnQifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToibmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJDaGFuZ2VkIix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJuYW1lIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITAsbmFtZToiYWRkciIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJQcmltYXJ5Q2hhbmdlZCIsdHlwZToiZXZlbnQifV19LHt9XSwyOltmdW5jdGlvbih0LGUscil7ZS5leHBvcnRzPVt7Y29uc3RhbnQ6ITAsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToib3duZXIiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImFkZHJlc3MifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX3JlZnVuZCIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJkaXNvd24iLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITAsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiYWRkciIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYWRkcmVzcyJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJyZXNlcnZlIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9uZXdPd25lciIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJ0cmFuc2ZlciIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfYSIsdHlwZToiYWRkcmVzcyJ9XSxuYW1lOiJzZXRBZGRyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6Im5hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiQ2hhbmdlZCIsdHlwZToiZXZlbnQifV19LHt9XSwzOltmdW5jdGlvbih0LGUscil7ZS5leHBvcnRzPVt7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiZnJvbSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJ0byIsdHlwZToiYWRkcmVzcyJ9LHtuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJ0cmFuc2ZlciIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJmcm9tIix0eXBlOiJieXRlczMyIn0se25hbWU6InRvIix0eXBlOiJhZGRyZXNzIn0se25hbWU6ImluZGlyZWN0SWQiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToidmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToiaWNhcFRyYW5zZmVyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6InRvIix0eXBlOiJieXRlczMyIn1dLG5hbWU6ImRlcG9zaXQiLG91dHB1dHM6W10scGF5YWJsZTohMCx0eXBlOiJmdW5jdGlvbiJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJmcm9tIix0eXBlOiJhZGRyZXNzIn0se2luZGV4ZWQ6ITEsbmFtZToidmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToiQW5vbnltb3VzRGVwb3NpdCIsdHlwZToiZXZlbnQifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToiZnJvbSIsdHlwZToiYWRkcmVzcyJ9LHtpbmRleGVkOiEwLG5hbWU6InRvIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITEsbmFtZToidmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToiRGVwb3NpdCIsdHlwZToiZXZlbnQifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToiZnJvbSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiEwLG5hbWU6InRvIix0eXBlOiJhZGRyZXNzIn0se2luZGV4ZWQ6ITEsbmFtZToidmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToiVHJhbnNmZXIiLHR5cGU6ImV2ZW50In0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6ImZyb20iLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMCxuYW1lOiJ0byIsdHlwZToiYWRkcmVzcyJ9LHtpbmRleGVkOiExLG5hbWU6ImluZGlyZWN0SWQiLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMSxuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJJY2FwVHJhbnNmZXIiLHR5cGU6ImV2ZW50In1dfSx7fV0sNDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPW4uZm9ybWF0SW5wdXRJbnQsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPW4uZm9ybWF0T3V0cHV0QWRkcmVzc307KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9hZGRyZXNzKFxbKFswLTldKilcXSk/Lyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDU6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1uLmZvcm1hdElucHV0Qm9vbCx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9bi5mb3JtYXRPdXRwdXRCb29sfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL15ib29sKFxbKFswLTldKilcXSkqJC8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSw2OltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9bi5mb3JtYXRJbnB1dEJ5dGVzLHRoaXMuX291dHB1dEZvcm1hdHRlcj1uLmZvcm1hdE91dHB1dEJ5dGVzfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL15ieXRlcyhbMC05XXsxLH0pKFxbKFswLTldKilcXSkqJC8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSw3OltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL2FkZHJlc3MiKSxpPXQoIi4vYm9vbCIpLGE9dCgiLi9pbnQiKSxzPXQoIi4vdWludCIpLGM9dCgiLi9keW5hbWljYnl0ZXMiKSx1PXQoIi4vc3RyaW5nIiksZj10KCIuL3JlYWwiKSxsPXQoIi4vdXJlYWwiKSxwPXQoIi4vYnl0ZXMiKSxoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaXNEeW5hbWljVHlwZShlKXx8dC5pc0R5bmFtaWNBcnJheShlKX0sZD1mdW5jdGlvbih0KXt0aGlzLl90eXBlcz10fTtkLnByb3RvdHlwZS5fcmVxdWlyZVR5cGU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fdHlwZXMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlzVHlwZSh0KX0pWzBdO2lmKCFlKXRocm93IEVycm9yKCJpbnZhbGlkIHNvbGlkaXR5IHR5cGUhOiAiK3QpO3JldHVybiBlfSxkLnByb3RvdHlwZS5lbmNvZGVQYXJhbT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZVBhcmFtcyhbdF0sW2VdKX0sZC5wcm90b3R5cGUuZW5jb2RlUGFyYW1zPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5nZXRTb2xpZGl0eVR5cGVzKHQpLG49ci5tYXAoZnVuY3Rpb24ocixuKXtyZXR1cm4gci5lbmNvZGUoZVtuXSx0W25dKX0pLG89ci5yZWR1Y2UoZnVuY3Rpb24oZSxuLG8pe3ZhciBpPW4uc3RhdGljUGFydExlbmd0aCh0W29dKSxhPTMyKk1hdGguZmxvb3IoKGkrMzEpLzMyKTtyZXR1cm4gZSsoaChyW29dLHRbb10pPzMyOmEpfSwwKTtyZXR1cm4gdGhpcy5lbmNvZGVNdWx0aVdpdGhPZmZzZXQodCxyLG4sbyl9LGQucHJvdG90eXBlLmVuY29kZU11bHRpV2l0aE9mZnNldD1mdW5jdGlvbih0LGUscixvKXt2YXIgaT0iIixhPXRoaXM7cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbihzLGMpe2lmKGgoZVtjXSx0W2NdKSl7aSs9bi5mb3JtYXRJbnB1dEludChvKS5lbmNvZGUoKTt2YXIgdT1hLmVuY29kZVdpdGhPZmZzZXQodFtjXSxlW2NdLHJbY10sbyk7bys9dS5sZW5ndGgvMn1lbHNlIGkrPWEuZW5jb2RlV2l0aE9mZnNldCh0W2NdLGVbY10scltjXSxvKX0pLHQuZm9yRWFjaChmdW5jdGlvbihuLHMpe2lmKGgoZVtzXSx0W3NdKSl7dmFyIGM9YS5lbmNvZGVXaXRoT2Zmc2V0KHRbc10sZVtzXSxyW3NdLG8pO28rPWMubGVuZ3RoLzIsaSs9Y319KSxpfSxkLnByb3RvdHlwZS5lbmNvZGVXaXRoT2Zmc2V0PWZ1bmN0aW9uKHQsZSxyLG8pe3ZhciBpPTEsYT0yLHM9MyxjPWUuaXNEeW5hbWljQXJyYXkodCk/aTplLmlzU3RhdGljQXJyYXkodCk/YTpzO2lmKGMhPT1zKXt2YXIgdT1lLm5lc3RlZE5hbWUodCksZj1lLnN0YXRpY1BhcnRMZW5ndGgodSksbD1jPT09aT9yWzBdOiIiO2lmKGUuaXNEeW5hbWljQXJyYXkodSkpZm9yKHZhciBwPWM9PT1pPzI6MCxoPTA7aDxyLmxlbmd0aDtoKyspYz09PWk/cCs9K3JbaC0xXVswXXx8MDpjPT09YSYmKHArPSsocltoLTFdfHxbXSlbMF18fDApLGwrPW4uZm9ybWF0SW5wdXRJbnQobytoKmYrMzIqcCkuZW5jb2RlKCk7Zm9yKHZhciBkPWM9PT1pP3IubGVuZ3RoLTE6ci5sZW5ndGgsbT0wO208ZDttKyspe3ZhciB5PWwvMjtjPT09aT9sKz10aGlzLmVuY29kZVdpdGhPZmZzZXQodSxlLHJbbSsxXSxvK3kpOmM9PT1hJiYobCs9dGhpcy5lbmNvZGVXaXRoT2Zmc2V0KHUsZSxyW21dLG8reSkpfXJldHVybiBsfXJldHVybiByfSxkLnByb3RvdHlwZS5kZWNvZGVQYXJhbT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmRlY29kZVBhcmFtcyhbdF0sZSlbMF19LGQucHJvdG90eXBlLmRlY29kZVBhcmFtcz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuZ2V0U29saWRpdHlUeXBlcyh0KSxuPXRoaXMuZ2V0T2Zmc2V0cyh0LHIpO3JldHVybiByLm1hcChmdW5jdGlvbihyLG8pe3JldHVybiByLmRlY29kZShlLG5bb10sdFtvXSxvKX0pfSxkLnByb3RvdHlwZS5nZXRPZmZzZXRzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPWUubWFwKGZ1bmN0aW9uKGUscil7cmV0dXJuIGUuc3RhdGljUGFydExlbmd0aCh0W3JdKX0pLG49MTtuPHIubGVuZ3RoO24rKylyW25dKz1yW24tMV07cmV0dXJuIHIubWFwKGZ1bmN0aW9uKHIsbil7cmV0dXJuIHItZVtuXS5zdGF0aWNQYXJ0TGVuZ3RoKHRbbl0pfSl9LGQucHJvdG90eXBlLmdldFNvbGlkaXR5VHlwZXM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuX3JlcXVpcmVUeXBlKHQpfSl9O3ZhciBtPW5ldyBkKFtuZXcgbyxuZXcgaSxuZXcgYSxuZXcgcyxuZXcgYyxuZXcgcCxuZXcgdSxuZXcgZixuZXcgbF0pO2UuZXhwb3J0cz1tfSx7Ii4vYWRkcmVzcyI6NCwiLi9ib29sIjo1LCIuL2J5dGVzIjo2LCIuL2R5bmFtaWNieXRlcyI6OCwiLi9mb3JtYXR0ZXJzIjo5LCIuL2ludCI6MTAsIi4vcmVhbCI6MTIsIi4vc3RyaW5nIjoxMywiLi91aW50IjoxNSwiLi91cmVhbCI6MTZ9XSw4OltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9bi5mb3JtYXRJbnB1dER5bmFtaWNCeXRlcyx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9bi5mb3JtYXRPdXRwdXREeW5hbWljQnl0ZXN9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXmJ5dGVzKFxbKFswLTldKilcXSkqJC8pfSxpLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDk6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCJiaWdudW1iZXIuanMiKSxvPXQoIi4uL3V0aWxzL3V0aWxzIiksaT10KCIuLi91dGlscy9jb25maWciKSxhPXQoIi4vcGFyYW0iKSxzPWZ1bmN0aW9uKHQpe24uY29uZmlnKGkuRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFKTt2YXIgZT1vLnBhZExlZnQoby50b1R3b3NDb21wbGVtZW50KHQpLnRvU3RyaW5nKDE2KSw2NCk7cmV0dXJuIG5ldyBhKGUpfSxjPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGljUGFydCgpfHwiMCI7cmV0dXJuIjEiPT09bmV3IG4oZS5zdWJzdHIoMCwxKSwxNikudG9TdHJpbmcoMikuc3Vic3RyKDAsMSk/bmV3IG4oZSwxNikubWludXMobmV3IG4oImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYiLDE2KSkubWludXMoMSk6bmV3IG4oZSwxNil9LHU9ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0aWNQYXJ0KCl8fCIwIjtyZXR1cm4gbmV3IG4oZSwxNil9O2UuZXhwb3J0cz17Zm9ybWF0SW5wdXRJbnQ6cyxmb3JtYXRJbnB1dEJ5dGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW8udG9IZXgodCkuc3Vic3RyKDIpLHI9TWF0aC5mbG9vcigoZS5sZW5ndGgrNjMpLzY0KTtyZXR1cm4gZT1vLnBhZFJpZ2h0KGUsNjQqciksbmV3IGEoZSl9LGZvcm1hdElucHV0RHluYW1pY0J5dGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW8udG9IZXgodCkuc3Vic3RyKDIpLHI9ZS5sZW5ndGgvMixuPU1hdGguZmxvb3IoKGUubGVuZ3RoKzYzKS82NCk7cmV0dXJuIGU9by5wYWRSaWdodChlLDY0Km4pLG5ldyBhKHMocikudmFsdWUrZSl9LGZvcm1hdElucHV0U3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbVV0ZjgodCkuc3Vic3RyKDIpLHI9ZS5sZW5ndGgvMixuPU1hdGguZmxvb3IoKGUubGVuZ3RoKzYzKS82NCk7cmV0dXJuIGU9by5wYWRSaWdodChlLDY0Km4pLG5ldyBhKHMocikudmFsdWUrZSl9LGZvcm1hdElucHV0Qm9vbDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGEoIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIrKHQ/IjEiOiIwIikpfSxmb3JtYXRJbnB1dFJlYWw6ZnVuY3Rpb24odCl7cmV0dXJuIHMobmV3IG4odCkudGltZXMobmV3IG4oMikucG93KDEyOCkpKX0sZm9ybWF0T3V0cHV0SW50OmMsZm9ybWF0T3V0cHV0VUludDp1LGZvcm1hdE91dHB1dFJlYWw6ZnVuY3Rpb24odCl7cmV0dXJuIGModCkuZGl2aWRlZEJ5KG5ldyBuKDIpLnBvdygxMjgpKX0sZm9ybWF0T3V0cHV0VVJlYWw6ZnVuY3Rpb24odCl7cmV0dXJuIHUodCkuZGl2aWRlZEJ5KG5ldyBuKDIpLnBvdygxMjgpKX0sZm9ybWF0T3V0cHV0Qm9vbDpmdW5jdGlvbih0KXtyZXR1cm4iMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSI9PT10LnN0YXRpY1BhcnQoKX0sZm9ybWF0T3V0cHV0Qnl0ZXM6ZnVuY3Rpb24odCxlKXt2YXIgcj1lLm1hdGNoKC9eYnl0ZXMoWzAtOV0qKS8pLG49cGFyc2VJbnQoclsxXSk7cmV0dXJuIjB4Iit0LnN0YXRpY1BhcnQoKS5zbGljZSgwLDIqbil9LGZvcm1hdE91dHB1dER5bmFtaWNCeXRlczpmdW5jdGlvbih0KXt2YXIgZT0yKm5ldyBuKHQuZHluYW1pY1BhcnQoKS5zbGljZSgwLDY0KSwxNikudG9OdW1iZXIoKTtyZXR1cm4iMHgiK3QuZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsZSl9LGZvcm1hdE91dHB1dFN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT0yKm5ldyBuKHQuZHluYW1pY1BhcnQoKS5zbGljZSgwLDY0KSwxNikudG9OdW1iZXIoKTtyZXR1cm4gby50b1V0ZjgodC5keW5hbWljUGFydCgpLnN1YnN0cig2NCxlKSl9LGZvcm1hdE91dHB1dEFkZHJlc3M6ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0aWNQYXJ0KCk7cmV0dXJuIjB4IitlLnNsaWNlKGUubGVuZ3RoLTQwLGUubGVuZ3RoKX19fSx7Ii4uL3V0aWxzL2NvbmZpZyI6MTgsIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9wYXJhbSI6MTEsImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwxMDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPW4uZm9ybWF0SW5wdXRJbnQsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPW4uZm9ybWF0T3V0cHV0SW50fTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL15pbnQoWzAtOV0qKT8oXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDExOltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi4vdXRpbHMvdXRpbHMiKSxvPWZ1bmN0aW9uKHQsZSl7dGhpcy52YWx1ZT10fHwiIix0aGlzLm9mZnNldD1lfTtvLnByb3RvdHlwZS5keW5hbWljUGFydExlbmd0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmR5bmFtaWNQYXJ0KCkubGVuZ3RoLzJ9LG8ucHJvdG90eXBlLndpdGhPZmZzZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvKHRoaXMudmFsdWUsdCl9LG8ucHJvdG90eXBlLmNvbWJpbmU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvKHRoaXMudmFsdWUrdC52YWx1ZSl9LG8ucHJvdG90eXBlLmlzRHluYW1pYz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLm9mZnNldH0sby5wcm90b3R5cGUub2Zmc2V0QXNCeXRlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRHluYW1pYygpP24ucGFkTGVmdChuLnRvVHdvc0NvbXBsZW1lbnQodGhpcy5vZmZzZXQpLnRvU3RyaW5nKDE2KSw2NCk6IiJ9LG8ucHJvdG90eXBlLnN0YXRpY1BhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0R5bmFtaWMoKT90aGlzLm9mZnNldEFzQnl0ZXMoKTp0aGlzLnZhbHVlfSxvLnByb3RvdHlwZS5keW5hbWljUGFydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRHluYW1pYygpP3RoaXMudmFsdWU6IiJ9LG8ucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRpY1BhcnQoKSt0aGlzLmR5bmFtaWNQYXJ0KCl9LG8uZW5jb2RlTGlzdD1mdW5jdGlvbih0KXt2YXIgZT0zMip0Lmxlbmd0aCxyPXQubWFwKGZ1bmN0aW9uKHQpe2lmKCF0LmlzRHluYW1pYygpKXJldHVybiB0O3ZhciByPWU7cmV0dXJuIGUrPXQuZHluYW1pY1BhcnRMZW5ndGgoKSx0LndpdGhPZmZzZXQocil9KTtyZXR1cm4gci5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlLmR5bmFtaWNQYXJ0KCl9LHIucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZS5zdGF0aWNQYXJ0KCl9LCIiKSl9LGUuZXhwb3J0cz1vfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMH1dLDEyOltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9bi5mb3JtYXRJbnB1dFJlYWwsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPW4uZm9ybWF0T3V0cHV0UmVhbH07KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9yZWFsKFswLTldKik/KFxbKFswLTldKilcXSk/Lyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDEzOltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9bi5mb3JtYXRJbnB1dFN0cmluZyx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9bi5mb3JtYXRPdXRwdXRTdHJpbmd9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXnN0cmluZyhcWyhbMC05XSopXF0pKiQvKX0saS5wcm90b3R5cGUuaXNEeW5hbWljVHlwZT1mdW5jdGlvbigpe3JldHVybiEwfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxNDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi9wYXJhbSIpLGk9ZnVuY3Rpb24odCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9dC5pbnB1dEZvcm1hdHRlcix0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9dC5vdXRwdXRGb3JtYXR0ZXJ9O2kucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXt0aHJvdyJ0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJ3cml0dGVuIGZvciB0eXBlICIrdH0saS5wcm90b3R5cGUuc3RhdGljUGFydExlbmd0aD1mdW5jdGlvbih0KXtyZXR1cm4odGhpcy5uZXN0ZWRUeXBlcyh0KXx8WyJbMV0iXSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBwYXJzZUludCh0LnNsaWNlKDEsLTEpLDEwKXx8MX0pLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9LDMyKX0saS5wcm90b3R5cGUuaXNEeW5hbWljQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4hIWUmJiFlW2UubGVuZ3RoLTFdLm1hdGNoKC9bMC05XXsxLH0vZyl9LGkucHJvdG90eXBlLmlzU3RhdGljQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4hIWUmJiEhZVtlLmxlbmd0aC0xXS5tYXRjaCgvWzAtOV17MSx9L2cpfSxpLnByb3RvdHlwZS5zdGF0aWNBcnJheUxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm5lc3RlZFR5cGVzKHQpO3JldHVybiBlP3BhcnNlSW50KGVbZS5sZW5ndGgtMV0ubWF0Y2goL1swLTldezEsfS9nKXx8MSk6MX0saS5wcm90b3R5cGUubmVzdGVkTmFtZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm5lc3RlZFR5cGVzKHQpO3JldHVybiBlP3Quc3Vic3RyKDAsdC5sZW5ndGgtZVtlLmxlbmd0aC0xXS5sZW5ndGgpOnR9LGkucHJvdG90eXBlLmlzRHluYW1pY1R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0saS5wcm90b3R5cGUubmVzdGVkVHlwZXM9ZnVuY3Rpb24odCl7cmV0dXJuIHQubWF0Y2goLyhcW1swLTldKlxdKS9nKX0saS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbyxpLGE9dGhpcztyZXR1cm4gdGhpcy5pc0R5bmFtaWNBcnJheShlKT8ocj10Lmxlbmd0aCxvPWEubmVzdGVkTmFtZShlKSwoaT1bXSkucHVzaChuLmZvcm1hdElucHV0SW50KHIpLmVuY29kZSgpKSx0LmZvckVhY2goZnVuY3Rpb24odCl7aS5wdXNoKGEuZW5jb2RlKHQsbykpfSksaSk6dGhpcy5pc1N0YXRpY0FycmF5KGUpP2Z1bmN0aW9uKCl7Zm9yKHZhciByPWEuc3RhdGljQXJyYXlMZW5ndGgoZSksbj1hLm5lc3RlZE5hbWUoZSksbz1bXSxpPTA7aTxyO2krKylvLnB1c2goYS5lbmNvZGUodFtpXSxuKSk7cmV0dXJuIG99KCk6dGhpcy5faW5wdXRGb3JtYXR0ZXIodCxlKS5lbmNvZGUoKX0saS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpLGEscyxjPXRoaXM7aWYodGhpcy5pc0R5bmFtaWNBcnJheShyKSlyZXR1cm4gZnVuY3Rpb24oKXtmb3IodmFyIG49cGFyc2VJbnQoIjB4Iit0LnN1YnN0cigyKmUsNjQpKSxvPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMipuLDY0KSksaT1uKzMyLGE9Yy5uZXN0ZWROYW1lKHIpLHM9Yy5zdGF0aWNQYXJ0TGVuZ3RoKGEpLHU9MzIqTWF0aC5mbG9vcigocyszMSkvMzIpLGY9W10sbD0wO2w8byp1O2wrPXUpZi5wdXNoKGMuZGVjb2RlKHQsaStsLGEpKTtyZXR1cm4gZn0oKTtpZih0aGlzLmlzU3RhdGljQXJyYXkocikpcmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBuPWMuc3RhdGljQXJyYXlMZW5ndGgociksbz1lLGk9Yy5uZXN0ZWROYW1lKHIpLGE9Yy5zdGF0aWNQYXJ0TGVuZ3RoKGkpLHM9MzIqTWF0aC5mbG9vcigoYSszMSkvMzIpLHU9W10sZj0wO2Y8bipzO2YrPXMpdS5wdXNoKGMuZGVjb2RlKHQsbytmLGkpKTtyZXR1cm4gdX0oKTtpZih0aGlzLmlzRHluYW1pY1R5cGUocikpcmV0dXJuIG49cGFyc2VJbnQoIjB4Iit0LnN1YnN0cigyKmUsNjQpKSxpPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMipuLDY0KSksYT1NYXRoLmZsb29yKChpKzMxKS8zMikscz1uZXcgbyh0LnN1YnN0cigyKm4sNjQqKDErYSkpLDApLGMuX291dHB1dEZvcm1hdHRlcihzLHIpO3ZhciB1PXRoaXMuc3RhdGljUGFydExlbmd0aChyKSxmPW5ldyBvKHQuc3Vic3RyKDIqZSwyKnUpKTtyZXR1cm4gdGhpcy5fb3V0cHV0Rm9ybWF0dGVyKGYscil9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi9wYXJhbSI6MTF9XSwxNTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPW4uZm9ybWF0SW5wdXRJbnQsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPW4uZm9ybWF0T3V0cHV0VUludH07KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9edWludChbMC05XSopPyhcWyhbMC05XSopXF0pKiQvKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sMTY6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1uLmZvcm1hdElucHV0UmVhbCx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9bi5mb3JtYXRPdXRwdXRVUmVhbH07KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9edXJlYWwoWzAtOV0qKT8oXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDE3OltmdW5jdGlvbih0LGUscil7InVzZSBzdHJpY3QiOyJ1bmRlZmluZWQiPT10eXBlb2YgWE1MSHR0cFJlcXVlc3Q/ci5YTUxIdHRwUmVxdWVzdD17fTpyLlhNTEh0dHBSZXF1ZXN0PVhNTEh0dHBSZXF1ZXN0fSx7fV0sMTg6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCJiaWdudW1iZXIuanMiKTtlLmV4cG9ydHM9e0VUSF9QQURESU5HOjMyLEVUSF9TSUdOQVRVUkVfTEVOR1RIOjQsRVRIX1VOSVRTOlsid2VpIiwia3dlaSIsIk13ZWkiLCJHd2VpIiwic3phYm8iLCJmaW5uZXkiLCJmZW10b2V0aGVyIiwicGljb2V0aGVyIiwibmFub2V0aGVyIiwibWljcm9ldGhlciIsIm1pbGxpZXRoZXIiLCJuYW5vIiwibWljcm8iLCJtaWxsaSIsImV0aGVyIiwiZ3JhbmQiLCJNZXRoZXIiLCJHZXRoZXIiLCJUZXRoZXIiLCJQZXRoZXIiLCJFZXRoZXIiLCJaZXRoZXIiLCJZZXRoZXIiLCJOZXRoZXIiLCJEZXRoZXIiLCJWZXRoZXIiLCJVZXRoZXIiXSxFVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREU6e1JPVU5ESU5HX01PREU6bi5ST1VORF9ET1dOfSxFVEhfUE9MTElOR19USU1FT1VUOjUwMCxkZWZhdWx0QmxvY2s6ImxhdGVzdCIsZGVmYXVsdEFjY291bnQ6dm9pZCAwfX0seyJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMifV0sMTk6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCJjcnlwdG8tanMiKSxvPXQoImNyeXB0by1qcy9zaGEzIik7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUmJiJoZXgiPT09ZS5lbmNvZGluZyYmKHQubGVuZ3RoPjImJiIweCI9PT10LnN1YnN0cigwLDIpJiYodD10LnN1YnN0cigyKSksdD1uLmVuYy5IZXgucGFyc2UodCkpLG8odCx7b3V0cHV0TGVuZ3RoOjI1Nn0pLnRvU3RyaW5nKCl9fSx7ImNyeXB0by1qcyI6NTgsImNyeXB0by1qcy9zaGEzIjo3OX1dLDIwOltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiYmlnbnVtYmVyLmpzIiksbz10KCIuL3NoYTMuanMiKSxpPXQoInV0ZjgiKSxhPXtub2V0aGVyOiIwIix3ZWk6IjEiLGt3ZWk6IjEwMDAiLEt3ZWk6IjEwMDAiLGJhYmJhZ2U6IjEwMDAiLGZlbXRvZXRoZXI6IjEwMDAiLG13ZWk6IjEwMDAwMDAiLE13ZWk6IjEwMDAwMDAiLGxvdmVsYWNlOiIxMDAwMDAwIixwaWNvZXRoZXI6IjEwMDAwMDAiLGd3ZWk6IjEwMDAwMDAwMDAiLEd3ZWk6IjEwMDAwMDAwMDAiLHNoYW5ub246IjEwMDAwMDAwMDAiLG5hbm9ldGhlcjoiMTAwMDAwMDAwMCIsbmFubzoiMTAwMDAwMDAwMCIsc3phYm86IjEwMDAwMDAwMDAwMDAiLG1pY3JvZXRoZXI6IjEwMDAwMDAwMDAwMDAiLG1pY3JvOiIxMDAwMDAwMDAwMDAwIixmaW5uZXk6IjEwMDAwMDAwMDAwMDAwMDAiLG1pbGxpZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAiLG1pbGxpOiIxMDAwMDAwMDAwMDAwMDAwIixldGhlcjoiMTAwMDAwMDAwMDAwMDAwMDAwMCIsa2V0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwIixncmFuZDoiMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsbWV0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIixnZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLHRldGhlcjoiMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCJ9LHM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBuZXcgQXJyYXkoZS10Lmxlbmd0aCsxKS5qb2luKHJ8fCIwIikrdH0sYz1mdW5jdGlvbih0LGUpe3Q9aS5lbmNvZGUodCk7Zm9yKHZhciByPSIiLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIG89dC5jaGFyQ29kZUF0KG4pO2lmKDA9PT1vKXtpZighZSlicmVhaztyKz0iMDAifWVsc2V7dmFyIGE9by50b1N0cmluZygxNik7cis9YS5sZW5ndGg8Mj8iMCIrYTphfX1yZXR1cm4iMHgiK3J9LHU9ZnVuY3Rpb24odCl7dmFyIGU9cCh0KSxyPWUudG9TdHJpbmcoMTYpO3JldHVybiBlLmxlc3NUaGFuKDApPyItMHgiK3Iuc3Vic3RyKDEpOiIweCIrcn0sZj1mdW5jdGlvbih0KXtpZihnKHQpKXJldHVybiB1KCt0KTtpZihtKHQpKXJldHVybiB1KHQpO2lmKCJvYmplY3QiPT10eXBlb2YgdClyZXR1cm4gYyhKU09OLnN0cmluZ2lmeSh0KSk7aWYoeSh0KSl7aWYoMD09PXQuaW5kZXhPZigiLTB4IikpcmV0dXJuIHUodCk7aWYoMD09PXQuaW5kZXhPZigiMHgiKSlyZXR1cm4gdDtpZighaXNGaW5pdGUodCkpcmV0dXJuIGModCwxKX1yZXR1cm4gdSh0KX0sbD1mdW5jdGlvbih0KXt0PXQ/dC50b0xvd2VyQ2FzZSgpOiJldGhlciI7dmFyIGU9YVt0XTtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcigiVGhpcyB1bml0IGRvZXNuJ3QgZXhpc3RzLCBwbGVhc2UgdXNlIHRoZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB1bml0cyIrSlNPTi5zdHJpbmdpZnkoYSxudWxsLDIpKTtyZXR1cm4gbmV3IG4oZSwxMCl9LHA9ZnVuY3Rpb24odCl7cmV0dXJuIG0odD10fHwwKT90OiF5KHQpfHwwIT09dC5pbmRleE9mKCIweCIpJiYwIT09dC5pbmRleE9mKCItMHgiKT9uZXcgbih0LnRvU3RyaW5nKDEwKSwxMCk6bmV3IG4odC5yZXBsYWNlKCIweCIsIiIpLDE2KX0saD1mdW5jdGlvbih0KXtyZXR1cm4vXjB4WzAtOWEtZl17NDB9JC9pLnRlc3QodCl9LGQ9ZnVuY3Rpb24odCl7dD10LnJlcGxhY2UoIjB4IiwiIik7Zm9yKHZhciBlPW8odC50b0xvd2VyQ2FzZSgpKSxyPTA7cjw0MDtyKyspaWYocGFyc2VJbnQoZVtyXSwxNik+NyYmdFtyXS50b1VwcGVyQ2FzZSgpIT09dFtyXXx8cGFyc2VJbnQoZVtyXSwxNik8PTcmJnRbcl0udG9Mb3dlckNhc2UoKSE9PXRbcl0pcmV0dXJuITE7cmV0dXJuITB9LG09ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBufHx0JiZ0LmNvbnN0cnVjdG9yJiYiQmlnTnVtYmVyIj09PXQuY29uc3RydWN0b3IubmFtZX0seT1mdW5jdGlvbih0KXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHR8fHQmJnQuY29uc3RydWN0b3ImJiJTdHJpbmciPT09dC5jb25zdHJ1Y3Rvci5uYW1lfSxnPWZ1bmN0aW9uKHQpe3JldHVybiJib29sZWFuIj09dHlwZW9mIHR9O2UuZXhwb3J0cz17cGFkTGVmdDpzLHBhZFJpZ2h0OmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdCtuZXcgQXJyYXkoZS10Lmxlbmd0aCsxKS5qb2luKHJ8fCIwIil9LHRvSGV4OmYsdG9EZWNpbWFsOmZ1bmN0aW9uKHQpe3JldHVybiBwKHQpLnRvTnVtYmVyKCl9LGZyb21EZWNpbWFsOnUsdG9VdGY4OmZ1bmN0aW9uKHQpe3ZhciBlPSIiLHI9MCxuPXQubGVuZ3RoO2ZvcigiMHgiPT09dC5zdWJzdHJpbmcoMCwyKSYmKHI9Mik7cjxuO3IrPTIpe3ZhciBvPXBhcnNlSW50KHQuc3Vic3RyKHIsMiksMTYpO2lmKDA9PT1vKWJyZWFrO2UrPVN0cmluZy5mcm9tQ2hhckNvZGUobyl9cmV0dXJuIGkuZGVjb2RlKGUpfSx0b0FzY2lpOmZ1bmN0aW9uKHQpe3ZhciBlPSIiLHI9MCxuPXQubGVuZ3RoO2ZvcigiMHgiPT09dC5zdWJzdHJpbmcoMCwyKSYmKHI9Mik7cjxuO3IrPTIpe3ZhciBvPXBhcnNlSW50KHQuc3Vic3RyKHIsMiksMTYpO2UrPVN0cmluZy5mcm9tQ2hhckNvZGUobyl9cmV0dXJuIGV9LGZyb21VdGY4OmMsZnJvbUFzY2lpOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0iIixyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXQuY2hhckNvZGVBdChyKS50b1N0cmluZygxNik7ZSs9bi5sZW5ndGg8Mj8iMCIrbjpufXJldHVybiIweCIrZX0sdHJhbnNmb3JtVG9GdWxsTmFtZTpmdW5jdGlvbih0KXtpZigtMSE9PXQubmFtZS5pbmRleE9mKCIoIikpcmV0dXJuIHQubmFtZTt2YXIgZT10LmlucHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pLmpvaW4oKTtyZXR1cm4gdC5uYW1lKyIoIitlKyIpIn0sZXh0cmFjdERpc3BsYXlOYW1lOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5kZXhPZigiKCIpLHI9dC5pbmRleE9mKCIpIik7cmV0dXJuLTEhPT1lJiYtMSE9PXI/dC5zdWJzdHIoMCxlKTp0fSxleHRyYWN0VHlwZU5hbWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbmRleE9mKCIoIikscj10LmluZGV4T2YoIikiKTtyZXR1cm4tMSE9PWUmJi0xIT09cj90LnN1YnN0cihlKzEsci1lLTEpLnJlcGxhY2UoIiAiLCIiKToiIn0sdG9XZWk6ZnVuY3Rpb24odCxlKXt2YXIgcj1wKHQpLnRpbWVzKGwoZSkpO3JldHVybiBtKHQpP3I6ci50b1N0cmluZygxMCl9LGZyb21XZWk6ZnVuY3Rpb24odCxlKXt2YXIgcj1wKHQpLmRpdmlkZWRCeShsKGUpKTtyZXR1cm4gbSh0KT9yOnIudG9TdHJpbmcoMTApfSx0b0JpZ051bWJlcjpwLHRvVHdvc0NvbXBsZW1lbnQ6ZnVuY3Rpb24odCl7dmFyIGU9cCh0KS5yb3VuZCgpO3JldHVybiBlLmxlc3NUaGFuKDApP25ldyBuKCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmIiwxNikucGx1cyhlKS5wbHVzKDEpOmV9LHRvQWRkcmVzczpmdW5jdGlvbih0KXtyZXR1cm4gaCh0KT90Oi9eWzAtOWEtZl17NDB9JC8udGVzdCh0KT8iMHgiK3Q6IjB4IitzKGYodCkuc3Vic3RyKDIpLDQwKX0saXNCaWdOdW1iZXI6bSxpc1N0cmljdEFkZHJlc3M6aCxpc0FkZHJlc3M6ZnVuY3Rpb24odCl7cmV0dXJuISEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QodCkmJighKCEvXigweCk/WzAtOWEtZl17NDB9JC8udGVzdCh0KSYmIS9eKDB4KT9bMC05QS1GXXs0MH0kLy50ZXN0KHQpKXx8ZCh0KSl9LGlzQ2hlY2tzdW1BZGRyZXNzOmQsdG9DaGVja3N1bUFkZHJlc3M6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4iIjt0PXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCIweCIsIiIpO2Zvcih2YXIgZT1vKHQpLHI9IjB4IixuPTA7bjx0Lmxlbmd0aDtuKyspcGFyc2VJbnQoZVtuXSwxNik+Nz9yKz10W25dLnRvVXBwZXJDYXNlKCk6cis9dFtuXTtyZXR1cm4gcn0saXNGdW5jdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgdH0saXNTdHJpbmc6eSxpc09iamVjdDpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXQmJiFBcnJheS5pc0FycmF5KHQpJiYib2JqZWN0Ij09dHlwZW9mIHR9LGlzQm9vbGVhbjpnLGlzQXJyYXk6ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCl9LGlzSnNvbjpmdW5jdGlvbih0KXt0cnl7cmV0dXJuISFKU09OLnBhcnNlKHQpfWNhdGNoKHQpe3JldHVybiExfX0saXNCbG9vbTpmdW5jdGlvbih0KXtyZXR1cm4hKCEvXigweCk/WzAtOWEtZl17NTEyfSQvaS50ZXN0KHQpfHwhL14oMHgpP1swLTlhLWZdezUxMn0kLy50ZXN0KHQpJiYhL14oMHgpP1swLTlBLUZdezUxMn0kLy50ZXN0KHQpKX0saXNUb3BpYzpmdW5jdGlvbih0KXtyZXR1cm4hKCEvXigweCk/WzAtOWEtZl17NjR9JC9pLnRlc3QodCl8fCEvXigweCk/WzAtOWEtZl17NjR9JC8udGVzdCh0KSYmIS9eKDB4KT9bMC05QS1GXXs2NH0kLy50ZXN0KHQpKX19fSx7Ii4vc2hhMy5qcyI6MTksImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyIsdXRmODo4NH1dLDIxOltmdW5jdGlvbih0LGUscil7ZS5leHBvcnRzPXt2ZXJzaW9uOiIwLjIwLjYifX0se31dLDIyOltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi93ZWIzL3JlcXVlc3RtYW5hZ2VyIiksbz10KCIuL3dlYjMvaWJhbiIpLGk9dCgiLi93ZWIzL21ldGhvZHMvZXRoIiksYT10KCIuL3dlYjMvbWV0aG9kcy9kYiIpLHM9dCgiLi93ZWIzL21ldGhvZHMvc2hoIiksYz10KCIuL3dlYjMvbWV0aG9kcy9uZXQiKSx1PXQoIi4vd2ViMy9tZXRob2RzL3BlcnNvbmFsIiksZj10KCIuL3dlYjMvbWV0aG9kcy9zd2FybSIpLGw9dCgiLi93ZWIzL3NldHRpbmdzIikscD10KCIuL3ZlcnNpb24uanNvbiIpLGg9dCgiLi91dGlscy91dGlscyIpLGQ9dCgiLi91dGlscy9zaGEzIiksbT10KCIuL3dlYjMvZXh0ZW5kIikseT10KCIuL3dlYjMvYmF0Y2giKSxnPXQoIi4vd2ViMy9wcm9wZXJ0eSIpLHY9dCgiLi93ZWIzL2h0dHBwcm92aWRlciIpLGI9dCgiLi93ZWIzL2lwY3Byb3ZpZGVyIiksXz10KCJiaWdudW1iZXIuanMiKTtmdW5jdGlvbiB3KHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPW5ldyBuKHQpLHRoaXMuY3VycmVudFByb3ZpZGVyPXQsdGhpcy5ldGg9bmV3IGkodGhpcyksdGhpcy5kYj1uZXcgYSh0aGlzKSx0aGlzLnNoaD1uZXcgcyh0aGlzKSx0aGlzLm5ldD1uZXcgYyh0aGlzKSx0aGlzLnBlcnNvbmFsPW5ldyB1KHRoaXMpLHRoaXMuYnp6PW5ldyBmKHRoaXMpLHRoaXMuc2V0dGluZ3M9bmV3IGwsdGhpcy52ZXJzaW9uPXthcGk6cC52ZXJzaW9ufSx0aGlzLnByb3ZpZGVycz17SHR0cFByb3ZpZGVyOnYsSXBjUHJvdmlkZXI6Yn0sdGhpcy5fZXh0ZW5kPW0odGhpcyksdGhpcy5fZXh0ZW5kKHtwcm9wZXJ0aWVzOngoKX0pfXcucHJvdmlkZXJzPXtIdHRwUHJvdmlkZXI6dixJcGNQcm92aWRlcjpifSx3LnByb3RvdHlwZS5zZXRQcm92aWRlcj1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlci5zZXRQcm92aWRlcih0KSx0aGlzLmN1cnJlbnRQcm92aWRlcj10fSx3LnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlci5yZXNldCh0KSx0aGlzLnNldHRpbmdzPW5ldyBsfSx3LnByb3RvdHlwZS5CaWdOdW1iZXI9Xyx3LnByb3RvdHlwZS50b0hleD1oLnRvSGV4LHcucHJvdG90eXBlLnRvQXNjaWk9aC50b0FzY2lpLHcucHJvdG90eXBlLnRvVXRmOD1oLnRvVXRmOCx3LnByb3RvdHlwZS5mcm9tQXNjaWk9aC5mcm9tQXNjaWksdy5wcm90b3R5cGUuZnJvbVV0Zjg9aC5mcm9tVXRmOCx3LnByb3RvdHlwZS50b0RlY2ltYWw9aC50b0RlY2ltYWwsdy5wcm90b3R5cGUuZnJvbURlY2ltYWw9aC5mcm9tRGVjaW1hbCx3LnByb3RvdHlwZS50b0JpZ051bWJlcj1oLnRvQmlnTnVtYmVyLHcucHJvdG90eXBlLnRvV2VpPWgudG9XZWksdy5wcm90b3R5cGUuZnJvbVdlaT1oLmZyb21XZWksdy5wcm90b3R5cGUuaXNBZGRyZXNzPWguaXNBZGRyZXNzLHcucHJvdG90eXBlLmlzQ2hlY2tzdW1BZGRyZXNzPWguaXNDaGVja3N1bUFkZHJlc3Msdy5wcm90b3R5cGUudG9DaGVja3N1bUFkZHJlc3M9aC50b0NoZWNrc3VtQWRkcmVzcyx3LnByb3RvdHlwZS5pc0lCQU49aC5pc0lCQU4sdy5wcm90b3R5cGUucGFkTGVmdD1oLnBhZExlZnQsdy5wcm90b3R5cGUucGFkUmlnaHQ9aC5wYWRSaWdodCx3LnByb3RvdHlwZS5zaGEzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIjB4IitkKHQsZSl9LHcucHJvdG90eXBlLmZyb21JQ0FQPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbyh0KS5hZGRyZXNzKCl9O3ZhciB4PWZ1bmN0aW9uKCl7cmV0dXJuW25ldyBnKHtuYW1lOiJ2ZXJzaW9uLm5vZGUiLGdldHRlcjoid2ViM19jbGllbnRWZXJzaW9uIn0pLG5ldyBnKHtuYW1lOiJ2ZXJzaW9uLm5ldHdvcmsiLGdldHRlcjoibmV0X3ZlcnNpb24iLGlucHV0Rm9ybWF0dGVyOmgudG9EZWNpbWFsfSksbmV3IGcoe25hbWU6InZlcnNpb24uZXRoZXJldW0iLGdldHRlcjoiZXRoX3Byb3RvY29sVmVyc2lvbiIsaW5wdXRGb3JtYXR0ZXI6aC50b0RlY2ltYWx9KSxuZXcgZyh7bmFtZToidmVyc2lvbi53aGlzcGVyIixnZXR0ZXI6InNoaF92ZXJzaW9uIixpbnB1dEZvcm1hdHRlcjpoLnRvRGVjaW1hbH0pXX07dy5wcm90b3R5cGUuaXNDb25uZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50UHJvdmlkZXImJnRoaXMuY3VycmVudFByb3ZpZGVyLmlzQ29ubmVjdGVkKCl9LHcucHJvdG90eXBlLmNyZWF0ZUJhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB5KHRoaXMpfSxlLmV4cG9ydHM9d30seyIuL3V0aWxzL3NoYTMiOjE5LCIuL3V0aWxzL3V0aWxzIjoyMCwiLi92ZXJzaW9uLmpzb24iOjIxLCIuL3dlYjMvYmF0Y2giOjI0LCIuL3dlYjMvZXh0ZW5kIjoyOCwiLi93ZWIzL2h0dHBwcm92aWRlciI6MzIsIi4vd2ViMy9pYmFuIjozMywiLi93ZWIzL2lwY3Byb3ZpZGVyIjozNCwiLi93ZWIzL21ldGhvZHMvZGIiOjM3LCIuL3dlYjMvbWV0aG9kcy9ldGgiOjM4LCIuL3dlYjMvbWV0aG9kcy9uZXQiOjM5LCIuL3dlYjMvbWV0aG9kcy9wZXJzb25hbCI6NDAsIi4vd2ViMy9tZXRob2RzL3NoaCI6NDEsIi4vd2ViMy9tZXRob2RzL3N3YXJtIjo0MiwiLi93ZWIzL3Byb3BlcnR5Ijo0NSwiLi93ZWIzL3JlcXVlc3RtYW5hZ2VyIjo0NiwiLi93ZWIzL3NldHRpbmdzIjo0NywiYmlnbnVtYmVyLmpzIjoiYmlnbnVtYmVyLmpzIn1dLDIzOltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi4vdXRpbHMvc2hhMyIpLG89dCgiLi9ldmVudCIpLGk9dCgiLi9mb3JtYXR0ZXJzIiksYT10KCIuLi91dGlscy91dGlscyIpLHM9dCgiLi9maWx0ZXIiKSxjPXQoIi4vbWV0aG9kcy93YXRjaGVzIiksdT1mdW5jdGlvbih0LGUscil7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dCx0aGlzLl9qc29uPWUsdGhpcy5fYWRkcmVzcz1yfTt1LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCl7dD10fHx7fTt2YXIgZT17fTtyZXR1cm5bImZyb21CbG9jayIsInRvQmxvY2siXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PXRbZV19KS5mb3JFYWNoKGZ1bmN0aW9uKHIpe2Vbcl09aS5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKHRbcl0pfSksZS5hZGRyZXNzPXRoaXMuX2FkZHJlc3MsZX0sdS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQpe3QuZGF0YT10LmRhdGF8fCIiO3ZhciBlPWEuaXNBcnJheSh0LnRvcGljcykmJmEuaXNTdHJpbmcodC50b3BpY3NbMF0pP3QudG9waWNzWzBdLnNsaWNlKDIpOiIiLHI9dGhpcy5fanNvbi5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIGU9PT1uKGEudHJhbnNmb3JtVG9GdWxsTmFtZSh0KSl9KVswXTtyZXR1cm4gcj9uZXcgbyh0aGlzLl9yZXF1ZXN0TWFuYWdlcixyLHRoaXMuX2FkZHJlc3MpLmRlY29kZSh0KTppLm91dHB1dExvZ0Zvcm1hdHRlcih0KX0sdS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbih0LGUpe2EuaXNGdW5jdGlvbihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSkmJihlPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdLDE9PT1hcmd1bWVudHMubGVuZ3RoJiYodD1udWxsKSk7dmFyIHI9dGhpcy5lbmNvZGUodCksbj10aGlzLmRlY29kZS5iaW5kKHRoaXMpO3JldHVybiBuZXcgcyhyLCJldGgiLHRoaXMuX3JlcXVlc3RNYW5hZ2VyLGMuZXRoKCksbixlKX0sdS5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTt0LmFsbEV2ZW50cz1lfSxlLmV4cG9ydHM9dX0seyIuLi91dGlscy9zaGEzIjoxOSwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2V2ZW50IjoyNywiLi9maWx0ZXIiOjI5LCIuL2Zvcm1hdHRlcnMiOjMwLCIuL21ldGhvZHMvd2F0Y2hlcyI6NDN9XSwyNDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4vanNvbnJwYyIpLG89dCgiLi9lcnJvcnMiKSxpPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXIsdGhpcy5yZXF1ZXN0cz1bXX07aS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdHMucHVzaCh0KX0saS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucmVxdWVzdHM7dGhpcy5yZXF1ZXN0TWFuYWdlci5zZW5kQmF0Y2godCxmdW5jdGlvbihlLHIpe3I9cnx8W10sdC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gcltlXXx8e319KS5mb3JFYWNoKGZ1bmN0aW9uKGUscil7aWYodFtyXS5jYWxsYmFjayl7aWYoIW4uaXNWYWxpZFJlc3BvbnNlKGUpKXJldHVybiB0W3JdLmNhbGxiYWNrKG8uSW52YWxpZFJlc3BvbnNlKGUpKTt0W3JdLmNhbGxiYWNrKG51bGwsdFtyXS5mb3JtYXQ/dFtyXS5mb3JtYXQoZS5yZXN1bHQpOmUucmVzdWx0KX19KX0pfSxlLmV4cG9ydHM9aX0seyIuL2Vycm9ycyI6MjYsIi4vanNvbnJwYyI6MzV9XSwyNTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9zb2xpZGl0eS9jb2RlciIpLGk9dCgiLi9ldmVudCIpLGE9dCgiLi9mdW5jdGlvbiIpLHM9dCgiLi9hbGxldmVudHMiKSxjPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiJjb25zdHJ1Y3RvciI9PT10LnR5cGUmJnQuaW5wdXRzLmxlbmd0aD09PWUubGVuZ3RofSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlucHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBvLmVuY29kZVBhcmFtcyh0LGUpfSlbMF18fCIifSx1PWZ1bmN0aW9uKHQpe3QuYWJpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT09dC50eXBlfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgYSh0Ll9ldGgsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sZj1mdW5jdGlvbih0KXt2YXIgZT10LmFiaS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuImV2ZW50Ij09PXQudHlwZX0pO25ldyBzKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpLmF0dGFjaFRvQ29udHJhY3QodCksZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sbD1mdW5jdGlvbih0LGUpe3ZhciByPTAsbj0hMSxvPXQuX2V0aC5maWx0ZXIoImxhdGVzdCIsZnVuY3Rpb24oaSl7aWYoIWkmJiFuKWlmKCsrcj41MCl7aWYoby5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKXt9KSxuPSEwLCFlKXRocm93IG5ldyBFcnJvcigiQ29udHJhY3QgdHJhbnNhY3Rpb24gY291bGRuJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzIik7ZShuZXcgRXJyb3IoIkNvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkbid0IGJlIGZvdW5kIGFmdGVyIDUwIGJsb2NrcyIpKX1lbHNlIHQuX2V0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodC50cmFuc2FjdGlvbkhhc2gsZnVuY3Rpb24ocixpKXtpJiZpLmJsb2NrSGFzaCYmIW4mJnQuX2V0aC5nZXRDb2RlKGkuY29udHJhY3RBZGRyZXNzLGZ1bmN0aW9uKHIsYSl7aWYoIW4mJmEpaWYoby5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKXt9KSxuPSEwLGEubGVuZ3RoPjMpdC5hZGRyZXNzPWkuY29udHJhY3RBZGRyZXNzLHUodCksZih0KSxlJiZlKG51bGwsdCk7ZWxzZXtpZighZSl0aHJvdyBuZXcgRXJyb3IoIlRoZSBjb250cmFjdCBjb2RlIGNvdWxkbid0IGJlIHN0b3JlZCwgcGxlYXNlIGNoZWNrIHlvdXIgZ2FzIGFtb3VudC4iKTtlKG5ldyBFcnJvcigiVGhlIGNvbnRyYWN0IGNvZGUgY291bGRuJ3QgYmUgc3RvcmVkLCBwbGVhc2UgY2hlY2sgeW91ciBnYXMgYW1vdW50LiIpKX19KX0pfSl9LHA9ZnVuY3Rpb24odCxlKXt0aGlzLmV0aD10LHRoaXMuYWJpPWUsdGhpcy5uZXc9ZnVuY3Rpb24oKXt2YXIgdCxyPW5ldyBoKHRoaXMuZXRoLHRoaXMuYWJpKSxvPXt9LGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtuLmlzRnVuY3Rpb24oaVtpLmxlbmd0aC0xXSkmJih0PWkucG9wKCkpO3ZhciBhPWlbaS5sZW5ndGgtMV07aWYoKG4uaXNPYmplY3QoYSkmJiFuLmlzQXJyYXkoYSkmJihvPWkucG9wKCkpLG8udmFsdWU+MCkmJiEoZS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuImNvbnN0cnVjdG9yIj09PXQudHlwZSYmdC5pbnB1dHMubGVuZ3RoPT09aS5sZW5ndGh9KVswXXx8e30pLnBheWFibGUpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBjb25zdHJ1Y3RvciIpO3ZhciBzPWModGhpcy5hYmksaSk7aWYoby5kYXRhKz1zLHQpdGhpcy5ldGguc2VuZFRyYW5zYWN0aW9uKG8sZnVuY3Rpb24oZSxuKXtlP3QoZSk6KHIudHJhbnNhY3Rpb25IYXNoPW4sdChudWxsLHIpLGwocix0KSl9KTtlbHNle3ZhciB1PXRoaXMuZXRoLnNlbmRUcmFuc2FjdGlvbihvKTtyLnRyYW5zYWN0aW9uSGFzaD11LGwocil9cmV0dXJuIHJ9LHRoaXMubmV3LmdldERhdGE9dGhpcy5nZXREYXRhLmJpbmQodGhpcyl9O3AucHJvdG90eXBlLmF0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9bmV3IGgodGhpcy5ldGgsdGhpcy5hYmksdCk7cmV0dXJuIHUociksZihyKSxlJiZlKG51bGwscikscn0scC5wcm90b3R5cGUuZ2V0RGF0YT1mdW5jdGlvbigpe3ZhciB0PXt9LGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxyPWVbZS5sZW5ndGgtMV07bi5pc09iamVjdChyKSYmIW4uaXNBcnJheShyKSYmKHQ9ZS5wb3AoKSk7dmFyIG89Yyh0aGlzLmFiaSxlKTtyZXR1cm4gdC5kYXRhKz1vLHQuZGF0YX07dmFyIGg9ZnVuY3Rpb24odCxlLHIpe3RoaXMuX2V0aD10LHRoaXMudHJhbnNhY3Rpb25IYXNoPW51bGwsdGhpcy5hZGRyZXNzPXIsdGhpcy5hYmk9ZX07ZS5leHBvcnRzPXB9LHsiLi4vc29saWRpdHkvY29kZXIiOjcsIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9hbGxldmVudHMiOjIzLCIuL2V2ZW50IjoyNywiLi9mdW5jdGlvbiI6MzF9XSwyNjpbZnVuY3Rpb24odCxlLHIpe2UuZXhwb3J0cz17SW52YWxpZE51bWJlck9mU29saWRpdHlBcmdzOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBFcnJvcigiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIFNvbGlkaXR5IGZ1bmN0aW9uIil9LEludmFsaWROdW1iZXJPZlJQQ1BhcmFtczpmdW5jdGlvbigpe3JldHVybiBuZXcgRXJyb3IoIkludmFsaWQgbnVtYmVyIG9mIGlucHV0IHBhcmFtZXRlcnMgdG8gUlBDIG1ldGhvZCIpfSxJbnZhbGlkQ29ubmVjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEVycm9yKCJDT05ORUNUSU9OIEVSUk9SOiBDb3VsZG4ndCBjb25uZWN0IHRvIG5vZGUgIit0KyIuIil9LEludmFsaWRQcm92aWRlcjpmdW5jdGlvbigpe3JldHVybiBuZXcgRXJyb3IoIlByb3ZpZGVyIG5vdCBzZXQgb3IgaW52YWxpZCIpfSxJbnZhbGlkUmVzcG9uc2U6ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5lcnJvciYmdC5lcnJvci5tZXNzYWdlP3QuZXJyb3IubWVzc2FnZToiSW52YWxpZCBKU09OIFJQQyByZXNwb25zZTogIitKU09OLnN0cmluZ2lmeSh0KTtyZXR1cm4gbmV3IEVycm9yKGUpfSxDb25uZWN0aW9uVGltZW91dDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEVycm9yKCJDT05ORUNUSU9OIFRJTUVPVVQ6IHRpbWVvdXQgb2YgIit0KyIgbXMgYWNoaXZlZCIpfX19LHt9XSwyNzpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9zb2xpZGl0eS9jb2RlciIpLGk9dCgiLi9mb3JtYXR0ZXJzIiksYT10KCIuLi91dGlscy9zaGEzIikscz10KCIuL2ZpbHRlciIpLGM9dCgiLi9tZXRob2RzL3dhdGNoZXMiKSx1PWZ1bmN0aW9uKHQsZSxyKXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10LHRoaXMuX3BhcmFtcz1lLmlucHV0cyx0aGlzLl9uYW1lPW4udHJhbnNmb3JtVG9GdWxsTmFtZShlKSx0aGlzLl9hZGRyZXNzPXIsdGhpcy5fYW5vbnltb3VzPWUuYW5vbnltb3VzfTt1LnByb3RvdHlwZS50eXBlcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5pbmRleGVkPT09dH0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlfSl9LHUucHJvdG90eXBlLmRpc3BsYXlOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG4uZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpfSx1LnByb3RvdHlwZS50eXBlTmFtZT1mdW5jdGlvbigpe3JldHVybiBuLmV4dHJhY3RUeXBlTmFtZSh0aGlzLl9uYW1lKX0sdS5wcm90b3R5cGUuc2lnbmF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcy5fbmFtZSl9LHUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUpe3Q9dHx8e30sZT1lfHx7fTt2YXIgcj17fTtbImZyb21CbG9jayIsInRvQmxvY2siXS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PWVbdF19KS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JbdF09aS5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKGVbdF0pfSksci50b3BpY3M9W10sci5hZGRyZXNzPXRoaXMuX2FkZHJlc3MsdGhpcy5fYW5vbnltb3VzfHxyLnRvcGljcy5wdXNoKCIweCIrdGhpcy5zaWduYXR1cmUoKSk7dmFyIGE9dGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hMD09PXQuaW5kZXhlZH0pLm1hcChmdW5jdGlvbihlKXt2YXIgcj10W2UubmFtZV07cmV0dXJuIG51bGw9PXI/bnVsbDpuLmlzQXJyYXkocik/ci5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIjB4IitvLmVuY29kZVBhcmFtKGUudHlwZSx0KX0pOiIweCIrby5lbmNvZGVQYXJhbShlLnR5cGUscil9KTtyZXR1cm4gci50b3BpY3M9ci50b3BpY3MuY29uY2F0KGEpLHJ9LHUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0KXt0LmRhdGE9dC5kYXRhfHwiIix0LnRvcGljcz10LnRvcGljc3x8W107dmFyIGU9KHRoaXMuX2Fub255bW91cz90LnRvcGljczp0LnRvcGljcy5zbGljZSgxKSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNsaWNlKDIpfSkuam9pbigiIikscj1vLmRlY29kZVBhcmFtcyh0aGlzLnR5cGVzKCEwKSxlKSxuPXQuZGF0YS5zbGljZSgyKSxhPW8uZGVjb2RlUGFyYW1zKHRoaXMudHlwZXMoITEpLG4pLHM9aS5vdXRwdXRMb2dGb3JtYXR0ZXIodCk7cmV0dXJuIHMuZXZlbnQ9dGhpcy5kaXNwbGF5TmFtZSgpLHMuYWRkcmVzcz10LmFkZHJlc3Mscy5hcmdzPXRoaXMuX3BhcmFtcy5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtlLm5hbWVdPWUuaW5kZXhlZD9yLnNoaWZ0KCk6YS5zaGlmdCgpLHR9LHt9KSxkZWxldGUgcy5kYXRhLGRlbGV0ZSBzLnRvcGljcyxzfSx1LnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKHQsZSxyKXtuLmlzRnVuY3Rpb24oYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0pJiYocj1hcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSwyPT09YXJndW1lbnRzLmxlbmd0aCYmKGU9bnVsbCksMT09PWFyZ3VtZW50cy5sZW5ndGgmJihlPW51bGwsdD17fSkpO3ZhciBvPXRoaXMuZW5jb2RlKHQsZSksaT10aGlzLmRlY29kZS5iaW5kKHRoaXMpO3JldHVybiBuZXcgcyhvLCJldGgiLHRoaXMuX3JlcXVlc3RNYW5hZ2VyLGMuZXRoKCksaSxyKX0sdS5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzKSxyPXRoaXMuZGlzcGxheU5hbWUoKTt0W3JdfHwodFtyXT1lKSx0W3JdW3RoaXMudHlwZU5hbWUoKV09dGhpcy5leGVjdXRlLmJpbmQodGhpcyx0KX0sZS5leHBvcnRzPXV9LHsiLi4vc29saWRpdHkvY29kZXIiOjcsIi4uL3V0aWxzL3NoYTMiOjE5LCIuLi91dGlscy91dGlscyI6MjAsIi4vZmlsdGVyIjoyOSwiLi9mb3JtYXR0ZXJzIjozMCwiLi9tZXRob2RzL3dhdGNoZXMiOjQzfV0sMjg6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4vbWV0aG9kIiksYT10KCIuL3Byb3BlcnR5Iik7ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKGUpe3ZhciByO2UucHJvcGVydHk/KHRbZS5wcm9wZXJ0eV18fCh0W2UucHJvcGVydHldPXt9KSxyPXRbZS5wcm9wZXJ0eV0pOnI9dCxlLm1ldGhvZHMmJmUubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuYXR0YWNoVG9PYmplY3QociksZS5zZXRSZXF1ZXN0TWFuYWdlcih0Ll9yZXF1ZXN0TWFuYWdlcil9KSxlLnByb3BlcnRpZXMmJmUucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuYXR0YWNoVG9PYmplY3QociksZS5zZXRSZXF1ZXN0TWFuYWdlcih0Ll9yZXF1ZXN0TWFuYWdlcil9KX07cmV0dXJuIGUuZm9ybWF0dGVycz1uLGUudXRpbHM9byxlLk1ldGhvZD1pLGUuUHJvcGVydHk9YSxlfX0seyIuLy4uL3V0aWxzL3V0aWxzIjoyMCwiLi9mb3JtYXR0ZXJzIjozMCwiLi9tZXRob2QiOjM2LCIuL3Byb3BlcnR5Ijo0NX1dLDI5OltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuLi91dGlscy91dGlscyIpLGk9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/bnVsbDowPT09KHQ9U3RyaW5nKHQpKS5pbmRleE9mKCIweCIpP3Q6by5mcm9tVXRmOCh0KX0sYT1mdW5jdGlvbih0LGUpe28uaXNTdHJpbmcodC5vcHRpb25zKXx8dC5nZXQoZnVuY3Rpb24odCxyKXt0JiZlKHQpLG8uaXNBcnJheShyKSYmci5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UobnVsbCx0KX0pfSl9LHM9ZnVuY3Rpb24odCl7dC5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe21ldGhvZDp0LmltcGxlbWVudGF0aW9uLnBvbGwuY2FsbCxwYXJhbXM6W3QuZmlsdGVySWRdfSx0LmZpbHRlcklkLGZ1bmN0aW9uKGUscil7aWYoZSlyZXR1cm4gdC5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbih0KXt0KGUpfSk7by5pc0FycmF5KHIpJiZyLmZvckVhY2goZnVuY3Rpb24oZSl7ZT10LmZvcm1hdHRlcj90LmZvcm1hdHRlcihlKTplLHQuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7dChudWxsLGUpfSl9KX0sdC5zdG9wV2F0Y2hpbmcuYmluZCh0KSl9LGM9ZnVuY3Rpb24odCxlLHIsYyx1LGYsbCl7dmFyIHA9dGhpcyxoPXt9O3JldHVybiBjLmZvckVhY2goZnVuY3Rpb24odCl7dC5zZXRSZXF1ZXN0TWFuYWdlcihyKSx0LmF0dGFjaFRvT2JqZWN0KGgpfSksdGhpcy5yZXF1ZXN0TWFuYWdlcj1yLHRoaXMub3B0aW9ucz1mdW5jdGlvbih0LGUpe2lmKG8uaXNTdHJpbmcodCkpcmV0dXJuIHQ7c3dpdGNoKHQ9dHx8e30sZSl7Y2FzZSJldGgiOnJldHVybiB0LnRvcGljcz10LnRvcGljc3x8W10sdC50b3BpY3M9dC50b3BpY3MubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBvLmlzQXJyYXkodCk/dC5tYXAoaSk6aSh0KX0pLHt0b3BpY3M6dC50b3BpY3MsZnJvbTp0LmZyb20sdG86dC50byxhZGRyZXNzOnQuYWRkcmVzcyxmcm9tQmxvY2s6bi5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKHQuZnJvbUJsb2NrKSx0b0Jsb2NrOm4uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcih0LnRvQmxvY2spfTtjYXNlInNoaCI6cmV0dXJuIHR9fSh0LGUpLHRoaXMuaW1wbGVtZW50YXRpb249aCx0aGlzLmZpbHRlcklkPW51bGwsdGhpcy5jYWxsYmFja3M9W10sdGhpcy5nZXRMb2dzQ2FsbGJhY2tzPVtdLHRoaXMucG9sbEZpbHRlcnM9W10sdGhpcy5mb3JtYXR0ZXI9dSx0aGlzLmltcGxlbWVudGF0aW9uLm5ld0ZpbHRlcih0aGlzLm9wdGlvbnMsZnVuY3Rpb24odCxlKXtpZih0KXAuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oZSl7ZSh0KX0pLCJmdW5jdGlvbiI9PXR5cGVvZiBsJiZsKHQpO2Vsc2UgaWYocC5maWx0ZXJJZD1lLHAuZ2V0TG9nc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3AuZ2V0KHQpfSkscC5nZXRMb2dzQ2FsbGJhY2tzPVtdLHAuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7YShwLHQpfSkscC5jYWxsYmFja3MubGVuZ3RoPjAmJnMocCksImZ1bmN0aW9uIj09dHlwZW9mIGYpcmV0dXJuIHAud2F0Y2goZil9KSx0aGlzfTtjLnByb3RvdHlwZS53YXRjaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYWxsYmFja3MucHVzaCh0KSx0aGlzLmZpbHRlcklkJiYoYSh0aGlzLHQpLHModGhpcykpLHRoaXN9LGMucHJvdG90eXBlLnN0b3BXYXRjaGluZz1mdW5jdGlvbih0KXtpZih0aGlzLnJlcXVlc3RNYW5hZ2VyLnN0b3BQb2xsaW5nKHRoaXMuZmlsdGVySWQpLHRoaXMuY2FsbGJhY2tzPVtdLCF0KXJldHVybiB0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkKTt0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkLHQpfSxjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZighby5pc0Z1bmN0aW9uKHQpKXtpZihudWxsPT09dGhpcy5maWx0ZXJJZCl0aHJvdyBuZXcgRXJyb3IoIkZpbHRlciBJRCBFcnJvcjogZmlsdGVyKCkuZ2V0KCkgY2FuJ3QgYmUgY2hhaW5lZCBzeW5jaHJvbm91cywgcGxlYXNlIHByb3ZpZGUgYSBjYWxsYmFjayBmb3IgdGhlIGdldCgpIG1ldGhvZC4iKTtyZXR1cm4gdGhpcy5pbXBsZW1lbnRhdGlvbi5nZXRMb2dzKHRoaXMuZmlsdGVySWQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5mb3JtYXR0ZXI/ZS5mb3JtYXR0ZXIodCk6dH0pfXJldHVybiBudWxsPT09dGhpcy5maWx0ZXJJZD90aGlzLmdldExvZ3NDYWxsYmFja3MucHVzaCh0KTp0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCxmdW5jdGlvbihyLG4pe3I/dChyKTp0KG51bGwsbi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuZm9ybWF0dGVyP2UuZm9ybWF0dGVyKHQpOnR9KSl9KSx0aGlzfSxlLmV4cG9ydHM9Y30seyIuLi91dGlscy91dGlscyI6MjAsIi4vZm9ybWF0dGVycyI6MzB9XSwzMDpbZnVuY3Rpb24odCxlLHIpeyJ1c2Ugc3RyaWN0Ijt2YXIgbj10KCIuLi91dGlscy91dGlscyIpLG89dCgiLi4vdXRpbHMvY29uZmlnIiksaT10KCIuL2liYW4iKSxhPWZ1bmN0aW9uKHQpe3ZhciBlO2lmKHZvaWQgMCE9PXQpcmV0dXJuImxhdGVzdCI9PT0oZT10KXx8InBlbmRpbmciPT09ZXx8ImVhcmxpZXN0Ij09PWU/dDpuLnRvSGV4KHQpfSxzPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dC5ibG9ja051bWJlciYmKHQuYmxvY2tOdW1iZXI9bi50b0RlY2ltYWwodC5ibG9ja051bWJlcikpLG51bGwhPT10LnRyYW5zYWN0aW9uSW5kZXgmJih0LnRyYW5zYWN0aW9uSW5kZXg9bi50b0RlY2ltYWwodC50cmFuc2FjdGlvbkluZGV4KSksdC5ub25jZT1uLnRvRGVjaW1hbCh0Lm5vbmNlKSx0Lmdhcz1uLnRvRGVjaW1hbCh0LmdhcyksdC5nYXNQcmljZT1uLnRvQmlnTnVtYmVyKHQuZ2FzUHJpY2UpLHQudmFsdWU9bi50b0JpZ051bWJlcih0LnZhbHVlKSx0fSxjPWZ1bmN0aW9uKHQpe3JldHVybiB0LmJsb2NrTnVtYmVyJiYodC5ibG9ja051bWJlcj1uLnRvRGVjaW1hbCh0LmJsb2NrTnVtYmVyKSksdC50cmFuc2FjdGlvbkluZGV4JiYodC50cmFuc2FjdGlvbkluZGV4PW4udG9EZWNpbWFsKHQudHJhbnNhY3Rpb25JbmRleCkpLHQubG9nSW5kZXgmJih0LmxvZ0luZGV4PW4udG9EZWNpbWFsKHQubG9nSW5kZXgpKSx0fSx1PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBpKHQpO2lmKGUuaXNWYWxpZCgpJiZlLmlzRGlyZWN0KCkpcmV0dXJuIjB4IitlLmFkZHJlc3MoKTtpZihuLmlzU3RyaWN0QWRkcmVzcyh0KSlyZXR1cm4gdDtpZihuLmlzQWRkcmVzcyh0KSlyZXR1cm4iMHgiK3Q7dGhyb3cgbmV3IEVycm9yKCJpbnZhbGlkIGFkZHJlc3MiKX07ZS5leHBvcnRzPXtpbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dD9vLmRlZmF1bHRCbG9jazphKHQpfSxpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyOmEsaW5wdXRDYWxsRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0LmZyb209dC5mcm9tfHxvLmRlZmF1bHRBY2NvdW50LHQuZnJvbSYmKHQuZnJvbT11KHQuZnJvbSkpLHQudG8mJih0LnRvPXUodC50bykpLFsiZ2FzUHJpY2UiLCJnYXMiLCJ2YWx1ZSIsIm5vbmNlIl0uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT10W2VdfSkuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPW4uZnJvbURlY2ltYWwodFtlXSl9KSx0fSxpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0LmZyb209dC5mcm9tfHxvLmRlZmF1bHRBY2NvdW50LHQuZnJvbT11KHQuZnJvbSksdC50byYmKHQudG89dSh0LnRvKSksWyJnYXNQcmljZSIsImdhcyIsInZhbHVlIiwibm9uY2UiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PXRbZV19KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV09bi5mcm9tRGVjaW1hbCh0W2VdKX0pLHR9LGlucHV0QWRkcmVzc0Zvcm1hdHRlcjp1LGlucHV0UG9zdEZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC50dGw9bi5mcm9tRGVjaW1hbCh0LnR0bCksdC53b3JrVG9Qcm92ZT1uLmZyb21EZWNpbWFsKHQud29ya1RvUHJvdmUpLHQucHJpb3JpdHk9bi5mcm9tRGVjaW1hbCh0LnByaW9yaXR5KSxuLmlzQXJyYXkodC50b3BpY3MpfHwodC50b3BpY3M9dC50b3BpY3M/W3QudG9waWNzXTpbXSksdC50b3BpY3M9dC50b3BpY3MubWFwKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5pbmRleE9mKCIweCIpP3Q6bi5mcm9tVXRmOCh0KX0pLHR9LG91dHB1dEJpZ051bWJlckZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gbi50b0JpZ051bWJlcih0KX0sb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXI6cyxvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10LmJsb2NrTnVtYmVyJiYodC5ibG9ja051bWJlcj1uLnRvRGVjaW1hbCh0LmJsb2NrTnVtYmVyKSksbnVsbCE9PXQudHJhbnNhY3Rpb25JbmRleCYmKHQudHJhbnNhY3Rpb25JbmRleD1uLnRvRGVjaW1hbCh0LnRyYW5zYWN0aW9uSW5kZXgpKSx0LmN1bXVsYXRpdmVHYXNVc2VkPW4udG9EZWNpbWFsKHQuY3VtdWxhdGl2ZUdhc1VzZWQpLHQuZ2FzVXNlZD1uLnRvRGVjaW1hbCh0Lmdhc1VzZWQpLG4uaXNBcnJheSh0LmxvZ3MpJiYodC5sb2dzPXQubG9ncy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGModCl9KSksdH0sb3V0cHV0QmxvY2tGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2FzTGltaXQ9bi50b0RlY2ltYWwodC5nYXNMaW1pdCksdC5nYXNVc2VkPW4udG9EZWNpbWFsKHQuZ2FzVXNlZCksdC5zaXplPW4udG9EZWNpbWFsKHQuc2l6ZSksdC50aW1lc3RhbXA9bi50b0RlY2ltYWwodC50aW1lc3RhbXApLG51bGwhPT10Lm51bWJlciYmKHQubnVtYmVyPW4udG9EZWNpbWFsKHQubnVtYmVyKSksdC5kaWZmaWN1bHR5PW4udG9CaWdOdW1iZXIodC5kaWZmaWN1bHR5KSx0LnRvdGFsRGlmZmljdWx0eT1uLnRvQmlnTnVtYmVyKHQudG90YWxEaWZmaWN1bHR5KSxuLmlzQXJyYXkodC50cmFuc2FjdGlvbnMpJiZ0LnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKCFuLmlzU3RyaW5nKHQpKXJldHVybiBzKHQpfSksdH0sb3V0cHV0TG9nRm9ybWF0dGVyOmMsb3V0cHV0UG9zdEZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5leHBpcnk9bi50b0RlY2ltYWwodC5leHBpcnkpLHQuc2VudD1uLnRvRGVjaW1hbCh0LnNlbnQpLHQudHRsPW4udG9EZWNpbWFsKHQudHRsKSx0LndvcmtQcm92ZWQ9bi50b0RlY2ltYWwodC53b3JrUHJvdmVkKSx0LnRvcGljc3x8KHQudG9waWNzPVtdKSx0LnRvcGljcz10LnRvcGljcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4udG9Bc2NpaSh0KX0pLHR9LG91dHB1dFN5bmNpbmdGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQ/KHQuc3RhcnRpbmdCbG9jaz1uLnRvRGVjaW1hbCh0LnN0YXJ0aW5nQmxvY2spLHQuY3VycmVudEJsb2NrPW4udG9EZWNpbWFsKHQuY3VycmVudEJsb2NrKSx0LmhpZ2hlc3RCbG9jaz1uLnRvRGVjaW1hbCh0LmhpZ2hlc3RCbG9jayksdC5rbm93blN0YXRlcyYmKHQua25vd25TdGF0ZXM9bi50b0RlY2ltYWwodC5rbm93blN0YXRlcyksdC5wdWxsZWRTdGF0ZXM9bi50b0RlY2ltYWwodC5wdWxsZWRTdGF0ZXMpKSx0KTp0fX19LHsiLi4vdXRpbHMvY29uZmlnIjoxOCwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2liYW4iOjMzfV0sMzE6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCIuLi9zb2xpZGl0eS9jb2RlciIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4vZXJyb3JzIiksYT10KCIuL2Zvcm1hdHRlcnMiKSxzPXQoIi4uL3V0aWxzL3NoYTMiKSxjPWZ1bmN0aW9uKHQsZSxyKXt0aGlzLl9ldGg9dCx0aGlzLl9pbnB1dFR5cGVzPWUuaW5wdXRzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlfSksdGhpcy5fb3V0cHV0VHlwZXM9ZS5vdXRwdXRzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlfSksdGhpcy5fY29uc3RhbnQ9ZS5jb25zdGFudCx0aGlzLl9wYXlhYmxlPWUucGF5YWJsZSx0aGlzLl9uYW1lPW8udHJhbnNmb3JtVG9GdWxsTmFtZShlKSx0aGlzLl9hZGRyZXNzPXJ9O2MucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjaz1mdW5jdGlvbih0KXtpZihvLmlzRnVuY3Rpb24odFt0Lmxlbmd0aC0xXSkpcmV0dXJuIHQucG9wKCl9LGMucHJvdG90eXBlLmV4dHJhY3REZWZhdWx0QmxvY2s9ZnVuY3Rpb24odCl7aWYodC5sZW5ndGg+dGhpcy5faW5wdXRUeXBlcy5sZW5ndGgmJiFvLmlzT2JqZWN0KHRbdC5sZW5ndGgtMV0pKXJldHVybiBhLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyKHQucG9wKCkpfSxjLnByb3RvdHlwZS52YWxpZGF0ZUFyZ3M9ZnVuY3Rpb24odCl7aWYodC5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuISghMD09PW8uaXNPYmplY3QodCkmJiExPT09by5pc0FycmF5KHQpJiYhMT09PW8uaXNCaWdOdW1iZXIodCkpfSkubGVuZ3RoIT09dGhpcy5faW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgaS5JbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3MoKX0sYy5wcm90b3R5cGUudG9QYXlsb2FkPWZ1bmN0aW9uKHQpe3ZhciBlPXt9O3JldHVybiB0Lmxlbmd0aD50aGlzLl9pbnB1dFR5cGVzLmxlbmd0aCYmby5pc09iamVjdCh0W3QubGVuZ3RoLTFdKSYmKGU9dFt0Lmxlbmd0aC0xXSksdGhpcy52YWxpZGF0ZUFyZ3ModCksZS50bz10aGlzLl9hZGRyZXNzLGUuZGF0YT0iMHgiK3RoaXMuc2lnbmF0dXJlKCkrbi5lbmNvZGVQYXJhbXModGhpcy5faW5wdXRUeXBlcyx0KSxlfSxjLnByb3RvdHlwZS5zaWduYXR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gcyh0aGlzLl9uYW1lKS5zbGljZSgwLDgpfSxjLnByb3RvdHlwZS51bnBhY2tPdXRwdXQ9ZnVuY3Rpb24odCl7aWYodCl7dD10Lmxlbmd0aD49Mj90LnNsaWNlKDIpOnQ7dmFyIGU9bi5kZWNvZGVQYXJhbXModGhpcy5fb3V0cHV0VHlwZXMsdCk7cmV0dXJuIDE9PT1lLmxlbmd0aD9lWzBdOmV9fSxjLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSxlPXRoaXMuZXh0cmFjdENhbGxiYWNrKHQpLHI9dGhpcy5leHRyYWN0RGVmYXVsdEJsb2NrKHQpLG49dGhpcy50b1BheWxvYWQodCk7aWYoIWUpe3ZhciBvPXRoaXMuX2V0aC5jYWxsKG4scik7cmV0dXJuIHRoaXMudW5wYWNrT3V0cHV0KG8pfXZhciBpPXRoaXM7dGhpcy5fZXRoLmNhbGwobixyLGZ1bmN0aW9uKHQscil7aWYodClyZXR1cm4gZSh0LG51bGwpO3ZhciBuPW51bGw7dHJ5e249aS51bnBhY2tPdXRwdXQocil9Y2F0Y2goZSl7dD1lfWUodCxuKX0pfSxjLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb249ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pLGU9dGhpcy5leHRyYWN0Q2FsbGJhY2sodCkscj10aGlzLnRvUGF5bG9hZCh0KTtpZihyLnZhbHVlPjAmJiF0aGlzLl9wYXlhYmxlKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZnVuY3Rpb24iKTtpZighZSlyZXR1cm4gdGhpcy5fZXRoLnNlbmRUcmFuc2FjdGlvbihyKTt0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKHIsZSl9LGMucHJvdG90eXBlLmVzdGltYXRlR2FzPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxlPXRoaXMuZXh0cmFjdENhbGxiYWNrKHQpLHI9dGhpcy50b1BheWxvYWQodCk7aWYoIWUpcmV0dXJuIHRoaXMuX2V0aC5lc3RpbWF0ZUdhcyhyKTt0aGlzLl9ldGguZXN0aW1hdGVHYXMocixlKX0sYy5wcm90b3R5cGUuZ2V0RGF0YT1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMudG9QYXlsb2FkKHQpLmRhdGF9LGMucHJvdG90eXBlLmRpc3BsYXlOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG8uZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpfSxjLnByb3RvdHlwZS50eXBlTmFtZT1mdW5jdGlvbigpe3JldHVybiBvLmV4dHJhY3RUeXBlTmFtZSh0aGlzLl9uYW1lKX0sYy5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksZT10aGlzLmV4dHJhY3RDYWxsYmFjayh0KSxyPXRoaXMudG9QYXlsb2FkKHQpLG49dGhpcy51bnBhY2tPdXRwdXQuYmluZCh0aGlzKTtyZXR1cm57bWV0aG9kOnRoaXMuX2NvbnN0YW50PyJldGhfY2FsbCI6ImV0aF9zZW5kVHJhbnNhY3Rpb24iLGNhbGxiYWNrOmUscGFyYW1zOltyXSxmb3JtYXQ6bn19LGMucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fY29uc3RhbnQ/dGhpcy5zZW5kVHJhbnNhY3Rpb24uYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTp0aGlzLmNhbGwuYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKX0sYy5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtlLnJlcXVlc3Q9dGhpcy5yZXF1ZXN0LmJpbmQodGhpcyksZS5jYWxsPXRoaXMuY2FsbC5iaW5kKHRoaXMpLGUuc2VuZFRyYW5zYWN0aW9uPXRoaXMuc2VuZFRyYW5zYWN0aW9uLmJpbmQodGhpcyksZS5lc3RpbWF0ZUdhcz10aGlzLmVzdGltYXRlR2FzLmJpbmQodGhpcyksZS5nZXREYXRhPXRoaXMuZ2V0RGF0YS5iaW5kKHRoaXMpO3ZhciByPXRoaXMuZGlzcGxheU5hbWUoKTt0W3JdfHwodFtyXT1lKSx0W3JdW3RoaXMudHlwZU5hbWUoKV09ZX0sZS5leHBvcnRzPWN9LHsiLi4vc29saWRpdHkvY29kZXIiOjcsIi4uL3V0aWxzL3NoYTMiOjE5LCIuLi91dGlscy91dGlscyI6MjAsIi4vZXJyb3JzIjoyNiwiLi9mb3JtYXR0ZXJzIjozMH1dLDMyOltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9lcnJvcnMiKTsidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LlhNTEh0dHBSZXF1ZXN0P1hNTEh0dHBSZXF1ZXN0PXdpbmRvdy5YTUxIdHRwUmVxdWVzdDpYTUxIdHRwUmVxdWVzdD10KCJ4bWxodHRwcmVxdWVzdCIpLlhNTEh0dHBSZXF1ZXN0O3ZhciBvPXQoInhocjIiKSxpPWZ1bmN0aW9uKHQsZSxyLG4sbyl7dGhpcy5ob3N0PXR8fCJodHRwOi8vbG9jYWxob3N0Ojg1NDUiLHRoaXMudGltZW91dD1lfHwwLHRoaXMudXNlcj1yLHRoaXMucGFzc3dvcmQ9bix0aGlzLmhlYWRlcnM9b307aS5wcm90b3R5cGUucHJlcGFyZVJlcXVlc3Q9ZnVuY3Rpb24odCl7dmFyIGU7aWYodD8oZT1uZXcgbykudGltZW91dD10aGlzLnRpbWVvdXQ6ZT1uZXcgWE1MSHR0cFJlcXVlc3QsZS5vcGVuKCJQT1NUIix0aGlzLmhvc3QsdCksdGhpcy51c2VyJiZ0aGlzLnBhc3N3b3JkKXt2YXIgcj0iQmFzaWMgIituZXcgQnVmZmVyKHRoaXMudXNlcisiOiIrdGhpcy5wYXNzd29yZCkudG9TdHJpbmcoImJhc2U2NCIpO2Uuc2V0UmVxdWVzdEhlYWRlcigiQXV0aG9yaXphdGlvbiIscil9cmV0dXJuIGUuc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1UeXBlIiwiYXBwbGljYXRpb24vanNvbiIpLHRoaXMuaGVhZGVycyYmdGhpcy5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odCl7ZS5zZXRSZXF1ZXN0SGVhZGVyKHQubmFtZSx0LnZhbHVlKX0pLGV9LGkucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcmVwYXJlUmVxdWVzdCghMSk7dHJ5e2Uuc2VuZChKU09OLnN0cmluZ2lmeSh0KSl9Y2F0Y2godCl7dGhyb3cgbi5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpfXZhciByPWUucmVzcG9uc2VUZXh0O3RyeXtyPUpTT04ucGFyc2Uocil9Y2F0Y2godCl7dGhyb3cgbi5JbnZhbGlkUmVzcG9uc2UoZS5yZXNwb25zZVRleHQpfXJldHVybiByfSxpLnByb3RvdHlwZS5zZW5kQXN5bmM9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLnByZXBhcmVSZXF1ZXN0KCEwKTtyLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKDQ9PT1yLnJlYWR5U3RhdGUmJjEhPT1yLnRpbWVvdXQpe3ZhciB0PXIucmVzcG9uc2VUZXh0LG89bnVsbDt0cnl7dD1KU09OLnBhcnNlKHQpfWNhdGNoKHQpe289bi5JbnZhbGlkUmVzcG9uc2Uoci5yZXNwb25zZVRleHQpfWUobyx0KX19LHIub250aW1lb3V0PWZ1bmN0aW9uKCl7ZShuLkNvbm5lY3Rpb25UaW1lb3V0KHRoaXMudGltZW91dCkpfTt0cnl7ci5zZW5kKEpTT04uc3RyaW5naWZ5KHQpKX1jYXRjaCh0KXtlKG4uSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KSl9fSxpLnByb3RvdHlwZS5pc0Nvbm5lY3RlZD1mdW5jdGlvbigpe3RyeXtyZXR1cm4gdGhpcy5zZW5kKHtpZDo5OTk5OTk5OTk5LGpzb25ycGM6IjIuMCIsbWV0aG9kOiJuZXRfbGlzdGVuaW5nIixwYXJhbXM6W119KSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19LGUuZXhwb3J0cz1pfSx7Ii4vZXJyb3JzIjoyNix4aHIyOjg1LHhtbGh0dHByZXF1ZXN0OjE3fV0sMzM6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCJiaWdudW1iZXIuanMiKSxvPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPXQ7ci5sZW5ndGg8MiplOylyPSIwIityO3JldHVybiByfSxpPWZ1bmN0aW9uKHQpe3ZhciBlPSJBIi5jaGFyQ29kZUF0KDApLHI9IloiLmNoYXJDb2RlQXQoMCk7cmV0dXJuKHQ9KHQ9dC50b1VwcGVyQ2FzZSgpKS5zdWJzdHIoNCkrdC5zdWJzdHIoMCw0KSkuc3BsaXQoIiIpLm1hcChmdW5jdGlvbih0KXt2YXIgbj10LmNoYXJDb2RlQXQoMCk7cmV0dXJuIG4+PWUmJm48PXI/bi1lKzEwOnR9KS5qb2luKCIiKX0sYT1mdW5jdGlvbih0KXtmb3IodmFyIGUscj10O3IubGVuZ3RoPjI7KWU9ci5zbGljZSgwLDkpLHI9cGFyc2VJbnQoZSwxMCklOTcrci5zbGljZShlLmxlbmd0aCk7cmV0dXJuIHBhcnNlSW50KHIsMTApJTk3fSxzPWZ1bmN0aW9uKHQpe3RoaXMuX2liYW49dH07cy5mcm9tQWRkcmVzcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgbih0LDE2KS50b1N0cmluZygzNikscj1vKGUsMTUpO3JldHVybiBzLmZyb21CYmFuKHIudG9VcHBlckNhc2UoKSl9LHMuZnJvbUJiYW49ZnVuY3Rpb24odCl7dmFyIGU9KCIwIisoOTgtYShpKCJYRTAwIit0KSkpKS5zbGljZSgtMik7cmV0dXJuIG5ldyBzKCJYRSIrZSt0KX0scy5jcmVhdGVJbmRpcmVjdD1mdW5jdGlvbih0KXtyZXR1cm4gcy5mcm9tQmJhbigiRVRIIit0Lmluc3RpdHV0aW9uK3QuaWRlbnRpZmllcil9LHMuaXNWYWxpZD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHModCkuaXNWYWxpZCgpfSxzLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuL15YRVswLTldezJ9KEVUSFswLTlBLVpdezEzfXxbMC05QS1aXXszMCwzMX0pJC8udGVzdCh0aGlzLl9pYmFuKSYmMT09PWEoaSh0aGlzLl9pYmFuKSl9LHMucHJvdG90eXBlLmlzRGlyZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIDM0PT09dGhpcy5faWJhbi5sZW5ndGh8fDM1PT09dGhpcy5faWJhbi5sZW5ndGh9LHMucHJvdG90eXBlLmlzSW5kaXJlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gMjA9PT10aGlzLl9pYmFuLmxlbmd0aH0scy5wcm90b3R5cGUuY2hlY2tzdW09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWJhbi5zdWJzdHIoMiwyKX0scy5wcm90b3R5cGUuaW5zdGl0dXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0luZGlyZWN0KCk/dGhpcy5faWJhbi5zdWJzdHIoNyw0KToiIn0scy5wcm90b3R5cGUuY2xpZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpP3RoaXMuX2liYW4uc3Vic3RyKDExKToiIn0scy5wcm90b3R5cGUuYWRkcmVzcz1mdW5jdGlvbigpe2lmKHRoaXMuaXNEaXJlY3QoKSl7dmFyIHQ9dGhpcy5faWJhbi5zdWJzdHIoNCksZT1uZXcgbih0LDM2KTtyZXR1cm4gbyhlLnRvU3RyaW5nKDE2KSwyMCl9cmV0dXJuIiJ9LHMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2liYW59LGUuZXhwb3J0cz1zfSx7ImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwzNDpbZnVuY3Rpb24odCxlLHIpeyJ1c2Ugc3RyaWN0Ijt2YXIgbj10KCIuLi91dGlscy91dGlscyIpLG89dCgiLi9lcnJvcnMiKSxpPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpczt0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzPXt9LHRoaXMucGF0aD10LHRoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Qoe3BhdGg6dGhpcy5wYXRofSksdGhpcy5jb25uZWN0aW9uLm9uKCJlcnJvciIsZnVuY3Rpb24odCl7Y29uc29sZS5lcnJvcigiSVBDIENvbm5lY3Rpb24gRXJyb3IiLHQpLHIuX3RpbWVvdXQoKX0pLHRoaXMuY29ubmVjdGlvbi5vbigiZW5kIixmdW5jdGlvbigpe3IuX3RpbWVvdXQoKX0pLHRoaXMuY29ubmVjdGlvbi5vbigiZGF0YSIsZnVuY3Rpb24odCl7ci5fcGFyc2VSZXNwb25zZSh0LnRvU3RyaW5nKCkpLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9bnVsbDtuLmlzQXJyYXkodCk/dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3IucmVzcG9uc2VDYWxsYmFja3NbdC5pZF0mJihlPXQuaWQpfSk6ZT10LmlkLHIucmVzcG9uc2VDYWxsYmFja3NbZV0mJihyLnJlc3BvbnNlQ2FsbGJhY2tzW2VdKG51bGwsdCksZGVsZXRlIHIucmVzcG9uc2VDYWxsYmFja3NbZV0pfSl9KX07aS5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPVtdO3JldHVybiB0LnJlcGxhY2UoL1x9W1xuXHJdP1x7L2csIn18LS18eyIpLnJlcGxhY2UoL1x9XF1bXG5ccl0/XFtcey9nLCJ9XXwtLXxbeyIpLnJlcGxhY2UoL1x9W1xuXHJdP1xbXHsvZywifXwtLXxbeyIpLnJlcGxhY2UoL1x9XF1bXG5ccl0/XHsvZywifV18LS18eyIpLnNwbGl0KCJ8LS18IikuZm9yRWFjaChmdW5jdGlvbih0KXtlLmxhc3RDaHVuayYmKHQ9ZS5sYXN0Q2h1bmsrdCk7dmFyIG49bnVsbDt0cnl7bj1KU09OLnBhcnNlKHQpfWNhdGNoKHIpe3JldHVybiBlLmxhc3RDaHVuaz10LGNsZWFyVGltZW91dChlLmxhc3RDaHVua1RpbWVvdXQpLHZvaWQoZS5sYXN0Q2h1bmtUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlLl90aW1lb3V0KCksby5JbnZhbGlkUmVzcG9uc2UodCl9LDE1ZTMpKX1jbGVhclRpbWVvdXQoZS5sYXN0Q2h1bmtUaW1lb3V0KSxlLmxhc3RDaHVuaz1udWxsLG4mJnIucHVzaChuKX0pLHJ9LGkucHJvdG90eXBlLl9hZGRSZXNwb25zZUNhbGxiYWNrPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5pZHx8dFswXS5pZCxuPXQubWV0aG9kfHx0WzBdLm1ldGhvZDt0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW3JdPWUsdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tyXS5tZXRob2Q9bn0saS5wcm90b3R5cGUuX3RpbWVvdXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5yZXNwb25zZUNhbGxiYWNrcyl0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KHQpJiYodGhpcy5yZXNwb25zZUNhbGxiYWNrc1t0XShvLkludmFsaWRDb25uZWN0aW9uKCJvbiBJUEMiKSksZGVsZXRlIHRoaXMucmVzcG9uc2VDYWxsYmFja3NbdF0pfSxpLnByb3RvdHlwZS5pc0Nvbm5lY3RlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbm5lY3Rpb24ud3JpdGFibGV8fHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOnRoaXMucGF0aH0pLCEhdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlfSxpLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHQpe2lmKHRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMpe3ZhciBlO3RoaXMuY29ubmVjdGlvbi53cml0YWJsZXx8dGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6dGhpcy5wYXRofSk7dmFyIHI9dGhpcy5jb25uZWN0aW9uLndyaXRlU3luYyhKU09OLnN0cmluZ2lmeSh0KSk7dHJ5e2U9SlNPTi5wYXJzZShyKX1jYXRjaCh0KXt0aHJvdyBvLkludmFsaWRSZXNwb25zZShyKX1yZXR1cm4gZX10aHJvdyBuZXcgRXJyb3IoJ1lvdSB0cmllZCB0byBzZW5kICInK3QubWV0aG9kKyciIHN5bmNocm9ub3VzbHkuIFN5bmNocm9ub3VzIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBJUEMgcHJvdmlkZXIuJyl9LGkucHJvdG90eXBlLnNlbmRBc3luYz1mdW5jdGlvbih0LGUpe3RoaXMuY29ubmVjdGlvbi53cml0YWJsZXx8dGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6dGhpcy5wYXRofSksdGhpcy5jb25uZWN0aW9uLndyaXRlKEpTT04uc3RyaW5naWZ5KHQpKSx0aGlzLl9hZGRSZXNwb25zZUNhbGxiYWNrKHQsZSl9LGUuZXhwb3J0cz1pfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMCwiLi9lcnJvcnMiOjI2fV0sMzU6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj17bWVzc2FnZUlkOjAsdG9QYXlsb2FkOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR8fGNvbnNvbGUuZXJyb3IoImpzb25ycGMgbWV0aG9kIHNob3VsZCBiZSBzcGVjaWZpZWQhIiksbi5tZXNzYWdlSWQrKyx7anNvbnJwYzoiMi4wIixpZDpuLm1lc3NhZ2VJZCxtZXRob2Q6dCxwYXJhbXM6ZXx8W119fSxpc1ZhbGlkUmVzcG9uc2U6ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dC5ldmVyeShlKTplKHQpO2Z1bmN0aW9uIGUodCl7cmV0dXJuISF0JiYhdC5lcnJvciYmIjIuMCI9PT10Lmpzb25ycGMmJiJudW1iZXIiPT10eXBlb2YgdC5pZCYmdm9pZCAwIT09dC5yZXN1bHR9fSx0b0JhdGNoUGF5bG9hZDpmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4udG9QYXlsb2FkKHQubWV0aG9kLHQucGFyYW1zKX0pfX07ZS5leHBvcnRzPW59LHt9XSwzNjpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuL2Vycm9ycyIpLGk9ZnVuY3Rpb24odCl7dGhpcy5uYW1lPXQubmFtZSx0aGlzLmNhbGw9dC5jYWxsLHRoaXMucGFyYW1zPXQucGFyYW1zfHwwLHRoaXMuaW5wdXRGb3JtYXR0ZXI9dC5pbnB1dEZvcm1hdHRlcix0aGlzLm91dHB1dEZvcm1hdHRlcj10Lm91dHB1dEZvcm1hdHRlcix0aGlzLnJlcXVlc3RNYW5hZ2VyPW51bGx9O2kucHJvdG90eXBlLnNldFJlcXVlc3RNYW5hZ2VyPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdE1hbmFnZXI9dH0saS5wcm90b3R5cGUuZ2V0Q2FsbD1mdW5jdGlvbih0KXtyZXR1cm4gbi5pc0Z1bmN0aW9uKHRoaXMuY2FsbCk/dGhpcy5jYWxsKHQpOnRoaXMuY2FsbH0saS5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrPWZ1bmN0aW9uKHQpe2lmKG4uaXNGdW5jdGlvbih0W3QubGVuZ3RoLTFdKSlyZXR1cm4gdC5wb3AoKX0saS5wcm90b3R5cGUudmFsaWRhdGVBcmdzPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoIT09dGhpcy5wYXJhbXMpdGhyb3cgby5JbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXMoKX0saS5wcm90b3R5cGUuZm9ybWF0SW5wdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW5wdXRGb3JtYXR0ZXI/dGhpcy5pbnB1dEZvcm1hdHRlci5tYXAoZnVuY3Rpb24oZSxyKXtyZXR1cm4gZT9lKHRbcl0pOnRbcl19KTp0fSxpLnByb3RvdHlwZS5mb3JtYXRPdXRwdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3V0cHV0Rm9ybWF0dGVyJiZ0P3RoaXMub3V0cHV0Rm9ybWF0dGVyKHQpOnR9LGkucHJvdG90eXBlLnRvUGF5bG9hZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldENhbGwodCkscj10aGlzLmV4dHJhY3RDYWxsYmFjayh0KSxuPXRoaXMuZm9ybWF0SW5wdXQodCk7cmV0dXJuIHRoaXMudmFsaWRhdGVBcmdzKG4pLHttZXRob2Q6ZSxwYXJhbXM6bixjYWxsYmFjazpyfX0saS5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5idWlsZENhbGwoKTtlLmNhbGw9dGhpcy5jYWxsO3ZhciByPXRoaXMubmFtZS5zcGxpdCgiLiIpO3IubGVuZ3RoPjE/KHRbclswXV09dFtyWzBdXXx8e30sdFtyWzBdXVtyWzFdXT1lKTp0W3JbMF1dPWV9LGkucHJvdG90eXBlLmJ1aWxkQ2FsbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1mdW5jdGlvbigpe3ZhciBlPXQudG9QYXlsb2FkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO3JldHVybiBlLmNhbGxiYWNrP3QucmVxdWVzdE1hbmFnZXIuc2VuZEFzeW5jKGUsZnVuY3Rpb24ocixuKXtlLmNhbGxiYWNrKHIsdC5mb3JtYXRPdXRwdXQobikpfSk6dC5mb3JtYXRPdXRwdXQodC5yZXF1ZXN0TWFuYWdlci5zZW5kKGUpKX07cmV0dXJuIGUucmVxdWVzdD10aGlzLnJlcXVlc3QuYmluZCh0aGlzKSxlfSxpLnByb3RvdHlwZS5yZXF1ZXN0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7cmV0dXJuIHQuZm9ybWF0PXRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyksdH0sZS5leHBvcnRzPWl9LHsiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2Vycm9ycyI6MjZ9XSwzNzpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uL21ldGhvZCIpLG89ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG4oe25hbWU6InB1dFN0cmluZyIsY2FsbDoiZGJfcHV0U3RyaW5nIixwYXJhbXM6M30pLG5ldyBuKHtuYW1lOiJnZXRTdHJpbmciLGNhbGw6ImRiX2dldFN0cmluZyIscGFyYW1zOjJ9KSxuZXcgbih7bmFtZToicHV0SGV4IixjYWxsOiJkYl9wdXRIZXgiLHBhcmFtczozfSksbmV3IG4oe25hbWU6ImdldEhleCIsY2FsbDoiZGJfZ2V0SGV4IixwYXJhbXM6Mn0pXX07ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7bygpLmZvckVhY2goZnVuY3Rpb24ocil7ci5hdHRhY2hUb09iamVjdChlKSxyLnNldFJlcXVlc3RNYW5hZ2VyKHQuX3JlcXVlc3RNYW5hZ2VyKX0pfX0seyIuLi9tZXRob2QiOjM2fV0sMzg6W2Z1bmN0aW9uKHQsZSxyKXsidXNlIHN0cmljdCI7dmFyIG49dCgiLi4vZm9ybWF0dGVycyIpLG89dCgiLi4vLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4uL21ldGhvZCIpLGE9dCgiLi4vcHJvcGVydHkiKSxzPXQoIi4uLy4uL3V0aWxzL2NvbmZpZyIpLGM9dCgiLi4vY29udHJhY3QiKSx1PXQoIi4vd2F0Y2hlcyIpLGY9dCgiLi4vZmlsdGVyIiksbD10KCIuLi9zeW5jaW5nIikscD10KCIuLi9uYW1lcmVnIiksaD10KCIuLi9pYmFuIiksZD10KCIuLi90cmFuc2ZlciIpLG09ZnVuY3Rpb24odCl7cmV0dXJuIG8uaXNTdHJpbmcodFswXSkmJjA9PT10WzBdLmluZGV4T2YoIjB4Iik/ImV0aF9nZXRCbG9ja0J5SGFzaCI6ImV0aF9nZXRCbG9ja0J5TnVtYmVyIn0seT1mdW5jdGlvbih0KXtyZXR1cm4gby5pc1N0cmluZyh0WzBdKSYmMD09PXRbMF0uaW5kZXhPZigiMHgiKT8iZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCI6ImV0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCJ9LGc9ZnVuY3Rpb24odCl7cmV0dXJuIG8uaXNTdHJpbmcodFswXSkmJjA9PT10WzBdLmluZGV4T2YoIjB4Iik/ImV0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgiOiJldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgifSx2PWZ1bmN0aW9uKHQpe3JldHVybiBvLmlzU3RyaW5nKHRbMF0pJiYwPT09dFswXS5pbmRleE9mKCIweCIpPyJldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoIjoiZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyIn0sYj1mdW5jdGlvbih0KXtyZXR1cm4gby5pc1N0cmluZyh0WzBdKSYmMD09PXRbMF0uaW5kZXhPZigiMHgiKT8iZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCI6ImV0aF9nZXRVbmNsZUNvdW50QnlCbG9ja051bWJlciJ9O2Z1bmN0aW9uIF8odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpczt3KCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSkseCgpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pLHRoaXMuaWJhbj1oLHRoaXMuc2VuZElCQU5UcmFuc2FjdGlvbj1kLmJpbmQobnVsbCx0aGlzKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsImRlZmF1bHRCbG9jayIse2dldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHRCbG9ja30sc2V0OmZ1bmN0aW9uKHQpe3JldHVybiBzLmRlZmF1bHRCbG9jaz10LHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KF8ucHJvdG90eXBlLCJkZWZhdWx0QWNjb3VudCIse2dldDpmdW5jdGlvbigpe3JldHVybiBzLmRlZmF1bHRBY2NvdW50fSxzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHMuZGVmYXVsdEFjY291bnQ9dCx0fX0pO3ZhciB3PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGkoe25hbWU6ImdldEJhbGFuY2UiLGNhbGw6ImV0aF9nZXRCYWxhbmNlIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbbi5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsbi5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl0sb3V0cHV0Rm9ybWF0dGVyOm4ub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyfSksZT1uZXcgaSh7bmFtZToiZ2V0U3RvcmFnZUF0IixjYWxsOiJldGhfZ2V0U3RvcmFnZUF0IixwYXJhbXM6MyxpbnB1dEZvcm1hdHRlcjpbbnVsbCxvLnRvSGV4LG4uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdfSkscj1uZXcgaSh7bmFtZToiZ2V0Q29kZSIsY2FsbDoiZXRoX2dldENvZGUiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltuLmlucHV0QWRkcmVzc0Zvcm1hdHRlcixuLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXX0pLGE9bmV3IGkoe25hbWU6ImdldEJsb2NrIixjYWxsOm0scGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W24uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixmdW5jdGlvbih0KXtyZXR1cm4hIXR9XSxvdXRwdXRGb3JtYXR0ZXI6bi5vdXRwdXRCbG9ja0Zvcm1hdHRlcn0pLHM9bmV3IGkoe25hbWU6ImdldFVuY2xlIixjYWxsOmcscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W24uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixvLnRvSGV4XSxvdXRwdXRGb3JtYXR0ZXI6bi5vdXRwdXRCbG9ja0Zvcm1hdHRlcn0pLGM9bmV3IGkoe25hbWU6ImdldENvbXBpbGVycyIsY2FsbDoiZXRoX2dldENvbXBpbGVycyIscGFyYW1zOjB9KSx1PW5ldyBpKHtuYW1lOiJnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQiLGNhbGw6dixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbi5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxvdXRwdXRGb3JtYXR0ZXI6by50b0RlY2ltYWx9KSxmPW5ldyBpKHtuYW1lOiJnZXRCbG9ja1VuY2xlQ291bnQiLGNhbGw6YixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbi5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxvdXRwdXRGb3JtYXR0ZXI6by50b0RlY2ltYWx9KSxsPW5ldyBpKHtuYW1lOiJnZXRUcmFuc2FjdGlvbiIsY2FsbDoiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoIixwYXJhbXM6MSxvdXRwdXRGb3JtYXR0ZXI6bi5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcn0pLHA9bmV3IGkoe25hbWU6ImdldFRyYW5zYWN0aW9uRnJvbUJsb2NrIixjYWxsOnkscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W24uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixvLnRvSGV4XSxvdXRwdXRGb3JtYXR0ZXI6bi5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcn0pLGg9bmV3IGkoe25hbWU6ImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsY2FsbDoiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCIscGFyYW1zOjEsb3V0cHV0Rm9ybWF0dGVyOm4ub3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyfSksZD1uZXcgaSh7bmFtZToiZ2V0VHJhbnNhY3Rpb25Db3VudCIsY2FsbDoiZXRoX2dldFRyYW5zYWN0aW9uQ291bnQiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG4uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLG91dHB1dEZvcm1hdHRlcjpvLnRvRGVjaW1hbH0pLF89bmV3IGkoe25hbWU6InNlbmRSYXdUcmFuc2FjdGlvbiIsY2FsbDoiZXRoX3NlbmRSYXdUcmFuc2FjdGlvbiIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksdz1uZXcgaSh7bmFtZToic2VuZFRyYW5zYWN0aW9uIixjYWxsOiJldGhfc2VuZFRyYW5zYWN0aW9uIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbi5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXX0pLHg9bmV3IGkoe25hbWU6InNpZ25UcmFuc2FjdGlvbiIsY2FsbDoiZXRoX3NpZ25UcmFuc2FjdGlvbiIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W24uaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl19KSxrPW5ldyBpKHtuYW1lOiJzaWduIixjYWxsOiJldGhfc2lnbiIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W24uaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG51bGxdfSk7cmV0dXJuW3QsZSxyLGEscyxjLHUsZixsLHAsaCxkLG5ldyBpKHtuYW1lOiJjYWxsIixjYWxsOiJldGhfY2FsbCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W24uaW5wdXRDYWxsRm9ybWF0dGVyLG4uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdfSksbmV3IGkoe25hbWU6ImVzdGltYXRlR2FzIixjYWxsOiJldGhfZXN0aW1hdGVHYXMiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltuLmlucHV0Q2FsbEZvcm1hdHRlcl0sb3V0cHV0Rm9ybWF0dGVyOm8udG9EZWNpbWFsfSksXyx4LHcsayxuZXcgaSh7bmFtZToiY29tcGlsZS5zb2xpZGl0eSIsY2FsbDoiZXRoX2NvbXBpbGVTb2xpZGl0eSIscGFyYW1zOjF9KSxuZXcgaSh7bmFtZToiY29tcGlsZS5sbGwiLGNhbGw6ImV0aF9jb21waWxlTExMIixwYXJhbXM6MX0pLG5ldyBpKHtuYW1lOiJjb21waWxlLnNlcnBlbnQiLGNhbGw6ImV0aF9jb21waWxlU2VycGVudCIscGFyYW1zOjF9KSxuZXcgaSh7bmFtZToic3VibWl0V29yayIsY2FsbDoiZXRoX3N1Ym1pdFdvcmsiLHBhcmFtczozfSksbmV3IGkoe25hbWU6ImdldFdvcmsiLGNhbGw6ImV0aF9nZXRXb3JrIixwYXJhbXM6MH0pXX0seD1mdW5jdGlvbigpe3JldHVybltuZXcgYSh7bmFtZToiY29pbmJhc2UiLGdldHRlcjoiZXRoX2NvaW5iYXNlIn0pLG5ldyBhKHtuYW1lOiJtaW5pbmciLGdldHRlcjoiZXRoX21pbmluZyJ9KSxuZXcgYSh7bmFtZToiaGFzaHJhdGUiLGdldHRlcjoiZXRoX2hhc2hyYXRlIixvdXRwdXRGb3JtYXR0ZXI6by50b0RlY2ltYWx9KSxuZXcgYSh7bmFtZToic3luY2luZyIsZ2V0dGVyOiJldGhfc3luY2luZyIsb3V0cHV0Rm9ybWF0dGVyOm4ub3V0cHV0U3luY2luZ0Zvcm1hdHRlcn0pLG5ldyBhKHtuYW1lOiJnYXNQcmljZSIsZ2V0dGVyOiJldGhfZ2FzUHJpY2UiLG91dHB1dEZvcm1hdHRlcjpuLm91dHB1dEJpZ051bWJlckZvcm1hdHRlcn0pLG5ldyBhKHtuYW1lOiJhY2NvdW50cyIsZ2V0dGVyOiJldGhfYWNjb3VudHMifSksbmV3IGEoe25hbWU6ImJsb2NrTnVtYmVyIixnZXR0ZXI6ImV0aF9ibG9ja051bWJlciIsb3V0cHV0Rm9ybWF0dGVyOm8udG9EZWNpbWFsfSksbmV3IGEoe25hbWU6InByb3RvY29sVmVyc2lvbiIsZ2V0dGVyOiJldGhfcHJvdG9jb2xWZXJzaW9uIn0pXX07Xy5wcm90b3R5cGUuY29udHJhY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBjKHRoaXMsdCl9LF8ucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbih0LGUscil7cmV0dXJuIG5ldyBmKHQsImV0aCIsdGhpcy5fcmVxdWVzdE1hbmFnZXIsdS5ldGgoKSxuLm91dHB1dExvZ0Zvcm1hdHRlcixlLHIpfSxfLnByb3RvdHlwZS5uYW1lcmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udHJhY3QocC5nbG9iYWwuYWJpKS5hdChwLmdsb2JhbC5hZGRyZXNzKX0sXy5wcm90b3R5cGUuaWNhcE5hbWVyZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250cmFjdChwLmljYXAuYWJpKS5hdChwLmljYXAuYWRkcmVzcyl9LF8ucHJvdG90eXBlLmlzU3luY2luZz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGwodGhpcy5fcmVxdWVzdE1hbmFnZXIsdCl9LGUuZXhwb3J0cz1ffSx7Ii4uLy4uL3V0aWxzL2NvbmZpZyI6MTgsIi4uLy4uL3V0aWxzL3V0aWxzIjoyMCwiLi4vY29udHJhY3QiOjI1LCIuLi9maWx0ZXIiOjI5LCIuLi9mb3JtYXR0ZXJzIjozMCwiLi4vaWJhbiI6MzMsIi4uL21ldGhvZCI6MzYsIi4uL25hbWVyZWciOjQ0LCIuLi9wcm9wZXJ0eSI6NDUsIi4uL3N5bmNpbmciOjQ4LCIuLi90cmFuc2ZlciI6NDksIi4vd2F0Y2hlcyI6NDN9XSwzOTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uLy4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9wcm9wZXJ0eSIpLGk9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG8oe25hbWU6Imxpc3RlbmluZyIsZ2V0dGVyOiJuZXRfbGlzdGVuaW5nIn0pLG5ldyBvKHtuYW1lOiJwZWVyQ291bnQiLGdldHRlcjoibmV0X3BlZXJDb3VudCIsb3V0cHV0Rm9ybWF0dGVyOm4udG9EZWNpbWFsfSldfTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpcztpKCkuZm9yRWFjaChmdW5jdGlvbihyKXtyLmF0dGFjaFRvT2JqZWN0KGUpLHIuc2V0UmVxdWVzdE1hbmFnZXIodC5fcmVxdWVzdE1hbmFnZXIpfSl9fSx7Ii4uLy4uL3V0aWxzL3V0aWxzIjoyMCwiLi4vcHJvcGVydHkiOjQ1fV0sNDA6W2Z1bmN0aW9uKHQsZSxyKXsidXNlIHN0cmljdCI7dmFyIG49dCgiLi4vbWV0aG9kIiksbz10KCIuLi9wcm9wZXJ0eSIpLGk9dCgiLi4vZm9ybWF0dGVycyIpO3ZhciBhPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IG4oe25hbWU6Im5ld0FjY291bnQiLGNhbGw6InBlcnNvbmFsX25ld0FjY291bnQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLGU9bmV3IG4oe25hbWU6ImltcG9ydFJhd0tleSIsY2FsbDoicGVyc29uYWxfaW1wb3J0UmF3S2V5IixwYXJhbXM6Mn0pLHI9bmV3IG4oe25hbWU6InNpZ24iLGNhbGw6InBlcnNvbmFsX3NpZ24iLHBhcmFtczozLGlucHV0Rm9ybWF0dGVyOltudWxsLGkuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG51bGxdfSksbz1uZXcgbih7bmFtZToiZWNSZWNvdmVyIixjYWxsOiJwZXJzb25hbF9lY1JlY292ZXIiLHBhcmFtczoyfSk7cmV0dXJuW3QsZSxuZXcgbih7bmFtZToidW5sb2NrQWNjb3VudCIsY2FsbDoicGVyc29uYWxfdW5sb2NrQWNjb3VudCIscGFyYW1zOjMsaW5wdXRGb3JtYXR0ZXI6W2kuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG51bGwsbnVsbF19KSxvLHIsbmV3IG4oe25hbWU6InNlbmRUcmFuc2FjdGlvbiIsY2FsbDoicGVyc29uYWxfc2VuZFRyYW5zYWN0aW9uIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbaS5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLG51bGxdfSksbmV3IG4oe25hbWU6ImxvY2tBY2NvdW50IixjYWxsOiJwZXJzb25hbF9sb2NrQWNjb3VudCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W2kuaW5wdXRBZGRyZXNzRm9ybWF0dGVyXX0pXX0scz1mdW5jdGlvbigpe3JldHVybltuZXcgbyh7bmFtZToibGlzdEFjY291bnRzIixnZXR0ZXI6InBlcnNvbmFsX2xpc3RBY2NvdW50cyJ9KV19O2UuZXhwb3J0cz1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10Ll9yZXF1ZXN0TWFuYWdlcjt2YXIgZT10aGlzO2EoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KSxzKCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSl9fSx7Ii4uL2Zvcm1hdHRlcnMiOjMwLCIuLi9tZXRob2QiOjM2LCIuLi9wcm9wZXJ0eSI6NDV9XSw0MTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uL21ldGhvZCIpLG89dCgiLi4vZmlsdGVyIiksaT10KCIuL3dhdGNoZXMiKSxhPWZ1bmN0aW9uKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7cygpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pfTthLnByb3RvdHlwZS5uZXdNZXNzYWdlRmlsdGVyPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gbmV3IG8odCwic2hoIix0aGlzLl9yZXF1ZXN0TWFuYWdlcixpLnNoaCgpLG51bGwsZSxyKX07dmFyIHM9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG4oe25hbWU6InZlcnNpb24iLGNhbGw6InNoaF92ZXJzaW9uIixwYXJhbXM6MH0pLG5ldyBuKHtuYW1lOiJpbmZvIixjYWxsOiJzaGhfaW5mbyIscGFyYW1zOjB9KSxuZXcgbih7bmFtZToic2V0TWF4TWVzc2FnZVNpemUiLGNhbGw6InNoaF9zZXRNYXhNZXNzYWdlU2l6ZSIscGFyYW1zOjF9KSxuZXcgbih7bmFtZToic2V0TWluUG9XIixjYWxsOiJzaGhfc2V0TWluUG9XIixwYXJhbXM6MX0pLG5ldyBuKHtuYW1lOiJtYXJrVHJ1c3RlZFBlZXIiLGNhbGw6InNoaF9tYXJrVHJ1c3RlZFBlZXIiLHBhcmFtczoxfSksbmV3IG4oe25hbWU6Im5ld0tleVBhaXIiLGNhbGw6InNoaF9uZXdLZXlQYWlyIixwYXJhbXM6MH0pLG5ldyBuKHtuYW1lOiJhZGRQcml2YXRlS2V5IixjYWxsOiJzaGhfYWRkUHJpdmF0ZUtleSIscGFyYW1zOjF9KSxuZXcgbih7bmFtZToiZGVsZXRlS2V5UGFpciIsY2FsbDoic2hoX2RlbGV0ZUtleVBhaXIiLHBhcmFtczoxfSksbmV3IG4oe25hbWU6Imhhc0tleVBhaXIiLGNhbGw6InNoaF9oYXNLZXlQYWlyIixwYXJhbXM6MX0pLG5ldyBuKHtuYW1lOiJnZXRQdWJsaWNLZXkiLGNhbGw6InNoaF9nZXRQdWJsaWNLZXkiLHBhcmFtczoxfSksbmV3IG4oe25hbWU6ImdldFByaXZhdGVLZXkiLGNhbGw6InNoaF9nZXRQcml2YXRlS2V5IixwYXJhbXM6MX0pLG5ldyBuKHtuYW1lOiJuZXdTeW1LZXkiLGNhbGw6InNoaF9uZXdTeW1LZXkiLHBhcmFtczowfSksbmV3IG4oe25hbWU6ImFkZFN5bUtleSIsY2FsbDoic2hoX2FkZFN5bUtleSIscGFyYW1zOjF9KSxuZXcgbih7bmFtZToiZ2VuZXJhdGVTeW1LZXlGcm9tUGFzc3dvcmQiLGNhbGw6InNoaF9nZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCIscGFyYW1zOjF9KSxuZXcgbih7bmFtZToiaGFzU3ltS2V5IixjYWxsOiJzaGhfaGFzU3ltS2V5IixwYXJhbXM6MX0pLG5ldyBuKHtuYW1lOiJnZXRTeW1LZXkiLGNhbGw6InNoaF9nZXRTeW1LZXkiLHBhcmFtczoxfSksbmV3IG4oe25hbWU6ImRlbGV0ZVN5bUtleSIsY2FsbDoic2hoX2RlbGV0ZVN5bUtleSIscGFyYW1zOjF9KSxuZXcgbih7bmFtZToicG9zdCIsY2FsbDoic2hoX3Bvc3QiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pXX07ZS5leHBvcnRzPWF9LHsiLi4vZmlsdGVyIjoyOSwiLi4vbWV0aG9kIjozNiwiLi93YXRjaGVzIjo0M31dLDQyOltmdW5jdGlvbih0LGUscil7InVzZSBzdHJpY3QiO3ZhciBuPXQoIi4uL21ldGhvZCIpLG89dCgiLi4vcHJvcGVydHkiKTt2YXIgaT1mdW5jdGlvbigpe3JldHVybltuZXcgbih7bmFtZToiYmxvY2tOZXR3b3JrUmVhZCIsY2FsbDoiYnp6X2Jsb2NrTmV0d29ya1JlYWQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLG5ldyBuKHtuYW1lOiJzeW5jRW5hYmxlZCIsY2FsbDoiYnp6X3N5bmNFbmFibGVkIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSxuZXcgbih7bmFtZToic3dhcEVuYWJsZWQiLGNhbGw6ImJ6el9zd2FwRW5hYmxlZCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IG4oe25hbWU6ImRvd25sb2FkIixjYWxsOiJienpfZG93bmxvYWQiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG51bGxdfSksbmV3IG4oe25hbWU6InVwbG9hZCIsY2FsbDoiYnp6X3VwbG9hZCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W251bGwsbnVsbF19KSxuZXcgbih7bmFtZToicmV0cmlldmUiLGNhbGw6ImJ6el9yZXRyaWV2ZSIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IG4oe25hbWU6InN0b3JlIixjYWxsOiJienpfc3RvcmUiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG51bGxdfSksbmV3IG4oe25hbWU6ImdldCIsY2FsbDoiYnp6X2dldCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IG4oe25hbWU6InB1dCIsY2FsbDoiYnp6X3B1dCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W251bGwsbnVsbF19KSxuZXcgbih7bmFtZToibW9kaWZ5IixjYWxsOiJienpfbW9kaWZ5IixwYXJhbXM6NCxpbnB1dEZvcm1hdHRlcjpbbnVsbCxudWxsLG51bGwsbnVsbF19KV19LGE9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG8oe25hbWU6ImhpdmUiLGdldHRlcjoiYnp6X2hpdmUifSksbmV3IG8oe25hbWU6ImluZm8iLGdldHRlcjoiYnp6X2luZm8ifSldfTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpcztpKCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSksYSgpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pfX0seyIuLi9tZXRob2QiOjM2LCIuLi9wcm9wZXJ0eSI6NDV9XSw0MzpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uL21ldGhvZCIpO2UuZXhwb3J0cz17ZXRoOmZ1bmN0aW9uKCl7cmV0dXJuW25ldyBuKHtuYW1lOiJuZXdGaWx0ZXIiLGNhbGw6ZnVuY3Rpb24odCl7c3dpdGNoKHRbMF0pe2Nhc2UibGF0ZXN0IjpyZXR1cm4gdC5zaGlmdCgpLHRoaXMucGFyYW1zPTAsImV0aF9uZXdCbG9ja0ZpbHRlciI7Y2FzZSJwZW5kaW5nIjpyZXR1cm4gdC5zaGlmdCgpLHRoaXMucGFyYW1zPTAsImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIiO2RlZmF1bHQ6cmV0dXJuImV0aF9uZXdGaWx0ZXIifX0scGFyYW1zOjF9KSxuZXcgbih7bmFtZToidW5pbnN0YWxsRmlsdGVyIixjYWxsOiJldGhfdW5pbnN0YWxsRmlsdGVyIixwYXJhbXM6MX0pLG5ldyBuKHtuYW1lOiJnZXRMb2dzIixjYWxsOiJldGhfZ2V0RmlsdGVyTG9ncyIscGFyYW1zOjF9KSxuZXcgbih7bmFtZToicG9sbCIsY2FsbDoiZXRoX2dldEZpbHRlckNoYW5nZXMiLHBhcmFtczoxfSldfSxzaGg6ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG4oe25hbWU6Im5ld0ZpbHRlciIsY2FsbDoic2hoX25ld01lc3NhZ2VGaWx0ZXIiLHBhcmFtczoxfSksbmV3IG4oe25hbWU6InVuaW5zdGFsbEZpbHRlciIsY2FsbDoic2hoX2RlbGV0ZU1lc3NhZ2VGaWx0ZXIiLHBhcmFtczoxfSksbmV3IG4oe25hbWU6ImdldExvZ3MiLGNhbGw6InNoaF9nZXRGaWx0ZXJNZXNzYWdlcyIscGFyYW1zOjF9KSxuZXcgbih7bmFtZToicG9sbCIsY2FsbDoic2hoX2dldEZpbHRlck1lc3NhZ2VzIixwYXJhbXM6MX0pXX19fSx7Ii4uL21ldGhvZCI6MzZ9XSw0NDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4uL2NvbnRyYWN0cy9HbG9iYWxSZWdpc3RyYXIuanNvbiIpLG89dCgiLi4vY29udHJhY3RzL0lDQVBSZWdpc3RyYXIuanNvbiIpO2UuZXhwb3J0cz17Z2xvYmFsOnthYmk6bixhZGRyZXNzOiIweGM2ZDlkMmNkNDQ5YTc1NGM0OTQyNjRlMTgwOWM1MGUzNGQ2NDU2MmIifSxpY2FwOnthYmk6byxhZGRyZXNzOiIweGExYTExMWJjMDc0YzljZmE3ODFmMGMzOGU2M2JkNTFjOTFiOGFmMDAifX19LHsiLi4vY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uIjoxLCIuLi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uIjoyfV0sNDU6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCIuLi91dGlscy91dGlscyIpLG89ZnVuY3Rpb24odCl7dGhpcy5uYW1lPXQubmFtZSx0aGlzLmdldHRlcj10LmdldHRlcix0aGlzLnNldHRlcj10LnNldHRlcix0aGlzLm91dHB1dEZvcm1hdHRlcj10Lm91dHB1dEZvcm1hdHRlcix0aGlzLmlucHV0Rm9ybWF0dGVyPXQuaW5wdXRGb3JtYXR0ZXIsdGhpcy5yZXF1ZXN0TWFuYWdlcj1udWxsfTtvLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlcj1mdW5jdGlvbih0KXt0aGlzLnJlcXVlc3RNYW5hZ2VyPXR9LG8ucHJvdG90eXBlLmZvcm1hdElucHV0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyP3RoaXMuaW5wdXRGb3JtYXR0ZXIodCk6dH0sby5wcm90b3R5cGUuZm9ybWF0T3V0cHV0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciYmbnVsbCE9dD90aGlzLm91dHB1dEZvcm1hdHRlcih0KTp0fSxvLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2s9ZnVuY3Rpb24odCl7aWYobi5pc0Z1bmN0aW9uKHRbdC5sZW5ndGgtMV0pKXJldHVybiB0LnBvcCgpfSxvLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdD1mdW5jdGlvbih0KXt2YXIgZT17Z2V0OnRoaXMuYnVpbGRHZXQoKSxlbnVtZXJhYmxlOiEwfSxyPXRoaXMubmFtZS5zcGxpdCgiLiIpLG49clswXTtyLmxlbmd0aD4xJiYodFtyWzBdXT10W3JbMF1dfHx7fSx0PXRbclswXV0sbj1yWzFdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLGUpLHRbaShuKV09dGhpcy5idWlsZEFzeW5jR2V0KCl9O3ZhciBpPWZ1bmN0aW9uKHQpe3JldHVybiJnZXQiK3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKX07by5wcm90b3R5cGUuYnVpbGRHZXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmZvcm1hdE91dHB1dCh0LnJlcXVlc3RNYW5hZ2VyLnNlbmQoe21ldGhvZDp0LmdldHRlcn0pKX19LG8ucHJvdG90eXBlLmJ1aWxkQXN5bmNHZXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9ZnVuY3Rpb24oZSl7dC5yZXF1ZXN0TWFuYWdlci5zZW5kQXN5bmMoe21ldGhvZDp0LmdldHRlcn0sZnVuY3Rpb24ocixuKXtlKHIsdC5mb3JtYXRPdXRwdXQobikpfSl9O3JldHVybiBlLnJlcXVlc3Q9dGhpcy5yZXF1ZXN0LmJpbmQodGhpcyksZX0sby5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbigpe3ZhciB0PXttZXRob2Q6dGhpcy5nZXR0ZXIscGFyYW1zOltdLGNhbGxiYWNrOnRoaXMuZXh0cmFjdENhbGxiYWNrKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpfTtyZXR1cm4gdC5mb3JtYXQ9dGhpcy5mb3JtYXRPdXRwdXQuYmluZCh0aGlzKSx0fSxlLmV4cG9ydHM9b30seyIuLi91dGlscy91dGlscyI6MjB9XSw0NjpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4vanNvbnJwYyIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4uL3V0aWxzL2NvbmZpZyIpLGE9dCgiLi9lcnJvcnMiKSxzPWZ1bmN0aW9uKHQpe3RoaXMucHJvdmlkZXI9dCx0aGlzLnBvbGxzPXt9LHRoaXMudGltZW91dD1udWxsfTtzLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHQpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiBjb25zb2xlLmVycm9yKGEuSW52YWxpZFByb3ZpZGVyKCkpLG51bGw7dmFyIGU9bi50b1BheWxvYWQodC5tZXRob2QsdC5wYXJhbXMpLHI9dGhpcy5wcm92aWRlci5zZW5kKGUpO2lmKCFuLmlzVmFsaWRSZXNwb25zZShyKSl0aHJvdyBhLkludmFsaWRSZXNwb25zZShyKTtyZXR1cm4gci5yZXN1bHR9LHMucHJvdG90eXBlLnNlbmRBc3luYz1mdW5jdGlvbih0LGUpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiBlKGEuSW52YWxpZFByb3ZpZGVyKCkpO3ZhciByPW4udG9QYXlsb2FkKHQubWV0aG9kLHQucGFyYW1zKTt0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhyLGZ1bmN0aW9uKHQscil7cmV0dXJuIHQ/ZSh0KTpuLmlzVmFsaWRSZXNwb25zZShyKT92b2lkIGUobnVsbCxyLnJlc3VsdCk6ZShhLkludmFsaWRSZXNwb25zZShyKSl9KX0scy5wcm90b3R5cGUuc2VuZEJhdGNoPWZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMucHJvdmlkZXIpcmV0dXJuIGUoYS5JbnZhbGlkUHJvdmlkZXIoKSk7dmFyIHI9bi50b0JhdGNoUGF5bG9hZCh0KTt0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhyLGZ1bmN0aW9uKHQscil7cmV0dXJuIHQ/ZSh0KTpvLmlzQXJyYXkocik/dm9pZCBlKHQscik6ZShhLkludmFsaWRSZXNwb25zZShyKSl9KX0scy5wcm90b3R5cGUuc2V0UHJvdmlkZXI9ZnVuY3Rpb24odCl7dGhpcy5wcm92aWRlcj10fSxzLnByb3RvdHlwZS5zdGFydFBvbGxpbmc9ZnVuY3Rpb24odCxlLHIsbil7dGhpcy5wb2xsc1tlXT17ZGF0YTp0LGlkOmUsY2FsbGJhY2s6cix1bmluc3RhbGw6bn0sdGhpcy50aW1lb3V0fHx0aGlzLnBvbGwoKX0scy5wcm90b3R5cGUuc3RvcFBvbGxpbmc9ZnVuY3Rpb24odCl7ZGVsZXRlIHRoaXMucG9sbHNbdF0sMD09PU9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCYmdGhpcy50aW1lb3V0JiYoY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCksdGhpcy50aW1lb3V0PW51bGwpfSxzLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdGhpcy5wb2xscyl0JiYtMSE9PWUuaW5kZXhPZigic3luY1BvbGxfIil8fCh0aGlzLnBvbGxzW2VdLnVuaW5zdGFsbCgpLGRlbGV0ZSB0aGlzLnBvbGxzW2VdKTswPT09T2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoJiZ0aGlzLnRpbWVvdXQmJihjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSx0aGlzLnRpbWVvdXQ9bnVsbCl9LHMucHJvdG90eXBlLnBvbGw9ZnVuY3Rpb24oKXtpZih0aGlzLnRpbWVvdXQ9c2V0VGltZW91dCh0aGlzLnBvbGwuYmluZCh0aGlzKSxpLkVUSF9QT0xMSU5HX1RJTUVPVVQpLDAhPT1PYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGgpaWYodGhpcy5wcm92aWRlcil7dmFyIHQ9W10sZT1bXTtmb3IodmFyIHIgaW4gdGhpcy5wb2xscyl0LnB1c2godGhpcy5wb2xsc1tyXS5kYXRhKSxlLnB1c2gocik7aWYoMCE9PXQubGVuZ3RoKXt2YXIgcz1uLnRvQmF0Y2hQYXlsb2FkKHQpLGM9e307cy5mb3JFYWNoKGZ1bmN0aW9uKHQscil7Y1t0LmlkXT1lW3JdfSk7dmFyIHU9dGhpczt0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhzLGZ1bmN0aW9uKHQsZSl7aWYoIXQpe2lmKCFvLmlzQXJyYXkoZSkpdGhyb3cgYS5JbnZhbGlkUmVzcG9uc2UoZSk7ZS5tYXAoZnVuY3Rpb24odCl7dmFyIGU9Y1t0LmlkXTtyZXR1cm4hIXUucG9sbHNbZV0mJih0LmNhbGxiYWNrPXUucG9sbHNbZV0uY2FsbGJhY2ssdCl9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuISF0fSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3ZhciBlPW4uaXNWYWxpZFJlc3BvbnNlKHQpO3JldHVybiBlfHx0LmNhbGxiYWNrKGEuSW52YWxpZFJlc3BvbnNlKHQpKSxlfSkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmNhbGxiYWNrKG51bGwsdC5yZXN1bHQpfSl9fSl9fWVsc2UgY29uc29sZS5lcnJvcihhLkludmFsaWRQcm92aWRlcigpKX0sZS5leHBvcnRzPXN9LHsiLi4vdXRpbHMvY29uZmlnIjoxOCwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2Vycm9ycyI6MjYsIi4vanNvbnJwYyI6MzV9XSw0NzpbZnVuY3Rpb24odCxlLHIpe2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMuZGVmYXVsdEJsb2NrPSJsYXRlc3QiLHRoaXMuZGVmYXVsdEFjY291bnQ9dm9pZCAwfX0se31dLDQ4OltmdW5jdGlvbih0LGUscil7dmFyIG49dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuLi91dGlscy91dGlscyIpLGk9MSxhPWZ1bmN0aW9uKHQsZSl7dmFyIHI7cmV0dXJuIHRoaXMucmVxdWVzdE1hbmFnZXI9dCx0aGlzLnBvbGxJZD0ic3luY1BvbGxfIitpKyssdGhpcy5jYWxsYmFja3M9W10sdGhpcy5hZGRDYWxsYmFjayhlKSx0aGlzLmxhc3RTeW5jU3RhdGU9ITEsKHI9dGhpcykucmVxdWVzdE1hbmFnZXIuc3RhcnRQb2xsaW5nKHttZXRob2Q6ImV0aF9zeW5jaW5nIixwYXJhbXM6W119LHIucG9sbElkLGZ1bmN0aW9uKHQsZSl7aWYodClyZXR1cm4gci5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihlKXtlKHQpfSk7by5pc09iamVjdChlKSYmZS5zdGFydGluZ0Jsb2NrJiYoZT1uLm91dHB1dFN5bmNpbmdGb3JtYXR0ZXIoZSkpLHIuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7ci5sYXN0U3luY1N0YXRlIT09ZSYmKCFyLmxhc3RTeW5jU3RhdGUmJm8uaXNPYmplY3QoZSkmJnQobnVsbCwhMCksc2V0VGltZW91dChmdW5jdGlvbigpe3QobnVsbCxlKX0sMCksci5sYXN0U3luY1N0YXRlPWUpfSl9LHIuc3RvcFdhdGNoaW5nLmJpbmQocikpLHRoaXN9O2EucHJvdG90eXBlLmFkZENhbGxiYWNrPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLmNhbGxiYWNrcy5wdXNoKHQpLHRoaXN9LGEucHJvdG90eXBlLnN0b3BXYXRjaGluZz1mdW5jdGlvbigpe3RoaXMucmVxdWVzdE1hbmFnZXIuc3RvcFBvbGxpbmcodGhpcy5wb2xsSWQpLHRoaXMuY2FsbGJhY2tzPVtdfSxlLmV4cG9ydHM9YX0seyIuLi91dGlscy91dGlscyI6MjAsIi4vZm9ybWF0dGVycyI6MzB9XSw0OTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQoIi4vaWJhbiIpLG89dCgiLi4vY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiIpLGk9ZnVuY3Rpb24odCxlLHIsbixvKXtyZXR1cm4gdC5zZW5kVHJhbnNhY3Rpb24oe2FkZHJlc3M6cixmcm9tOmUsdmFsdWU6bn0sbyl9LGE9ZnVuY3Rpb24odCxlLHIsbixpLGEpe3ZhciBzPW87cmV0dXJuIHQuY29udHJhY3QocykuYXQocikuZGVwb3NpdChpLHtmcm9tOmUsdmFsdWU6bn0sYSl9O2UuZXhwb3J0cz1mdW5jdGlvbih0LGUscixvLHMpe3ZhciBjPW5ldyBuKHIpO2lmKCFjLmlzVmFsaWQoKSl0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgaWJhbiBhZGRyZXNzIik7aWYoYy5pc0RpcmVjdCgpKXJldHVybiBpKHQsZSxjLmFkZHJlc3MoKSxvLHMpO2lmKCFzKXt2YXIgdT10LmljYXBOYW1lcmVnKCkuYWRkcihjLmluc3RpdHV0aW9uKCkpO3JldHVybiBhKHQsZSx1LG8sYy5jbGllbnQoKSl9dC5pY2FwTmFtZXJlZygpLmFkZHIoYy5pbnN0aXR1dGlvbigpLGZ1bmN0aW9uKHIsbil7cmV0dXJuIGEodCxlLG4sbyxjLmNsaWVudCgpLHMpfSl9fSx7Ii4uL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb24iOjMsIi4vaWJhbiI6MzN9XSw1MDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dCxyPWUubGliLkJsb2NrQ2lwaGVyLG49ZS5hbGdvLG89W10saT1bXSxhPVtdLHM9W10sYz1bXSx1PVtdLGY9W10sbD1bXSxwPVtdLGg9W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPDI1NjtlKyspdFtlXT1lPDEyOD9lPDwxOmU8PDFeMjgzO3ZhciByPTAsbj0wO2ZvcihlPTA7ZTwyNTY7ZSsrKXt2YXIgZD1uXm48PDFebjw8Ml5uPDwzXm48PDQ7ZD1kPj4+OF4yNTUmZF45OSxvW3JdPWQsaVtkXT1yO3ZhciBtPXRbcl0seT10W21dLGc9dFt5XSx2PTI1Nyp0W2RdXjE2ODQzMDA4KmQ7YVtyXT12PDwyNHx2Pj4+OCxzW3JdPXY8PDE2fHY+Pj4xNixjW3JdPXY8PDh8dj4+PjI0LHVbcl09djt2PTE2ODQzMDA5KmdeNjU1MzcqeV4yNTcqbV4xNjg0MzAwOCpyO2ZbZF09djw8MjR8dj4+PjgsbFtkXT12PDwxNnx2Pj4+MTYscFtkXT12PDw4fHY+Pj4yNCxoW2RdPXYscj8ocj1tXnRbdFt0W2debV1dXSxuXj10W3Rbbl1dKTpyPW49MX19KCk7dmFyIGQ9WzAsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTRdLG09bi5BRVM9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMuX25Sb3VuZHN8fHRoaXMuX2tleVByaW9yUmVzZXQhPT10aGlzLl9rZXkpe2Zvcih2YXIgdD10aGlzLl9rZXlQcmlvclJlc2V0PXRoaXMuX2tleSxlPXQud29yZHMscj10LnNpZ0J5dGVzLzQsbj00KigodGhpcy5fblJvdW5kcz1yKzYpKzEpLGk9dGhpcy5fa2V5U2NoZWR1bGU9W10sYT0wO2E8bjthKyspaWYoYTxyKWlbYV09ZVthXTtlbHNle3ZhciBzPWlbYS0xXTthJXI/cj42JiZhJXI9PTQmJihzPW9bcz4+PjI0XTw8MjR8b1tzPj4+MTYmMjU1XTw8MTZ8b1tzPj4+OCYyNTVdPDw4fG9bMjU1JnNdKToocz1vWyhzPXM8PDh8cz4+PjI0KT4+PjI0XTw8MjR8b1tzPj4+MTYmMjU1XTw8MTZ8b1tzPj4+OCYyNTVdPDw4fG9bMjU1JnNdLHNePWRbYS9yfDBdPDwyNCksaVthXT1pW2Etcl1ec31mb3IodmFyIGM9dGhpcy5faW52S2V5U2NoZWR1bGU9W10sdT0wO3U8bjt1Kyspe2E9bi11O2lmKHUlNClzPWlbYV07ZWxzZSBzPWlbYS00XTtjW3VdPXU8NHx8YTw9ND9zOmZbb1tzPj4+MjRdXV5sW29bcz4+PjE2JjI1NV1dXnBbb1tzPj4+OCYyNTVdXV5oW29bMjU1JnNdXX19fSxlbmNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9kb0NyeXB0QmxvY2sodCxlLHRoaXMuX2tleVNjaGVkdWxlLGEscyxjLHUsbyl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3ZhciByPXRbZSsxXTt0W2UrMV09dFtlKzNdLHRbZSszXT1yLHRoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5faW52S2V5U2NoZWR1bGUsZixsLHAsaCxpKTtyPXRbZSsxXTt0W2UrMV09dFtlKzNdLHRbZSszXT1yfSxfZG9DcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSxyLG4sbyxpLGEscyl7Zm9yKHZhciBjPXRoaXMuX25Sb3VuZHMsdT10W2VdXnJbMF0sZj10W2UrMV1eclsxXSxsPXRbZSsyXV5yWzJdLHA9dFtlKzNdXnJbM10saD00LGQ9MTtkPGM7ZCsrKXt2YXIgbT1uW3U+Pj4yNF1eb1tmPj4+MTYmMjU1XV5pW2w+Pj44JjI1NV1eYVsyNTUmcF1ecltoKytdLHk9bltmPj4+MjRdXm9bbD4+PjE2JjI1NV1eaVtwPj4+OCYyNTVdXmFbMjU1JnVdXnJbaCsrXSxnPW5bbD4+PjI0XV5vW3A+Pj4xNiYyNTVdXmlbdT4+PjgmMjU1XV5hWzI1NSZmXV5yW2grK10sdj1uW3A+Pj4yNF1eb1t1Pj4+MTYmMjU1XV5pW2Y+Pj44JjI1NV1eYVsyNTUmbF1ecltoKytdO3U9bSxmPXksbD1nLHA9dn1tPShzW3U+Pj4yNF08PDI0fHNbZj4+PjE2JjI1NV08PDE2fHNbbD4+PjgmMjU1XTw8OHxzWzI1NSZwXSlecltoKytdLHk9KHNbZj4+PjI0XTw8MjR8c1tsPj4+MTYmMjU1XTw8MTZ8c1twPj4+OCYyNTVdPDw4fHNbMjU1JnVdKV5yW2grK10sZz0oc1tsPj4+MjRdPDwyNHxzW3A+Pj4xNiYyNTVdPDwxNnxzW3U+Pj44JjI1NV08PDh8c1syNTUmZl0pXnJbaCsrXSx2PShzW3A+Pj4yNF08PDI0fHNbdT4+PjE2JjI1NV08PDE2fHNbZj4+PjgmMjU1XTw8OHxzWzI1NSZsXSlecltoKytdO3RbZV09bSx0W2UrMV09eSx0W2UrMl09Zyx0W2UrM109dn0sa2V5U2l6ZTo4fSk7ZS5BRVM9ci5fY3JlYXRlSGVscGVyKG0pfSgpLHQuQUVTfSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1MiwiLi9lbmMtYmFzZTY0Ijo1MywiLi9ldnBrZGYiOjU1LCIuL21kNSI6NjB9XSw1MTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7dmFyIGUscixuLG8saSxhLHMsYyx1LGYsbCxwLGgsZCxtLHksZyx2LGI7dC5saWIuQ2lwaGVyfHwobj0ocj10KS5saWIsbz1uLkJhc2UsaT1uLldvcmRBcnJheSxhPW4uQnVmZmVyZWRCbG9ja0FsZ29yaXRobSwocz1yLmVuYykuVXRmOCxjPXMuQmFzZTY0LHU9ci5hbGdvLkV2cEtERixmPW4uQ2lwaGVyPWEuZXh0ZW5kKHtjZmc6by5leHRlbmQoKSxjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsdCxlKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLHQsZSl9LGluaXQ6ZnVuY3Rpb24odCxlLHIpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChyKSx0aGlzLl94Zm9ybU1vZGU9dCx0aGlzLl9rZXk9ZSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7YS5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0scHJvY2VzczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYXBwZW5kKHQpLHRoaXMuX3Byb2Nlc3MoKX0sZmluYWxpemU6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMuX2FwcGVuZCh0KSx0aGlzLl9kb0ZpbmFsaXplKCl9LGtleVNpemU6NCxpdlNpemU6NCxfRU5DX1hGT1JNX01PREU6MSxfREVDX1hGT1JNX01PREU6MixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHQ/YjpnfXJldHVybiBmdW5jdGlvbihlKXtyZXR1cm57ZW5jcnlwdDpmdW5jdGlvbihyLG4sbyl7cmV0dXJuIHQobikuZW5jcnlwdChlLHIsbixvKX0sZGVjcnlwdDpmdW5jdGlvbihyLG4sbyl7cmV0dXJuIHQobikuZGVjcnlwdChlLHIsbixvKX19fX0oKX0pLG4uU3RyZWFtQ2lwaGVyPWYuZXh0ZW5kKHtfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9jZXNzKCEwKX0sYmxvY2tTaXplOjF9KSxsPXIubW9kZT17fSxwPW4uQmxvY2tDaXBoZXJNb2RlPW8uZXh0ZW5kKHtjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKHQsZSl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUodCxlKX0saW5pdDpmdW5jdGlvbih0LGUpe3RoaXMuX2NpcGhlcj10LHRoaXMuX2l2PWV9fSksaD1sLkNCQz1mdW5jdGlvbigpe3ZhciB0PXAuZXh0ZW5kKCk7ZnVuY3Rpb24gcih0LHIsbil7dmFyIG89dGhpcy5faXY7aWYobyl7dmFyIGk9bzt0aGlzLl9pdj1lfWVsc2UgaT10aGlzLl9wcmV2QmxvY2s7Zm9yKHZhciBhPTA7YTxuO2ErKyl0W3IrYV1ePWlbYV19cmV0dXJuIHQuRW5jcnlwdG9yPXQuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9jaXBoZXIsbz1uLmJsb2NrU2l6ZTtyLmNhbGwodGhpcyx0LGUsbyksbi5lbmNyeXB0QmxvY2sodCxlKSx0aGlzLl9wcmV2QmxvY2s9dC5zbGljZShlLGUrbyl9fSksdC5EZWNyeXB0b3I9dC5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2NpcGhlcixvPW4uYmxvY2tTaXplLGk9dC5zbGljZShlLGUrbyk7bi5kZWNyeXB0QmxvY2sodCxlKSxyLmNhbGwodGhpcyx0LGUsbyksdGhpcy5fcHJldkJsb2NrPWl9fSksdH0oKSxkPShyLnBhZD17fSkuUGtjczc9e3BhZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj00KmUsbj1yLXQuc2lnQnl0ZXMlcixvPW48PDI0fG48PDE2fG48PDh8bixhPVtdLHM9MDtzPG47cys9NClhLnB1c2gobyk7dmFyIGM9aS5jcmVhdGUoYSxuKTt0LmNvbmNhdChjKX0sdW5wYWQ6ZnVuY3Rpb24odCl7dmFyIGU9MjU1JnQud29yZHNbdC5zaWdCeXRlcy0xPj4+Ml07dC5zaWdCeXRlcy09ZX19LG4uQmxvY2tDaXBoZXI9Zi5leHRlbmQoe2NmZzpmLmNmZy5leHRlbmQoe21vZGU6aCxwYWRkaW5nOmR9KSxyZXNldDpmdW5jdGlvbigpe2YucmVzZXQuY2FsbCh0aGlzKTt2YXIgdD10aGlzLmNmZyxlPXQuaXYscj10Lm1vZGU7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl2YXIgbj1yLmNyZWF0ZUVuY3J5cHRvcjtlbHNle249ci5jcmVhdGVEZWNyeXB0b3I7dGhpcy5fbWluQnVmZmVyU2l6ZT0xfXRoaXMuX21vZGU9bi5jYWxsKHIsdGhpcyxlJiZlLndvcmRzKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sodCxlKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNmZy5wYWRkaW5nO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpe3QucGFkKHRoaXMuX2RhdGEsdGhpcy5ibG9ja1NpemUpO3ZhciBlPXRoaXMuX3Byb2Nlc3MoITApfWVsc2V7ZT10aGlzLl9wcm9jZXNzKCEwKTt0LnVucGFkKGUpfXJldHVybiBlfSxibG9ja1NpemU6NH0pLG09bi5DaXBoZXJQYXJhbXM9by5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCl7dGhpcy5taXhJbih0KX0sdG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuKHR8fHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyl9fSkseT0oci5mb3JtYXQ9e30pLk9wZW5TU0w9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXt2YXIgZT10LmNpcGhlcnRleHQscj10LnNhbHQ7aWYocil2YXIgbj1pLmNyZWF0ZShbMTM5ODg5MzY4NCwxNzAxMDc2ODMxXSkuY29uY2F0KHIpLmNvbmNhdChlKTtlbHNlIG49ZTtyZXR1cm4gbi50b1N0cmluZyhjKX0scGFyc2U6ZnVuY3Rpb24odCl7dmFyIGU9Yy5wYXJzZSh0KSxyPWUud29yZHM7aWYoMTM5ODg5MzY4ND09clswXSYmMTcwMTA3NjgzMT09clsxXSl7dmFyIG49aS5jcmVhdGUoci5zbGljZSgyLDQpKTtyLnNwbGljZSgwLDQpLGUuc2lnQnl0ZXMtPTE2fXJldHVybiBtLmNyZWF0ZSh7Y2lwaGVydGV4dDplLHNhbHQ6bn0pfX0sZz1uLlNlcmlhbGl6YWJsZUNpcGhlcj1vLmV4dGVuZCh7Y2ZnOm8uZXh0ZW5kKHtmb3JtYXQ6eX0pLGVuY3J5cHQ6ZnVuY3Rpb24odCxlLHIsbil7bj10aGlzLmNmZy5leHRlbmQobik7dmFyIG89dC5jcmVhdGVFbmNyeXB0b3IocixuKSxpPW8uZmluYWxpemUoZSksYT1vLmNmZztyZXR1cm4gbS5jcmVhdGUoe2NpcGhlcnRleHQ6aSxrZXk6cixpdjphLml2LGFsZ29yaXRobTp0LG1vZGU6YS5tb2RlLHBhZGRpbmc6YS5wYWRkaW5nLGJsb2NrU2l6ZTp0LmJsb2NrU2l6ZSxmb3JtYXR0ZXI6bi5mb3JtYXR9KX0sZGVjcnlwdDpmdW5jdGlvbih0LGUscixuKXtyZXR1cm4gbj10aGlzLmNmZy5leHRlbmQobiksZT10aGlzLl9wYXJzZShlLG4uZm9ybWF0KSx0LmNyZWF0ZURlY3J5cHRvcihyLG4pLmZpbmFsaXplKGUuY2lwaGVydGV4dCl9LF9wYXJzZTpmdW5jdGlvbih0LGUpe3JldHVybiJzdHJpbmciPT10eXBlb2YgdD9lLnBhcnNlKHQsdGhpcyk6dH19KSx2PShyLmtkZj17fSkuT3BlblNTTD17ZXhlY3V0ZTpmdW5jdGlvbih0LGUscixuKXtufHwobj1pLnJhbmRvbSg4KSk7dmFyIG89dS5jcmVhdGUoe2tleVNpemU6ZStyfSkuY29tcHV0ZSh0LG4pLGE9aS5jcmVhdGUoby53b3Jkcy5zbGljZShlKSw0KnIpO3JldHVybiBvLnNpZ0J5dGVzPTQqZSxtLmNyZWF0ZSh7a2V5Om8saXY6YSxzYWx0Om59KX19LGI9bi5QYXNzd29yZEJhc2VkQ2lwaGVyPWcuZXh0ZW5kKHtjZmc6Zy5jZmcuZXh0ZW5kKHtrZGY6dn0pLGVuY3J5cHQ6ZnVuY3Rpb24odCxlLHIsbil7dmFyIG89KG49dGhpcy5jZmcuZXh0ZW5kKG4pKS5rZGYuZXhlY3V0ZShyLHQua2V5U2l6ZSx0Lml2U2l6ZSk7bi5pdj1vLml2O3ZhciBpPWcuZW5jcnlwdC5jYWxsKHRoaXMsdCxlLG8ua2V5LG4pO3JldHVybiBpLm1peEluKG8pLGl9LGRlY3J5cHQ6ZnVuY3Rpb24odCxlLHIsbil7bj10aGlzLmNmZy5leHRlbmQobiksZT10aGlzLl9wYXJzZShlLG4uZm9ybWF0KTt2YXIgbz1uLmtkZi5leGVjdXRlKHIsdC5rZXlTaXplLHQuaXZTaXplLGUuc2FsdCk7cmV0dXJuIG4uaXY9by5pdixnLmRlY3J5cHQuY2FsbCh0aGlzLHQsZSxvLmtleSxuKX19KSl9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jb3JlIjo1Mn1dLDUyOltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbigpe3ZhciB0LGUscixuLG8saSxhLHMsYyx1LGYsbCxwPXB8fCh0PU1hdGgsZT1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByO3JldHVybiB0LnByb3RvdHlwZT1lLHI9bmV3IHQsdC5wcm90b3R5cGU9bnVsbCxyfX0oKSxuPShyPXt9KS5saWI9e30sbz1uLkJhc2U9e2V4dGVuZDpmdW5jdGlvbih0KXt2YXIgcj1lKHRoaXMpO3JldHVybiB0JiZyLm1peEluKHQpLHIuaGFzT3duUHJvcGVydHkoImluaXQiKSYmdGhpcy5pbml0IT09ci5pbml0fHwoci5pbml0PWZ1bmN0aW9uKCl7ci4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSxyLmluaXQucHJvdG90eXBlPXIsci4kc3VwZXI9dGhpcyxyfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmV4dGVuZCgpO3JldHVybiB0LmluaXQuYXBwbHkodCxhcmd1bWVudHMpLHR9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkmJih0aGlzW2VdPXRbZV0pO3QuaGFzT3duUHJvcGVydHkoInRvU3RyaW5nIikmJih0aGlzLnRvU3RyaW5nPXQudG9TdHJpbmcpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKX19LGk9bi5Xb3JkQXJyYXk9by5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMud29yZHM9dHx8W10sdGhpcy5zaWdCeXRlcz1udWxsIT1lP2U6NCp0Lmxlbmd0aH0sdG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuKHR8fHMpLnN0cmluZ2lmeSh0aGlzKX0sY29uY2F0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMud29yZHMscj10LndvcmRzLG49dGhpcy5zaWdCeXRlcyxvPXQuc2lnQnl0ZXM7aWYodGhpcy5jbGFtcCgpLG4lNClmb3IodmFyIGk9MDtpPG87aSsrKXt2YXIgYT1yW2k+Pj4yXT4+PjI0LWklNCo4JjI1NTtlW24raT4+PjJdfD1hPDwyNC0obitpKSU0Kjh9ZWxzZSBmb3IoaT0wO2k8bztpKz00KWVbbitpPj4+Ml09cltpPj4+Ml07cmV0dXJuIHRoaXMuc2lnQnl0ZXMrPW8sdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndvcmRzLHI9dGhpcy5zaWdCeXRlcztlW3I+Pj4yXSY9NDI5NDk2NzI5NTw8MzItciU0KjgsZS5sZW5ndGg9dC5jZWlsKHIvNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9by5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0LndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCksdH0scmFuZG9tOmZ1bmN0aW9uKGUpe2Zvcih2YXIgcixuPVtdLG89ZnVuY3Rpb24oZSl7ZT1lO3ZhciByPTk4NzY1NDMyMSxuPTQyOTQ5NjcyOTU7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG89KChyPTM2OTY5Kig2NTUzNSZyKSsocj4+MTYpJm4pPDwxNikrKGU9MThlMyooNjU1MzUmZSkrKGU+PjE2KSZuKSZuO3JldHVybiBvLz00Mjk0OTY3Mjk2LChvKz0uNSkqKHQucmFuZG9tKCk+LjU/MTotMSl9fSxhPTA7YTxlO2ErPTQpe3ZhciBzPW8oNDI5NDk2NzI5Nioocnx8dC5yYW5kb20oKSkpO3I9OTg3NjU0MDcxKnMoKSxuLnB1c2goNDI5NDk2NzI5NipzKCl8MCl9cmV0dXJuIG5ldyBpLmluaXQobixlKX19KSxhPXIuZW5jPXt9LHM9YS5IZXg9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC53b3JkcyxyPXQuc2lnQnl0ZXMsbj1bXSxvPTA7bzxyO28rKyl7dmFyIGk9ZVtvPj4+Ml0+Pj4yNC1vJTQqOCYyNTU7bi5wdXNoKChpPj4+NCkudG9TdHJpbmcoMTYpKSxuLnB1c2goKDE1JmkpLnRvU3RyaW5nKDE2KSl9cmV0dXJuIG4uam9pbigiIil9LHBhcnNlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxyPVtdLG49MDtuPGU7bis9MilyW24+Pj4zXXw9cGFyc2VJbnQodC5zdWJzdHIobiwyKSwxNik8PDI0LW4lOCo0O3JldHVybiBuZXcgaS5pbml0KHIsZS8yKX19LGM9YS5MYXRpbjE9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC53b3JkcyxyPXQuc2lnQnl0ZXMsbj1bXSxvPTA7bzxyO28rKyl7dmFyIGk9ZVtvPj4+Ml0+Pj4yNC1vJTQqOCYyNTU7bi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpfXJldHVybiBuLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgscj1bXSxuPTA7bjxlO24rKylyW24+Pj4yXXw9KDI1NSZ0LmNoYXJDb2RlQXQobikpPDwyNC1uJTQqODtyZXR1cm4gbmV3IGkuaW5pdChyLGUpfX0sdT1hLlV0Zjg9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoYy5zdHJpbmdpZnkodCkpKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoIk1hbGZvcm1lZCBVVEYtOCBkYXRhIil9fSxwYXJzZTpmdW5jdGlvbih0KXtyZXR1cm4gYy5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodCkpKX19LGY9bi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtPW8uZXh0ZW5kKHtyZXNldDpmdW5jdGlvbigpe3RoaXMuX2RhdGE9bmV3IGkuaW5pdCx0aGlzLl9uRGF0YUJ5dGVzPTB9LF9hcHBlbmQ6ZnVuY3Rpb24odCl7InN0cmluZyI9PXR5cGVvZiB0JiYodD11LnBhcnNlKHQpKSx0aGlzLl9kYXRhLmNvbmNhdCh0KSx0aGlzLl9uRGF0YUJ5dGVzKz10LnNpZ0J5dGVzfSxfcHJvY2VzczpmdW5jdGlvbihlKXt2YXIgcj10aGlzLl9kYXRhLG49ci53b3JkcyxvPXIuc2lnQnl0ZXMsYT10aGlzLmJsb2NrU2l6ZSxzPW8vKDQqYSksYz0ocz1lP3QuY2VpbChzKTp0Lm1heCgoMHxzKS10aGlzLl9taW5CdWZmZXJTaXplLDApKSphLHU9dC5taW4oNCpjLG8pO2lmKGMpe2Zvcih2YXIgZj0wO2Y8YztmKz1hKXRoaXMuX2RvUHJvY2Vzc0Jsb2NrKG4sZik7dmFyIGw9bi5zcGxpY2UoMCxjKTtyLnNpZ0J5dGVzLT11fXJldHVybiBuZXcgaS5pbml0KGwsdSl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9by5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0Ll9kYXRhPXRoaXMuX2RhdGEuY2xvbmUoKSx0fSxfbWluQnVmZmVyU2l6ZTowfSksbi5IYXNoZXI9Zi5leHRlbmQoe2NmZzpvLmV4dGVuZCgpLGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKHQpLHRoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXtmLnJlc2V0LmNhbGwodGhpcyksdGhpcy5fZG9SZXNldCgpfSx1cGRhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2FwcGVuZCh0KSx0aGlzLl9wcm9jZXNzKCksdGhpc30sZmluYWxpemU6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMuX2FwcGVuZCh0KSx0aGlzLl9kb0ZpbmFsaXplKCl9LGJsb2NrU2l6ZToxNixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIpe3JldHVybiBuZXcgdC5pbml0KHIpLmZpbmFsaXplKGUpfX0sX2NyZWF0ZUhtYWNIZWxwZXI6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUscil7cmV0dXJuIG5ldyBsLkhNQUMuaW5pdCh0LHIpLmZpbmFsaXplKGUpfX19KSxsPXIuYWxnbz17fSxyKTtyZXR1cm4gcH0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8oKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxvKTpuLkNyeXB0b0pTPW8oKX0se31dLDUzOltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LHI9ZS5saWIuV29yZEFycmF5O2UuZW5jLkJhc2U2ND17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3ZhciBlPXQud29yZHMscj10LnNpZ0J5dGVzLG49dGhpcy5fbWFwO3QuY2xhbXAoKTtmb3IodmFyIG89W10saT0wO2k8cjtpKz0zKWZvcih2YXIgYT0oZVtpPj4+Ml0+Pj4yNC1pJTQqOCYyNTUpPDwxNnwoZVtpKzE+Pj4yXT4+PjI0LShpKzEpJTQqOCYyNTUpPDw4fGVbaSsyPj4+Ml0+Pj4yNC0oaSsyKSU0KjgmMjU1LHM9MDtzPDQmJmkrLjc1KnM8cjtzKyspby5wdXNoKG4uY2hhckF0KGE+Pj42KigzLXMpJjYzKSk7dmFyIGM9bi5jaGFyQXQoNjQpO2lmKGMpZm9yKDtvLmxlbmd0aCU0OylvLnB1c2goYyk7cmV0dXJuIG8uam9pbigiIil9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoLG49dGhpcy5fbWFwLG89dGhpcy5fcmV2ZXJzZU1hcDtpZighbyl7bz10aGlzLl9yZXZlcnNlTWFwPVtdO2Zvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKW9bbi5jaGFyQ29kZUF0KGkpXT1pfXZhciBhPW4uY2hhckF0KDY0KTtpZihhKXt2YXIgcz10LmluZGV4T2YoYSk7LTEhPT1zJiYoZT1zKX1yZXR1cm4gZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgbz1bXSxpPTAsYT0wO2E8ZTthKyspaWYoYSU0KXt2YXIgcz1uW3QuY2hhckNvZGVBdChhLTEpXTw8YSU0KjIsYz1uW3QuY2hhckNvZGVBdChhKV0+Pj42LWElNCoyO29baT4+PjJdfD0oc3xjKTw8MjQtaSU0KjgsaSsrfXJldHVybiByLmNyZWF0ZShvLGkpfSh0LGUsbyl9LF9tYXA6IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89In19KCksdC5lbmMuQmFzZTY0fSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY29yZSI6NTJ9XSw1NDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dCxyPWUubGliLldvcmRBcnJheSxuPWUuZW5jO24uVXRmMTY9bi5VdGYxNkJFPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMscj10LnNpZ0J5dGVzLG49W10sbz0wO288cjtvKz0yKXt2YXIgaT1lW28+Pj4yXT4+PjE2LW8lNCo4JjY1NTM1O24ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKX1yZXR1cm4gbi5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10sbz0wO288ZTtvKyspbltvPj4+MV18PXQuY2hhckNvZGVBdChvKTw8MTYtbyUyKjE2O3JldHVybiByLmNyZWF0ZShuLDIqZSl9fTtmdW5jdGlvbiBvKHQpe3JldHVybiB0PDw4JjQyNzgyNTUzNjB8dD4+PjgmMTY3MTE5MzV9bi5VdGYxNkxFPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMscj10LnNpZ0J5dGVzLG49W10saT0wO2k8cjtpKz0yKXt2YXIgYT1vKGVbaT4+PjJdPj4+MTYtaSU0KjgmNjU1MzUpO24ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKX1yZXR1cm4gbi5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10saT0wO2k8ZTtpKyspbltpPj4+MV18PW8odC5jaGFyQ29kZUF0KGkpPDwxNi1pJTIqMTYpO3JldHVybiByLmNyZWF0ZShuLDIqZSl9fX0oKSx0LmVuYy5VdGYxNn0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NvcmUiOjUyfV0sNTU6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixvLGksYSxzO3JldHVybiByPShlPXQpLmxpYixuPXIuQmFzZSxvPXIuV29yZEFycmF5LGk9ZS5hbGdvLGE9aS5NRDUscz1pLkV2cEtERj1uLmV4dGVuZCh7Y2ZnOm4uZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOmEsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbih0KXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQodCl9LGNvbXB1dGU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy5jZmcsbj1yLmhhc2hlci5jcmVhdGUoKSxpPW8uY3JlYXRlKCksYT1pLndvcmRzLHM9ci5rZXlTaXplLGM9ci5pdGVyYXRpb25zO2EubGVuZ3RoPHM7KXt1JiZuLnVwZGF0ZSh1KTt2YXIgdT1uLnVwZGF0ZSh0KS5maW5hbGl6ZShlKTtuLnJlc2V0KCk7Zm9yKHZhciBmPTE7ZjxjO2YrKyl1PW4uZmluYWxpemUodSksbi5yZXNldCgpO2kuY29uY2F0KHUpfXJldHVybiBpLnNpZ0J5dGVzPTQqcyxpfX0pLGUuRXZwS0RGPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gcy5jcmVhdGUocikuY29tcHV0ZSh0LGUpfSx0LkV2cEtERn0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIiksdCgiLi9zaGExIiksdCgiLi9obWFjIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9zaGExIiwiLi9obWFjIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NvcmUiOjUyLCIuL2htYWMiOjU3LCIuL3NoYTEiOjc2fV0sNTY6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtyZXR1cm4gcj0oZT10KS5saWIuQ2lwaGVyUGFyYW1zLG49ZS5lbmMuSGV4LGUuZm9ybWF0LkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmNpcGhlcnRleHQudG9TdHJpbmcobil9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBlPW4ucGFyc2UodCk7cmV0dXJuIHIuY3JlYXRlKHtjaXBoZXJ0ZXh0OmV9KX19LHQuZm9ybWF0LkhleH0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNTc6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtyPShlPXQpLmxpYi5CYXNlLG49ZS5lbmMuVXRmOCxlLmFsZ28uSE1BQz1yLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3Q9dGhpcy5faGFzaGVyPW5ldyB0LmluaXQsInN0cmluZyI9PXR5cGVvZiBlJiYoZT1uLnBhcnNlKGUpKTt2YXIgcj10LmJsb2NrU2l6ZSxvPTQqcjtlLnNpZ0J5dGVzPm8mJihlPXQuZmluYWxpemUoZSkpLGUuY2xhbXAoKTtmb3IodmFyIGk9dGhpcy5fb0tleT1lLmNsb25lKCksYT10aGlzLl9pS2V5PWUuY2xvbmUoKSxzPWkud29yZHMsYz1hLndvcmRzLHU9MDt1PHI7dSsrKXNbdV1ePTE1NDk1NTY4MjgsY1t1XV49OTA5NTIyNDg2O2kuc2lnQnl0ZXM9YS5zaWdCeXRlcz1vLHRoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9oYXNoZXI7dC5yZXNldCgpLHQudXBkYXRlKHRoaXMuX2lLZXkpfSx1cGRhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2hhc2hlci51cGRhdGUodCksdGhpc30sZmluYWxpemU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5faGFzaGVyLHI9ZS5maW5hbGl6ZSh0KTtyZXR1cm4gZS5yZXNldCgpLGUuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChyKSl9fSl9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jb3JlIjo1Mn1dLDU4OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gdH0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIiksdCgiLi94NjQtY29yZSIpLHQoIi4vbGliLXR5cGVkYXJyYXlzIiksdCgiLi9lbmMtdXRmMTYiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vc2hhMSIpLHQoIi4vc2hhMjU2IiksdCgiLi9zaGEyMjQiKSx0KCIuL3NoYTUxMiIpLHQoIi4vc2hhMzg0IiksdCgiLi9zaGEzIiksdCgiLi9yaXBlbWQxNjAiKSx0KCIuL2htYWMiKSx0KCIuL3Bia2RmMiIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpLHQoIi4vbW9kZS1jZmIiKSx0KCIuL21vZGUtY3RyIiksdCgiLi9tb2RlLWN0ci1nbGFkbWFuIiksdCgiLi9tb2RlLW9mYiIpLHQoIi4vbW9kZS1lY2IiKSx0KCIuL3BhZC1hbnNpeDkyMyIpLHQoIi4vcGFkLWlzbzEwMTI2IiksdCgiLi9wYWQtaXNvOTc5NzEiKSx0KCIuL3BhZC16ZXJvcGFkZGluZyIpLHQoIi4vcGFkLW5vcGFkZGluZyIpLHQoIi4vZm9ybWF0LWhleCIpLHQoIi4vYWVzIiksdCgiLi90cmlwbGVkZXMiKSx0KCIuL3JjNCIpLHQoIi4vcmFiYml0IiksdCgiLi9yYWJiaXQtbGVnYWN5IikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi94NjQtY29yZSIsIi4vbGliLXR5cGVkYXJyYXlzIiwiLi9lbmMtdXRmMTYiLCIuL2VuYy1iYXNlNjQiLCIuL21kNSIsIi4vc2hhMSIsIi4vc2hhMjU2IiwiLi9zaGEyMjQiLCIuL3NoYTUxMiIsIi4vc2hhMzg0IiwiLi9zaGEzIiwiLi9yaXBlbWQxNjAiLCIuL2htYWMiLCIuL3Bia2RmMiIsIi4vZXZwa2RmIiwiLi9jaXBoZXItY29yZSIsIi4vbW9kZS1jZmIiLCIuL21vZGUtY3RyIiwiLi9tb2RlLWN0ci1nbGFkbWFuIiwiLi9tb2RlLW9mYiIsIi4vbW9kZS1lY2IiLCIuL3BhZC1hbnNpeDkyMyIsIi4vcGFkLWlzbzEwMTI2IiwiLi9wYWQtaXNvOTc5NzEiLCIuL3BhZC16ZXJvcGFkZGluZyIsIi4vcGFkLW5vcGFkZGluZyIsIi4vZm9ybWF0LWhleCIsIi4vYWVzIiwiLi90cmlwbGVkZXMiLCIuL3JjNCIsIi4vcmFiYml0IiwiLi9yYWJiaXQtbGVnYWN5Il0sbyk6bi5DcnlwdG9KUz1vKG4uQ3J5cHRvSlMpfSx7Ii4vYWVzIjo1MCwiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTIsIi4vZW5jLWJhc2U2NCI6NTMsIi4vZW5jLXV0ZjE2Ijo1NCwiLi9ldnBrZGYiOjU1LCIuL2Zvcm1hdC1oZXgiOjU2LCIuL2htYWMiOjU3LCIuL2xpYi10eXBlZGFycmF5cyI6NTksIi4vbWQ1Ijo2MCwiLi9tb2RlLWNmYiI6NjEsIi4vbW9kZS1jdHIiOjYzLCIuL21vZGUtY3RyLWdsYWRtYW4iOjYyLCIuL21vZGUtZWNiIjo2NCwiLi9tb2RlLW9mYiI6NjUsIi4vcGFkLWFuc2l4OTIzIjo2NiwiLi9wYWQtaXNvMTAxMjYiOjY3LCIuL3BhZC1pc285Nzk3MSI6NjgsIi4vcGFkLW5vcGFkZGluZyI6NjksIi4vcGFkLXplcm9wYWRkaW5nIjo3MCwiLi9wYmtkZjIiOjcxLCIuL3JhYmJpdCI6NzMsIi4vcmFiYml0LWxlZ2FjeSI6NzIsIi4vcmM0Ijo3NCwiLi9yaXBlbWQxNjAiOjc1LCIuL3NoYTEiOjc2LCIuL3NoYTIyNCI6NzcsIi4vc2hhMjU2Ijo3OCwiLi9zaGEzIjo3OSwiLi9zaGEzODQiOjgwLCIuL3NoYTUxMiI6ODEsIi4vdHJpcGxlZGVzIjo4MiwiLi94NjQtY29yZSI6ODN9XSw1OTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIEFycmF5QnVmZmVyKXt2YXIgZT10LmxpYi5Xb3JkQXJyYXkscj1lLmluaXQ7KGUuaW5pdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih0PW5ldyBVaW50OEFycmF5KHQpKSwodCBpbnN0YW5jZW9mIEludDhBcnJheXx8InVuZGVmaW5lZCIhPXR5cGVvZiBVaW50OENsYW1wZWRBcnJheSYmdCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHx0IGluc3RhbmNlb2YgSW50MTZBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSYmKHQ9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtmb3IodmFyIGU9dC5ieXRlTGVuZ3RoLG49W10sbz0wO288ZTtvKyspbltvPj4+Ml18PXRbb108PDI0LW8lNCo4O3IuY2FsbCh0aGlzLG4sZSl9ZWxzZSByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pLnByb3RvdHlwZT1lfX0oKSx0LmxpYi5Xb3JkQXJyYXl9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jb3JlIjo1Mn1dLDYwOltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI9dCxuPXIubGliLG89bi5Xb3JkQXJyYXksaT1uLkhhc2hlcixhPXIuYWxnbyxzPVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8NjQ7dCsrKXNbdF09NDI5NDk2NzI5NiplLmFicyhlLnNpbih0KzEpKXwwfSgpO3ZhciBjPWEuTUQ1PWkuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IG8uaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj0wO3I8MTY7cisrKXt2YXIgbj1lK3Isbz10W25dO3Rbbl09MTY3MTE5MzUmKG88PDh8bz4+PjI0KXw0Mjc4MjU1MzYwJihvPDwyNHxvPj4+OCl9dmFyIGk9dGhpcy5faGFzaC53b3JkcyxhPXRbZSswXSxjPXRbZSsxXSxoPXRbZSsyXSxkPXRbZSszXSxtPXRbZSs0XSx5PXRbZSs1XSxnPXRbZSs2XSx2PXRbZSs3XSxiPXRbZSs4XSxfPXRbZSs5XSx3PXRbZSsxMF0seD10W2UrMTFdLGs9dFtlKzEyXSxCPXRbZSsxM10sUz10W2UrMTRdLEE9dFtlKzE1XSxDPWlbMF0sRj1pWzFdLE89aVsyXSxJPWlbM107Rj1wKEY9cChGPXAoRj1wKEY9bChGPWwoRj1sKEY9bChGPWYoRj1mKEY9ZihGPWYoRj11KEY9dShGPXUoRj11KEYsTz11KE8sST11KEksQz11KEMsRixPLEksYSw3LHNbMF0pLEYsTyxjLDEyLHNbMV0pLEMsRixoLDE3LHNbMl0pLEksQyxkLDIyLHNbM10pLE89dShPLEk9dShJLEM9dShDLEYsTyxJLG0sNyxzWzRdKSxGLE8seSwxMixzWzVdKSxDLEYsZywxNyxzWzZdKSxJLEMsdiwyMixzWzddKSxPPXUoTyxJPXUoSSxDPXUoQyxGLE8sSSxiLDcsc1s4XSksRixPLF8sMTIsc1s5XSksQyxGLHcsMTcsc1sxMF0pLEksQyx4LDIyLHNbMTFdKSxPPXUoTyxJPXUoSSxDPXUoQyxGLE8sSSxrLDcsc1sxMl0pLEYsTyxCLDEyLHNbMTNdKSxDLEYsUywxNyxzWzE0XSksSSxDLEEsMjIsc1sxNV0pLE89ZihPLEk9ZihJLEM9ZihDLEYsTyxJLGMsNSxzWzE2XSksRixPLGcsOSxzWzE3XSksQyxGLHgsMTQsc1sxOF0pLEksQyxhLDIwLHNbMTldKSxPPWYoTyxJPWYoSSxDPWYoQyxGLE8sSSx5LDUsc1syMF0pLEYsTyx3LDksc1syMV0pLEMsRixBLDE0LHNbMjJdKSxJLEMsbSwyMCxzWzIzXSksTz1mKE8sST1mKEksQz1mKEMsRixPLEksXyw1LHNbMjRdKSxGLE8sUyw5LHNbMjVdKSxDLEYsZCwxNCxzWzI2XSksSSxDLGIsMjAsc1syN10pLE89ZihPLEk9ZihJLEM9ZihDLEYsTyxJLEIsNSxzWzI4XSksRixPLGgsOSxzWzI5XSksQyxGLHYsMTQsc1szMF0pLEksQyxrLDIwLHNbMzFdKSxPPWwoTyxJPWwoSSxDPWwoQyxGLE8sSSx5LDQsc1szMl0pLEYsTyxiLDExLHNbMzNdKSxDLEYseCwxNixzWzM0XSksSSxDLFMsMjMsc1szNV0pLE89bChPLEk9bChJLEM9bChDLEYsTyxJLGMsNCxzWzM2XSksRixPLG0sMTEsc1szN10pLEMsRix2LDE2LHNbMzhdKSxJLEMsdywyMyxzWzM5XSksTz1sKE8sST1sKEksQz1sKEMsRixPLEksQiw0LHNbNDBdKSxGLE8sYSwxMSxzWzQxXSksQyxGLGQsMTYsc1s0Ml0pLEksQyxnLDIzLHNbNDNdKSxPPWwoTyxJPWwoSSxDPWwoQyxGLE8sSSxfLDQsc1s0NF0pLEYsTyxrLDExLHNbNDVdKSxDLEYsQSwxNixzWzQ2XSksSSxDLGgsMjMsc1s0N10pLE89cChPLEk9cChJLEM9cChDLEYsTyxJLGEsNixzWzQ4XSksRixPLHYsMTAsc1s0OV0pLEMsRixTLDE1LHNbNTBdKSxJLEMseSwyMSxzWzUxXSksTz1wKE8sST1wKEksQz1wKEMsRixPLEksayw2LHNbNTJdKSxGLE8sZCwxMCxzWzUzXSksQyxGLHcsMTUsc1s1NF0pLEksQyxjLDIxLHNbNTVdKSxPPXAoTyxJPXAoSSxDPXAoQyxGLE8sSSxiLDYsc1s1Nl0pLEYsTyxBLDEwLHNbNTddKSxDLEYsZywxNSxzWzU4XSksSSxDLEIsMjEsc1s1OV0pLE89cChPLEk9cChJLEM9cChDLEYsTyxJLG0sNixzWzYwXSksRixPLHgsMTAsc1s2MV0pLEMsRixoLDE1LHNbNjJdKSxJLEMsXywyMSxzWzYzXSksaVswXT1pWzBdK0N8MCxpWzFdPWlbMV0rRnwwLGlbMl09aVsyXStPfDAsaVszXT1pWzNdK0l8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLHI9dC53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxvPTgqdC5zaWdCeXRlcztyW28+Pj41XXw9MTI4PDwyNC1vJTMyO3ZhciBpPWUuZmxvb3Iobi80Mjk0OTY3Mjk2KSxhPW47clsxNSsobys2ND4+Pjk8PDQpXT0xNjcxMTkzNSYoaTw8OHxpPj4+MjQpfDQyNzgyNTUzNjAmKGk8PDI0fGk+Pj44KSxyWzE0KyhvKzY0Pj4+OTw8NCldPTE2NzExOTM1JihhPDw4fGE+Pj4yNCl8NDI3ODI1NTM2MCYoYTw8MjR8YT4+PjgpLHQuc2lnQnl0ZXM9NCooci5sZW5ndGgrMSksdGhpcy5fcHJvY2VzcygpO2Zvcih2YXIgcz10aGlzLl9oYXNoLGM9cy53b3Jkcyx1PTA7dTw0O3UrKyl7dmFyIGY9Y1t1XTtjW3VdPTE2NzExOTM1JihmPDw4fGY+Pj4yNCl8NDI3ODI1NTM2MCYoZjw8MjR8Zj4+PjgpfXJldHVybiBzfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWkuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTtmdW5jdGlvbiB1KHQsZSxyLG4sbyxpLGEpe3ZhciBzPXQrKGUmcnx+ZSZuKStvK2E7cmV0dXJuKHM8PGl8cz4+PjMyLWkpK2V9ZnVuY3Rpb24gZih0LGUscixuLG8saSxhKXt2YXIgcz10KyhlJm58ciZ+bikrbythO3JldHVybihzPDxpfHM+Pj4zMi1pKStlfWZ1bmN0aW9uIGwodCxlLHIsbixvLGksYSl7dmFyIHM9dCsoZV5yXm4pK28rYTtyZXR1cm4oczw8aXxzPj4+MzItaSkrZX1mdW5jdGlvbiBwKHQsZSxyLG4sbyxpLGEpe3ZhciBzPXQrKHJeKGV8fm4pKStvK2E7cmV0dXJuKHM8PGl8cz4+PjMyLWkpK2V9ci5NRDU9aS5fY3JlYXRlSGVscGVyKGMpLHIuSG1hY01ENT1pLl9jcmVhdGVIbWFjSGVscGVyKGMpfShNYXRoKSx0Lk1ENX0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NvcmUiOjUyfV0sNjE6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuQ0ZCPWZ1bmN0aW9uKCl7dmFyIGU9dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO2Z1bmN0aW9uIHIodCxlLHIsbil7dmFyIG89dGhpcy5faXY7aWYobyl7dmFyIGk9by5zbGljZSgwKTt0aGlzLl9pdj12b2lkIDB9ZWxzZSBpPXRoaXMuX3ByZXZCbG9jaztuLmVuY3J5cHRCbG9jayhpLDApO2Zvcih2YXIgYT0wO2E8cjthKyspdFtlK2FdXj1pW2FdfXJldHVybiBlLkVuY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fY2lwaGVyLG89bi5ibG9ja1NpemU7ci5jYWxsKHRoaXMsdCxlLG8sbiksdGhpcy5fcHJldkJsb2NrPXQuc2xpY2UoZSxlK28pfX0pLGUuRGVjcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9jaXBoZXIsbz1uLmJsb2NrU2l6ZSxpPXQuc2xpY2UoZSxlK28pO3IuY2FsbCh0aGlzLHQsZSxvLG4pLHRoaXMuX3ByZXZCbG9jaz1pfX0pLGV9KCksdC5tb2RlLkNGQn0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjI6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuQ1RSR2xhZG1hbj1mdW5jdGlvbigpe3ZhciBlPXQubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtmdW5jdGlvbiByKHQpe2lmKDI1NT09KHQ+PjI0JjI1NSkpe3ZhciBlPXQ+PjE2JjI1NSxyPXQ+PjgmMjU1LG49MjU1JnQ7MjU1PT09ZT8oZT0wLDI1NT09PXI/KHI9MCwyNTU9PT1uP249MDorK24pOisrcik6KytlLHQ9MCx0Kz1lPDwxNix0Kz1yPDw4LHQrPW59ZWxzZSB0Kz0xPDwyNDtyZXR1cm4gdH12YXIgbj1lLkVuY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIG4sbz10aGlzLl9jaXBoZXIsaT1vLmJsb2NrU2l6ZSxhPXRoaXMuX2l2LHM9dGhpcy5fY291bnRlcjthJiYocz10aGlzLl9jb3VudGVyPWEuc2xpY2UoMCksdGhpcy5faXY9dm9pZCAwKSwwPT09KChuPXMpWzBdPXIoblswXSkpJiYoblsxXT1yKG5bMV0pKTt2YXIgYz1zLnNsaWNlKDApO28uZW5jcnlwdEJsb2NrKGMsMCk7Zm9yKHZhciB1PTA7dTxpO3UrKyl0W2UrdV1ePWNbdV19fSk7cmV0dXJuIGUuRGVjcnlwdG9yPW4sZX0oKSx0Lm1vZGUuQ1RSR2xhZG1hbn0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjM6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3ZhciBlLHI7cmV0dXJuIHQubW9kZS5DVFI9KGU9dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpLHI9ZS5FbmNyeXB0b3I9ZS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuX2NpcGhlcixuPXIuYmxvY2tTaXplLG89dGhpcy5faXYsaT10aGlzLl9jb3VudGVyO28mJihpPXRoaXMuX2NvdW50ZXI9by5zbGljZSgwKSx0aGlzLl9pdj12b2lkIDApO3ZhciBhPWkuc2xpY2UoMCk7ci5lbmNyeXB0QmxvY2soYSwwKSxpW24tMV09aVtuLTFdKzF8MDtmb3IodmFyIHM9MDtzPG47cysrKXRbZStzXV49YVtzXX19KSxlLkRlY3J5cHRvcj1yLGUpLHQubW9kZS5DVFJ9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1Mn1dLDY0OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gdC5tb2RlLkVDQj0oKGU9dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpKS5FbmNyeXB0b3I9ZS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodCxlKX19KSxlLkRlY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fY2lwaGVyLmRlY3J5cHRCbG9jayh0LGUpfX0pLGUpLHQubW9kZS5FQ0J9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1Mn1dLDY1OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXt2YXIgZSxyO3JldHVybiB0Lm1vZGUuT0ZCPShlPXQubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKSxyPWUuRW5jcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLl9jaXBoZXIsbj1yLmJsb2NrU2l6ZSxvPXRoaXMuX2l2LGk9dGhpcy5fa2V5c3RyZWFtO28mJihpPXRoaXMuX2tleXN0cmVhbT1vLnNsaWNlKDApLHRoaXMuX2l2PXZvaWQgMCksci5lbmNyeXB0QmxvY2soaSwwKTtmb3IodmFyIGE9MDthPG47YSsrKXRbZSthXV49aVthXX19KSxlLkRlY3J5cHRvcj1yLGUpLHQubW9kZS5PRkJ9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1Mn1dLDY2OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuQW5zaVg5MjM9e3BhZDpmdW5jdGlvbih0LGUpe3ZhciByPXQuc2lnQnl0ZXMsbj00KmUsbz1uLXIlbixpPXIrby0xO3QuY2xhbXAoKSx0LndvcmRzW2k+Pj4yXXw9bzw8MjQtaSU0KjgsdC5zaWdCeXRlcys9b30sdW5wYWQ6ZnVuY3Rpb24odCl7dmFyIGU9MjU1JnQud29yZHNbdC5zaWdCeXRlcy0xPj4+Ml07dC5zaWdCeXRlcy09ZX19LHQucGFkLkFuc2l4OTIzfSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9jaXBoZXItY29yZSJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2NzpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7cmV0dXJuIHQucGFkLklzbzEwMTI2PXtwYWQ6ZnVuY3Rpb24oZSxyKXt2YXIgbj00KnIsbz1uLWUuc2lnQnl0ZXMlbjtlLmNvbmNhdCh0LmxpYi5Xb3JkQXJyYXkucmFuZG9tKG8tMSkpLmNvbmNhdCh0LmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtvPDwyNF0sMSkpfSx1bnBhZDpmdW5jdGlvbih0KXt2YXIgZT0yNTUmdC53b3Jkc1t0LnNpZ0J5dGVzLTE+Pj4yXTt0LnNpZ0J5dGVzLT1lfX0sdC5wYWQuSXNvMTAxMjZ9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1Mn1dLDY4OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuSXNvOTc5NzE9e3BhZDpmdW5jdGlvbihlLHIpe2UuY29uY2F0KHQubGliLldvcmRBcnJheS5jcmVhdGUoWzIxNDc0ODM2NDhdLDEpKSx0LnBhZC5aZXJvUGFkZGluZy5wYWQoZSxyKX0sdW5wYWQ6ZnVuY3Rpb24oZSl7dC5wYWQuWmVyb1BhZGRpbmcudW5wYWQoZSksZS5zaWdCeXRlcy0tfX0sdC5wYWQuSXNvOTc5NzF9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1Mn1dLDY5OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuTm9QYWRkaW5nPXtwYWQ6ZnVuY3Rpb24oKXt9LHVucGFkOmZ1bmN0aW9uKCl7fX0sdC5wYWQuTm9QYWRkaW5nfSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9jaXBoZXItY29yZSJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw3MDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7cmV0dXJuIHQucGFkLlplcm9QYWRkaW5nPXtwYWQ6ZnVuY3Rpb24odCxlKXt2YXIgcj00KmU7dC5jbGFtcCgpLHQuc2lnQnl0ZXMrPXItKHQuc2lnQnl0ZXMlcnx8cil9LHVucGFkOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LndvcmRzLHI9dC5zaWdCeXRlcy0xOyEoZVtyPj4+Ml0+Pj4yNC1yJTQqOCYyNTUpOylyLS07dC5zaWdCeXRlcz1yKzF9fSx0LnBhZC5aZXJvUGFkZGluZ30sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNzE6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixvLGksYSxzLGM7cmV0dXJuIHI9KGU9dCkubGliLG49ci5CYXNlLG89ci5Xb3JkQXJyYXksaT1lLmFsZ28sYT1pLlNIQTEscz1pLkhNQUMsYz1pLlBCS0RGMj1uLmV4dGVuZCh7Y2ZnOm4uZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOmEsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbih0KXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQodCl9LGNvbXB1dGU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy5jZmcsbj1zLmNyZWF0ZShyLmhhc2hlcix0KSxpPW8uY3JlYXRlKCksYT1vLmNyZWF0ZShbMV0pLGM9aS53b3Jkcyx1PWEud29yZHMsZj1yLmtleVNpemUsbD1yLml0ZXJhdGlvbnM7Yy5sZW5ndGg8Zjspe3ZhciBwPW4udXBkYXRlKGUpLmZpbmFsaXplKGEpO24ucmVzZXQoKTtmb3IodmFyIGg9cC53b3JkcyxkPWgubGVuZ3RoLG09cCx5PTE7eTxsO3krKyl7bT1uLmZpbmFsaXplKG0pLG4ucmVzZXQoKTtmb3IodmFyIGc9bS53b3Jkcyx2PTA7djxkO3YrKyloW3ZdXj1nW3ZdfWkuY29uY2F0KHApLHVbMF0rK31yZXR1cm4gaS5zaWdCeXRlcz00KmYsaX19KSxlLlBCS0RGMj1mdW5jdGlvbih0LGUscil7cmV0dXJuIGMuY3JlYXRlKHIpLmNvbXB1dGUodCxlKX0sdC5QQktERjJ9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vc2hhMSIpLHQoIi4vaG1hYyIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vc2hhMSIsIi4vaG1hYyJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jb3JlIjo1MiwiLi9obWFjIjo1NywiLi9zaGExIjo3Nn1dLDcyOltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LHI9ZS5saWIuU3RyZWFtQ2lwaGVyLG49ZS5hbGdvLG89W10saT1bXSxhPVtdLHM9bi5SYWJiaXRMZWdhY3k9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fa2V5LndvcmRzLGU9dGhpcy5jZmcuaXYscj10aGlzLl9YPVt0WzBdLHRbM108PDE2fHRbMl0+Pj4xNix0WzFdLHRbMF08PDE2fHRbM10+Pj4xNix0WzJdLHRbMV08PDE2fHRbMF0+Pj4xNix0WzNdLHRbMl08PDE2fHRbMV0+Pj4xNl0sbj10aGlzLl9DPVt0WzJdPDwxNnx0WzJdPj4+MTYsNDI5NDkwMTc2MCZ0WzBdfDY1NTM1JnRbMV0sdFszXTw8MTZ8dFszXT4+PjE2LDQyOTQ5MDE3NjAmdFsxXXw2NTUzNSZ0WzJdLHRbMF08PDE2fHRbMF0+Pj4xNiw0Mjk0OTAxNzYwJnRbMl18NjU1MzUmdFszXSx0WzFdPDwxNnx0WzFdPj4+MTYsNDI5NDkwMTc2MCZ0WzNdfDY1NTM1JnRbMF1dO3RoaXMuX2I9MDtmb3IodmFyIG89MDtvPDQ7bysrKWMuY2FsbCh0aGlzKTtmb3Iobz0wO288ODtvKyspbltvXV49cltvKzQmN107aWYoZSl7dmFyIGk9ZS53b3JkcyxhPWlbMF0scz1pWzFdLHU9MTY3MTE5MzUmKGE8PDh8YT4+PjI0KXw0Mjc4MjU1MzYwJihhPDwyNHxhPj4+OCksZj0xNjcxMTkzNSYoczw8OHxzPj4+MjQpfDQyNzgyNTUzNjAmKHM8PDI0fHM+Pj44KSxsPXU+Pj4xNnw0Mjk0OTAxNzYwJmYscD1mPDwxNnw2NTUzNSZ1O25bMF1ePXUsblsxXV49bCxuWzJdXj1mLG5bM11ePXAsbls0XV49dSxuWzVdXj1sLG5bNl1ePWYsbls3XV49cDtmb3Iobz0wO288NDtvKyspYy5jYWxsKHRoaXMpfX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5fWDtjLmNhbGwodGhpcyksb1swXT1yWzBdXnJbNV0+Pj4xNl5yWzNdPDwxNixvWzFdPXJbMl1ecls3XT4+PjE2XnJbNV08PDE2LG9bMl09cls0XV5yWzFdPj4+MTZecls3XTw8MTYsb1szXT1yWzZdXnJbM10+Pj4xNl5yWzFdPDwxNjtmb3IodmFyIG49MDtuPDQ7bisrKW9bbl09MTY3MTE5MzUmKG9bbl08PDh8b1tuXT4+PjI0KXw0Mjc4MjU1MzYwJihvW25dPDwyNHxvW25dPj4+OCksdFtlK25dXj1vW25dfSxibG9ja1NpemU6NCxpdlNpemU6Mn0pO2Z1bmN0aW9uIGMoKXtmb3IodmFyIHQ9dGhpcy5fWCxlPXRoaXMuX0Mscj0wO3I8ODtyKyspaVtyXT1lW3JdO2VbMF09ZVswXSsxMjk1MzA3NTk3K3RoaXMuX2J8MCxlWzFdPWVbMV0rMzU0NTA1MjM3MSsoZVswXT4+PjA8aVswXT4+PjA/MTowKXwwLGVbMl09ZVsyXSs4ODYyNjMwOTIrKGVbMV0+Pj4wPGlbMV0+Pj4wPzE6MCl8MCxlWzNdPWVbM10rMTI5NTMwNzU5NysoZVsyXT4+PjA8aVsyXT4+PjA/MTowKXwwLGVbNF09ZVs0XSszNTQ1MDUyMzcxKyhlWzNdPj4+MDxpWzNdPj4+MD8xOjApfDAsZVs1XT1lWzVdKzg4NjI2MzA5MisoZVs0XT4+PjA8aVs0XT4+PjA/MTowKXwwLGVbNl09ZVs2XSsxMjk1MzA3NTk3KyhlWzVdPj4+MDxpWzVdPj4+MD8xOjApfDAsZVs3XT1lWzddKzM1NDUwNTIzNzErKGVbNl0+Pj4wPGlbNl0+Pj4wPzE6MCl8MCx0aGlzLl9iPWVbN10+Pj4wPGlbN10+Pj4wPzE6MDtmb3Iocj0wO3I8ODtyKyspe3ZhciBuPXRbcl0rZVtyXSxvPTY1NTM1Jm4scz1uPj4+MTYsYz0oKG8qbz4+PjE3KStvKnM+Pj4xNSkrcypzLHU9KCg0Mjk0OTAxNzYwJm4pKm58MCkrKCg2NTUzNSZuKSpufDApO2Fbcl09Y151fXRbMF09YVswXSsoYVs3XTw8MTZ8YVs3XT4+PjE2KSsoYVs2XTw8MTZ8YVs2XT4+PjE2KXwwLHRbMV09YVsxXSsoYVswXTw8OHxhWzBdPj4+MjQpK2FbN118MCx0WzJdPWFbMl0rKGFbMV08PDE2fGFbMV0+Pj4xNikrKGFbMF08PDE2fGFbMF0+Pj4xNil8MCx0WzNdPWFbM10rKGFbMl08PDh8YVsyXT4+PjI0KSthWzFdfDAsdFs0XT1hWzRdKyhhWzNdPDwxNnxhWzNdPj4+MTYpKyhhWzJdPDwxNnxhWzJdPj4+MTYpfDAsdFs1XT1hWzVdKyhhWzRdPDw4fGFbNF0+Pj4yNCkrYVszXXwwLHRbNl09YVs2XSsoYVs1XTw8MTZ8YVs1XT4+PjE2KSsoYVs0XTw8MTZ8YVs0XT4+PjE2KXwwLHRbN109YVs3XSsoYVs2XTw8OHxhWzZdPj4+MjQpK2FbNV18MH1lLlJhYmJpdExlZ2FjeT1yLl9jcmVhdGVIZWxwZXIocyl9KCksdC5SYWJiaXRMZWdhY3l9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vZW5jLWJhc2U2NCIpLHQoIi4vbWQ1IiksdCgiLi9ldnBrZGYiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyLCIuL2VuYy1iYXNlNjQiOjUzLCIuL2V2cGtkZiI6NTUsIi4vbWQ1Ijo2MH1dLDczOltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LHI9ZS5saWIuU3RyZWFtQ2lwaGVyLG49ZS5hbGdvLG89W10saT1bXSxhPVtdLHM9bi5SYWJiaXQ9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2tleS53b3JkcyxlPXRoaXMuY2ZnLml2LHI9MDtyPDQ7cisrKXRbcl09MTY3MTE5MzUmKHRbcl08PDh8dFtyXT4+PjI0KXw0Mjc4MjU1MzYwJih0W3JdPDwyNHx0W3JdPj4+OCk7dmFyIG49dGhpcy5fWD1bdFswXSx0WzNdPDwxNnx0WzJdPj4+MTYsdFsxXSx0WzBdPDwxNnx0WzNdPj4+MTYsdFsyXSx0WzFdPDwxNnx0WzBdPj4+MTYsdFszXSx0WzJdPDwxNnx0WzFdPj4+MTZdLG89dGhpcy5fQz1bdFsyXTw8MTZ8dFsyXT4+PjE2LDQyOTQ5MDE3NjAmdFswXXw2NTUzNSZ0WzFdLHRbM108PDE2fHRbM10+Pj4xNiw0Mjk0OTAxNzYwJnRbMV18NjU1MzUmdFsyXSx0WzBdPDwxNnx0WzBdPj4+MTYsNDI5NDkwMTc2MCZ0WzJdfDY1NTM1JnRbM10sdFsxXTw8MTZ8dFsxXT4+PjE2LDQyOTQ5MDE3NjAmdFszXXw2NTUzNSZ0WzBdXTt0aGlzLl9iPTA7Zm9yKHI9MDtyPDQ7cisrKWMuY2FsbCh0aGlzKTtmb3Iocj0wO3I8ODtyKyspb1tyXV49bltyKzQmN107aWYoZSl7dmFyIGk9ZS53b3JkcyxhPWlbMF0scz1pWzFdLHU9MTY3MTE5MzUmKGE8PDh8YT4+PjI0KXw0Mjc4MjU1MzYwJihhPDwyNHxhPj4+OCksZj0xNjcxMTkzNSYoczw8OHxzPj4+MjQpfDQyNzgyNTUzNjAmKHM8PDI0fHM+Pj44KSxsPXU+Pj4xNnw0Mjk0OTAxNzYwJmYscD1mPDwxNnw2NTUzNSZ1O29bMF1ePXUsb1sxXV49bCxvWzJdXj1mLG9bM11ePXAsb1s0XV49dSxvWzVdXj1sLG9bNl1ePWYsb1s3XV49cDtmb3Iocj0wO3I8NDtyKyspYy5jYWxsKHRoaXMpfX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5fWDtjLmNhbGwodGhpcyksb1swXT1yWzBdXnJbNV0+Pj4xNl5yWzNdPDwxNixvWzFdPXJbMl1ecls3XT4+PjE2XnJbNV08PDE2LG9bMl09cls0XV5yWzFdPj4+MTZecls3XTw8MTYsb1szXT1yWzZdXnJbM10+Pj4xNl5yWzFdPDwxNjtmb3IodmFyIG49MDtuPDQ7bisrKW9bbl09MTY3MTE5MzUmKG9bbl08PDh8b1tuXT4+PjI0KXw0Mjc4MjU1MzYwJihvW25dPDwyNHxvW25dPj4+OCksdFtlK25dXj1vW25dfSxibG9ja1NpemU6NCxpdlNpemU6Mn0pO2Z1bmN0aW9uIGMoKXtmb3IodmFyIHQ9dGhpcy5fWCxlPXRoaXMuX0Mscj0wO3I8ODtyKyspaVtyXT1lW3JdO2VbMF09ZVswXSsxMjk1MzA3NTk3K3RoaXMuX2J8MCxlWzFdPWVbMV0rMzU0NTA1MjM3MSsoZVswXT4+PjA8aVswXT4+PjA/MTowKXwwLGVbMl09ZVsyXSs4ODYyNjMwOTIrKGVbMV0+Pj4wPGlbMV0+Pj4wPzE6MCl8MCxlWzNdPWVbM10rMTI5NTMwNzU5NysoZVsyXT4+PjA8aVsyXT4+PjA/MTowKXwwLGVbNF09ZVs0XSszNTQ1MDUyMzcxKyhlWzNdPj4+MDxpWzNdPj4+MD8xOjApfDAsZVs1XT1lWzVdKzg4NjI2MzA5MisoZVs0XT4+PjA8aVs0XT4+PjA/MTowKXwwLGVbNl09ZVs2XSsxMjk1MzA3NTk3KyhlWzVdPj4+MDxpWzVdPj4+MD8xOjApfDAsZVs3XT1lWzddKzM1NDUwNTIzNzErKGVbNl0+Pj4wPGlbNl0+Pj4wPzE6MCl8MCx0aGlzLl9iPWVbN10+Pj4wPGlbN10+Pj4wPzE6MDtmb3Iocj0wO3I8ODtyKyspe3ZhciBuPXRbcl0rZVtyXSxvPTY1NTM1Jm4scz1uPj4+MTYsYz0oKG8qbz4+PjE3KStvKnM+Pj4xNSkrcypzLHU9KCg0Mjk0OTAxNzYwJm4pKm58MCkrKCg2NTUzNSZuKSpufDApO2Fbcl09Y151fXRbMF09YVswXSsoYVs3XTw8MTZ8YVs3XT4+PjE2KSsoYVs2XTw8MTZ8YVs2XT4+PjE2KXwwLHRbMV09YVsxXSsoYVswXTw8OHxhWzBdPj4+MjQpK2FbN118MCx0WzJdPWFbMl0rKGFbMV08PDE2fGFbMV0+Pj4xNikrKGFbMF08PDE2fGFbMF0+Pj4xNil8MCx0WzNdPWFbM10rKGFbMl08PDh8YVsyXT4+PjI0KSthWzFdfDAsdFs0XT1hWzRdKyhhWzNdPDwxNnxhWzNdPj4+MTYpKyhhWzJdPDwxNnxhWzJdPj4+MTYpfDAsdFs1XT1hWzVdKyhhWzRdPDw4fGFbNF0+Pj4yNCkrYVszXXwwLHRbNl09YVs2XSsoYVs1XTw8MTZ8YVs1XT4+PjE2KSsoYVs0XTw8MTZ8YVs0XT4+PjE2KXwwLHRbN109YVs3XSsoYVs2XTw8OHxhWzZdPj4+MjQpK2FbNV18MH1lLlJhYmJpdD1yLl9jcmVhdGVIZWxwZXIocyl9KCksdC5SYWJiaXR9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vZW5jLWJhc2U2NCIpLHQoIi4vbWQ1IiksdCgiLi9ldnBrZGYiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyLCIuL2VuYy1iYXNlNjQiOjUzLCIuL2V2cGtkZiI6NTUsIi4vbWQ1Ijo2MH1dLDc0OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LHI9ZS5saWIuU3RyZWFtQ2lwaGVyLG49ZS5hbGdvLG89bi5SQzQ9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2tleSxlPXQud29yZHMscj10LnNpZ0J5dGVzLG49dGhpcy5fUz1bXSxvPTA7bzwyNTY7bysrKW5bb109bztvPTA7Zm9yKHZhciBpPTA7bzwyNTY7bysrKXt2YXIgYT1vJXIscz1lW2E+Pj4yXT4+PjI0LWElNCo4JjI1NTtpPShpK25bb10rcyklMjU2O3ZhciBjPW5bb107bltvXT1uW2ldLG5baV09Y310aGlzLl9pPXRoaXMuX2o9MH0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dFtlXV49aS5jYWxsKHRoaXMpfSxrZXlTaXplOjgsaXZTaXplOjB9KTtmdW5jdGlvbiBpKCl7Zm9yKHZhciB0PXRoaXMuX1MsZT10aGlzLl9pLHI9dGhpcy5faixuPTAsbz0wO288NDtvKyspe3I9KHIrdFtlPShlKzEpJTI1Nl0pJTI1Njt2YXIgaT10W2VdO3RbZV09dFtyXSx0W3JdPWksbnw9dFsodFtlXSt0W3JdKSUyNTZdPDwyNC04Km99cmV0dXJuIHRoaXMuX2k9ZSx0aGlzLl9qPXIsbn1lLlJDND1yLl9jcmVhdGVIZWxwZXIobyk7dmFyIGE9bi5SQzREcm9wPW8uZXh0ZW5kKHtjZmc6by5jZmcuZXh0ZW5kKHtkcm9wOjE5Mn0pLF9kb1Jlc2V0OmZ1bmN0aW9uKCl7by5fZG9SZXNldC5jYWxsKHRoaXMpO2Zvcih2YXIgdD10aGlzLmNmZy5kcm9wO3Q+MDt0LS0paS5jYWxsKHRoaXMpfX0pO2UuUkM0RHJvcD1yLl9jcmVhdGVIZWxwZXIoYSl9KCksdC5SQzR9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vZW5jLWJhc2U2NCIpLHQoIi4vbWQ1IiksdCgiLi9ldnBrZGYiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyLCIuL2VuYy1iYXNlNjQiOjUzLCIuL2V2cGtkZiI6NTUsIi4vbWQ1Ijo2MH1dLDc1OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI9dCxuPXIubGliLG89bi5Xb3JkQXJyYXksaT1uLkhhc2hlcixhPXIuYWxnbyxzPW8uY3JlYXRlKFswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDcsNCwxMywxLDEwLDYsMTUsMywxMiwwLDksNSwyLDE0LDExLDgsMywxMCwxNCw0LDksMTUsOCwxLDIsNywwLDYsMTMsMTEsNSwxMiwxLDksMTEsMTAsMCw4LDEyLDQsMTMsMyw3LDE1LDE0LDUsNiwyLDQsMCw1LDksNywxMiwyLDEwLDE0LDEsMyw4LDExLDYsMTUsMTNdKSxjPW8uY3JlYXRlKFs1LDE0LDcsMCw5LDIsMTEsNCwxMyw2LDE1LDgsMSwxMCwzLDEyLDYsMTEsMyw3LDAsMTMsNSwxMCwxNCwxNSw4LDEyLDQsOSwxLDIsMTUsNSwxLDMsNywxNCw2LDksMTEsOCwxMiwyLDEwLDAsNCwxMyw4LDYsNCwxLDMsMTEsMTUsMCw1LDEyLDIsMTMsOSw3LDEwLDE0LDEyLDE1LDEwLDQsMSw1LDgsNyw2LDIsMTMsMTQsMCwzLDksMTFdKSx1PW8uY3JlYXRlKFsxMSwxNCwxNSwxMiw1LDgsNyw5LDExLDEzLDE0LDE1LDYsNyw5LDgsNyw2LDgsMTMsMTEsOSw3LDE1LDcsMTIsMTUsOSwxMSw3LDEzLDEyLDExLDEzLDYsNywxNCw5LDEzLDE1LDE0LDgsMTMsNiw1LDEyLDcsNSwxMSwxMiwxNCwxNSwxNCwxNSw5LDgsOSwxNCw1LDYsOCw2LDUsMTIsOSwxNSw1LDExLDYsOCwxMywxMiw1LDEyLDEzLDE0LDExLDgsNSw2XSksZj1vLmNyZWF0ZShbOCw5LDksMTEsMTMsMTUsMTUsNSw3LDcsOCwxMSwxNCwxNCwxMiw2LDksMTMsMTUsNywxMiw4LDksMTEsNyw3LDEyLDcsNiwxNSwxMywxMSw5LDcsMTUsMTEsOCw2LDYsMTQsMTIsMTMsNSwxNCwxMywxMyw3LDUsMTUsNSw4LDExLDE0LDE0LDYsMTQsNiw5LDEyLDksMTIsNSwxNSw4LDgsNSwxMiw5LDEyLDUsMTQsNiw4LDEzLDYsNSwxNSwxMywxMSwxMV0pLGw9by5jcmVhdGUoWzAsMTUxODUwMDI0OSwxODU5Nzc1MzkzLDI0MDA5NTk3MDgsMjg0MDg1MzgzOF0pLHA9by5jcmVhdGUoWzEzNTI4Mjk5MjYsMTU0ODYwMzY4NCwxODM2MDcyNjkxLDIwNTM5OTQyMTcsMF0pLGg9YS5SSVBFTUQxNjA9aS5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1vLmNyZWF0ZShbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTA7cjwxNjtyKyspe3ZhciBuPWUrcixvPXRbbl07dFtuXT0xNjcxMTkzNSYobzw8OHxvPj4+MjQpfDQyNzgyNTUzNjAmKG88PDI0fG8+Pj44KX12YXIgaSxhLGgsXyx3LHgsayxCLFMsQSxDLEY9dGhpcy5faGFzaC53b3JkcyxPPWwud29yZHMsST1wLndvcmRzLE49cy53b3JkcyxUPWMud29yZHMsUD11LndvcmRzLEQ9Zi53b3Jkczt4PWk9RlswXSxrPWE9RlsxXSxCPWg9RlsyXSxTPV89RlszXSxBPXc9Rls0XTtmb3Iocj0wO3I8ODA7cis9MSlDPWkrdFtlK05bcl1dfDAsQys9cjwxNj9kKGEsaCxfKStPWzBdOnI8MzI/bShhLGgsXykrT1sxXTpyPDQ4P3koYSxoLF8pK09bMl06cjw2ND9nKGEsaCxfKStPWzNdOnYoYSxoLF8pK09bNF0sQz0oQz1iKEN8PTAsUFtyXSkpK3d8MCxpPXcsdz1fLF89YihoLDEwKSxoPWEsYT1DLEM9eCt0W2UrVFtyXV18MCxDKz1yPDE2P3YoayxCLFMpK0lbMF06cjwzMj9nKGssQixTKStJWzFdOnI8NDg/eShrLEIsUykrSVsyXTpyPDY0P20oayxCLFMpK0lbM106ZChrLEIsUykrSVs0XSxDPShDPWIoQ3w9MCxEW3JdKSkrQXwwLHg9QSxBPVMsUz1iKEIsMTApLEI9ayxrPUM7Qz1GWzFdK2grU3wwLEZbMV09RlsyXStfK0F8MCxGWzJdPUZbM10rdyt4fDAsRlszXT1GWzRdK2kra3wwLEZbNF09RlswXSthK0J8MCxGWzBdPUN9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxlPXQud29yZHMscj04KnRoaXMuX25EYXRhQnl0ZXMsbj04KnQuc2lnQnl0ZXM7ZVtuPj4+NV18PTEyODw8MjQtbiUzMixlWzE0KyhuKzY0Pj4+OTw8NCldPTE2NzExOTM1JihyPDw4fHI+Pj4yNCl8NDI3ODI1NTM2MCYocjw8MjR8cj4+PjgpLHQuc2lnQnl0ZXM9NCooZS5sZW5ndGgrMSksdGhpcy5fcHJvY2VzcygpO2Zvcih2YXIgbz10aGlzLl9oYXNoLGk9by53b3JkcyxhPTA7YTw1O2ErKyl7dmFyIHM9aVthXTtpW2FdPTE2NzExOTM1JihzPDw4fHM+Pj4yNCl8NDI3ODI1NTM2MCYoczw8MjR8cz4+PjgpfXJldHVybiBvfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWkuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTtmdW5jdGlvbiBkKHQsZSxyKXtyZXR1cm4gdF5lXnJ9ZnVuY3Rpb24gbSh0LGUscil7cmV0dXJuIHQmZXx+dCZyfWZ1bmN0aW9uIHkodCxlLHIpe3JldHVybih0fH5lKV5yfWZ1bmN0aW9uIGcodCxlLHIpe3JldHVybiB0JnJ8ZSZ+cn1mdW5jdGlvbiB2KHQsZSxyKXtyZXR1cm4gdF4oZXx+cil9ZnVuY3Rpb24gYih0LGUpe3JldHVybiB0PDxlfHQ+Pj4zMi1lfXIuUklQRU1EMTYwPWkuX2NyZWF0ZUhlbHBlcihoKSxyLkhtYWNSSVBFTUQxNjA9aS5fY3JlYXRlSG1hY0hlbHBlcihoKX0oTWF0aCksdC5SSVBFTUQxNjB9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jb3JlIjo1Mn1dLDc2OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXt2YXIgZSxyLG4sbyxpLGEscztyZXR1cm4gcj0oZT10KS5saWIsbj1yLldvcmRBcnJheSxvPXIuSGFzaGVyLGk9ZS5hbGdvLGE9W10scz1pLlNIQTE9by5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgbi5pbml0KFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzgsMzI4NTM3NzUyMF0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy5faGFzaC53b3JkcyxuPXJbMF0sbz1yWzFdLGk9clsyXSxzPXJbM10sYz1yWzRdLHU9MDt1PDgwO3UrKyl7aWYodTwxNilhW3VdPTB8dFtlK3VdO2Vsc2V7dmFyIGY9YVt1LTNdXmFbdS04XV5hW3UtMTRdXmFbdS0xNl07YVt1XT1mPDwxfGY+Pj4zMX12YXIgbD0objw8NXxuPj4+MjcpK2MrYVt1XTtsKz11PDIwPzE1MTg1MDAyNDkrKG8maXx+byZzKTp1PDQwPzE4NTk3NzUzOTMrKG9eaV5zKTp1PDYwPyhvJml8byZzfGkmcyktMTg5NDAwNzU4ODoob15pXnMpLTg5OTQ5NzUxNCxjPXMscz1pLGk9bzw8MzB8bz4+PjIsbz1uLG49bH1yWzBdPXJbMF0rbnwwLHJbMV09clsxXStvfDAsclsyXT1yWzJdK2l8MCxyWzNdPXJbM10rc3wwLHJbNF09cls0XStjfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxlPXQud29yZHMscj04KnRoaXMuX25EYXRhQnl0ZXMsbj04KnQuc2lnQnl0ZXM7cmV0dXJuIGVbbj4+PjVdfD0xMjg8PDI0LW4lMzIsZVsxNCsobis2ND4+Pjk8PDQpXT1NYXRoLmZsb29yKHIvNDI5NDk2NzI5NiksZVsxNSsobis2ND4+Pjk8PDQpXT1yLHQuc2lnQnl0ZXM9NCplLmxlbmd0aCx0aGlzLl9wcm9jZXNzKCksdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1vLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9fSksZS5TSEExPW8uX2NyZWF0ZUhlbHBlcihzKSxlLkhtYWNTSEExPW8uX2NyZWF0ZUhtYWNIZWxwZXIocyksdC5TSEExfSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY29yZSI6NTJ9XSw3NzpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7dmFyIGUscixuLG8saTtyZXR1cm4gcj0oZT10KS5saWIuV29yZEFycmF5LG49ZS5hbGdvLG89bi5TSEEyNTYsaT1uLlNIQTIyND1vLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyByLmluaXQoWzMyMzgzNzEwMzIsOTE0MTUwNjYzLDgxMjcwMjk5OSw0MTQ0OTEyNjk3LDQyOTA3NzU4NTcsMTc1MDYwMzAyNSwxNjk0MDc2ODM5LDMyMDQwNzU0MjhdKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD1vLl9kb0ZpbmFsaXplLmNhbGwodGhpcyk7cmV0dXJuIHQuc2lnQnl0ZXMtPTQsdH19KSxlLlNIQTIyND1vLl9jcmVhdGVIZWxwZXIoaSksZS5IbWFjU0hBMjI0PW8uX2NyZWF0ZUhtYWNIZWxwZXIoaSksdC5TSEEyMjR9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4vc2hhMjU2IikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9zaGEyNTYiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY29yZSI6NTIsIi4vc2hhMjU2Ijo3OH1dLDc4OltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI9dCxuPXIubGliLG89bi5Xb3JkQXJyYXksaT1uLkhhc2hlcixhPXIuYWxnbyxzPVtdLGM9W107IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtmb3IodmFyIHI9ZS5zcXJ0KHQpLG49MjtuPD1yO24rKylpZighKHQlbikpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gcih0KXtyZXR1cm4gNDI5NDk2NzI5NioodC0oMHx0KSl8MH1mb3IodmFyIG49MixvPTA7bzw2NDspdChuKSYmKG88OCYmKHNbb109cihlLnBvdyhuLC41KSkpLGNbb109cihlLnBvdyhuLDEvMykpLG8rKyksbisrfSgpO3ZhciB1PVtdLGY9YS5TSEEyNTY9aS5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgby5pbml0KHMuc2xpY2UoMCkpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy5faGFzaC53b3JkcyxuPXJbMF0sbz1yWzFdLGk9clsyXSxhPXJbM10scz1yWzRdLGY9cls1XSxsPXJbNl0scD1yWzddLGg9MDtoPDY0O2grKyl7aWYoaDwxNil1W2hdPTB8dFtlK2hdO2Vsc2V7dmFyIGQ9dVtoLTE1XSxtPShkPDwyNXxkPj4+NyleKGQ8PDE0fGQ+Pj4xOCleZD4+PjMseT11W2gtMl0sZz0oeTw8MTV8eT4+PjE3KV4oeTw8MTN8eT4+PjE5KV55Pj4+MTA7dVtoXT1tK3VbaC03XStnK3VbaC0xNl19dmFyIHY9biZvXm4maV5vJmksYj0objw8MzB8bj4+PjIpXihuPDwxOXxuPj4+MTMpXihuPDwxMHxuPj4+MjIpLF89cCsoKHM8PDI2fHM+Pj42KV4oczw8MjF8cz4+PjExKV4oczw8N3xzPj4+MjUpKSsocyZmXn5zJmwpK2NbaF0rdVtoXTtwPWwsbD1mLGY9cyxzPWErX3wwLGE9aSxpPW8sbz1uLG49XysoYit2KXwwfXJbMF09clswXStufDAsclsxXT1yWzFdK298MCxyWzJdPXJbMl0raXwwLHJbM109clszXSthfDAscls0XT1yWzRdK3N8MCxyWzVdPXJbNV0rZnwwLHJbNl09cls2XStsfDAscls3XT1yWzddK3B8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLHI9dC53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxvPTgqdC5zaWdCeXRlcztyZXR1cm4gcltvPj4+NV18PTEyODw8MjQtbyUzMixyWzE0KyhvKzY0Pj4+OTw8NCldPWUuZmxvb3Iobi80Mjk0OTY3Mjk2KSxyWzE1KyhvKzY0Pj4+OTw8NCldPW4sdC5zaWdCeXRlcz00KnIubGVuZ3RoLHRoaXMuX3Byb2Nlc3MoKSx0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWkuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTtyLlNIQTI1Nj1pLl9jcmVhdGVIZWxwZXIoZiksci5IbWFjU0hBMjU2PWkuX2NyZWF0ZUhtYWNIZWxwZXIoZil9KE1hdGgpLHQuU0hBMjU2fSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY29yZSI6NTJ9XSw3OTpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByPXQsbj1yLmxpYixvPW4uV29yZEFycmF5LGk9bi5IYXNoZXIsYT1yLng2NC5Xb3JkLHM9ci5hbGdvLGM9W10sdT1bXSxmPVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD0xLGU9MCxyPTA7cjwyNDtyKyspe2NbdCs1KmVdPShyKzEpKihyKzIpLzIlNjQ7dmFyIG49KDIqdCszKmUpJTU7dD1lJTUsZT1ufWZvcih0PTA7dDw1O3QrKylmb3IoZT0wO2U8NTtlKyspdVt0KzUqZV09ZSsoMip0KzMqZSklNSo1O2Zvcih2YXIgbz0xLGk9MDtpPDI0O2krKyl7Zm9yKHZhciBzPTAsbD0wLHA9MDtwPDc7cCsrKXtpZigxJm8pe3ZhciBoPSgxPDxwKS0xO2g8MzI/bF49MTw8aDpzXj0xPDxoLTMyfTEyOCZvP289bzw8MV4xMTM6bzw8PTF9ZltpXT1hLmNyZWF0ZShzLGwpfX0oKTt2YXIgbD1bXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PDI1O3QrKylsW3RdPWEuY3JlYXRlKCl9KCk7dmFyIHA9cy5TSEEzPWkuZXh0ZW5kKHtjZmc6aS5jZmcuZXh0ZW5kKHtvdXRwdXRMZW5ndGg6NTEyfSksX2RvUmVzZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5fc3RhdGU9W10sZT0wO2U8MjU7ZSsrKXRbZV09bmV3IGEuaW5pdDt0aGlzLmJsb2NrU2l6ZT0oMTYwMC0yKnRoaXMuY2ZnLm91dHB1dExlbmd0aCkvMzJ9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj10aGlzLl9zdGF0ZSxuPXRoaXMuYmxvY2tTaXplLzIsbz0wO288bjtvKyspe3ZhciBpPXRbZSsyKm9dLGE9dFtlKzIqbysxXTtpPTE2NzExOTM1JihpPDw4fGk+Pj4yNCl8NDI3ODI1NTM2MCYoaTw8MjR8aT4+PjgpLGE9MTY3MTE5MzUmKGE8PDh8YT4+PjI0KXw0Mjc4MjU1MzYwJihhPDwyNHxhPj4+OCksKEY9cltvXSkuaGlnaF49YSxGLmxvd149aX1mb3IodmFyIHM9MDtzPDI0O3MrKyl7Zm9yKHZhciBwPTA7cDw1O3ArKyl7Zm9yKHZhciBoPTAsZD0wLG09MDttPDU7bSsrKXtoXj0oRj1yW3ArNSptXSkuaGlnaCxkXj1GLmxvd312YXIgeT1sW3BdO3kuaGlnaD1oLHkubG93PWR9Zm9yKHA9MDtwPDU7cCsrKXt2YXIgZz1sWyhwKzQpJTVdLHY9bFsocCsxKSU1XSxiPXYuaGlnaCxfPXYubG93O2ZvcihoPWcuaGlnaF4oYjw8MXxfPj4+MzEpLGQ9Zy5sb3deKF88PDF8Yj4+PjMxKSxtPTA7bTw1O20rKyl7KEY9cltwKzUqbV0pLmhpZ2hePWgsRi5sb3dePWR9fWZvcih2YXIgdz0xO3c8MjU7dysrKXt2YXIgeD0oRj1yW3ddKS5oaWdoLGs9Ri5sb3csQj1jW3ddO2lmKEI8MzIpaD14PDxCfGs+Pj4zMi1CLGQ9azw8Qnx4Pj4+MzItQjtlbHNlIGg9azw8Qi0zMnx4Pj4+NjQtQixkPXg8PEItMzJ8az4+PjY0LUI7dmFyIFM9bFt1W3ddXTtTLmhpZ2g9aCxTLmxvdz1kfXZhciBBPWxbMF0sQz1yWzBdO0EuaGlnaD1DLmhpZ2gsQS5sb3c9Qy5sb3c7Zm9yKHA9MDtwPDU7cCsrKWZvcihtPTA7bTw1O20rKyl7dmFyIEY9clt3PXArNSptXSxPPWxbd10sST1sWyhwKzEpJTUrNSptXSxOPWxbKHArMiklNSs1Km1dO0YuaGlnaD1PLmhpZ2hefkkuaGlnaCZOLmhpZ2gsRi5sb3c9Ty5sb3defkkubG93Jk4ubG93fUY9clswXTt2YXIgVD1mW3NdO0YuaGlnaF49VC5oaWdoLEYubG93Xj1ULmxvd319LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxyPXQud29yZHMsbj0odGhpcy5fbkRhdGFCeXRlcyw4KnQuc2lnQnl0ZXMpLGk9MzIqdGhpcy5ibG9ja1NpemU7cltuPj4+NV18PTE8PDI0LW4lMzIsclsoZS5jZWlsKChuKzEpL2kpKmk+Pj41KS0xXXw9MTI4LHQuc2lnQnl0ZXM9NCpyLmxlbmd0aCx0aGlzLl9wcm9jZXNzKCk7Zm9yKHZhciBhPXRoaXMuX3N0YXRlLHM9dGhpcy5jZmcub3V0cHV0TGVuZ3RoLzgsYz1zLzgsdT1bXSxmPTA7ZjxjO2YrKyl7dmFyIGw9YVtmXSxwPWwuaGlnaCxoPWwubG93O3A9MTY3MTE5MzUmKHA8PDh8cD4+PjI0KXw0Mjc4MjU1MzYwJihwPDwyNHxwPj4+OCksaD0xNjcxMTkzNSYoaDw8OHxoPj4+MjQpfDQyNzgyNTUzNjAmKGg8PDI0fGg+Pj44KSx1LnB1c2goaCksdS5wdXNoKHApfXJldHVybiBuZXcgby5pbml0KHUscyl9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWkuY2xvbmUuY2FsbCh0aGlzKSxlPXQuX3N0YXRlPXRoaXMuX3N0YXRlLnNsaWNlKDApLHI9MDtyPDI1O3IrKyllW3JdPWVbcl0uY2xvbmUoKTtyZXR1cm4gdH19KTtyLlNIQTM9aS5fY3JlYXRlSGVscGVyKHApLHIuSG1hY1NIQTM9aS5fY3JlYXRlSG1hY0hlbHBlcihwKX0oTWF0aCksdC5TSEEzfSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSx0KCIuL3g2NC1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi94NjQtY29yZSJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jb3JlIjo1MiwiLi94NjQtY29yZSI6ODN9XSw4MDpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7dmFyIGUscixuLG8saSxhLHM7cmV0dXJuIHI9KGU9dCkueDY0LG49ci5Xb3JkLG89ci5Xb3JkQXJyYXksaT1lLmFsZ28sYT1pLlNIQTUxMixzPWkuU0hBMzg0PWEuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IG8uaW5pdChbbmV3IG4uaW5pdCgzNDE4MDcwMzY1LDMyMzgzNzEwMzIpLG5ldyBuLmluaXQoMTY1NDI3MDI1MCw5MTQxNTA2NjMpLG5ldyBuLmluaXQoMjQzODUyOTM3MCw4MTI3MDI5OTkpLG5ldyBuLmluaXQoMzU1NDYyMzYwLDQxNDQ5MTI2OTcpLG5ldyBuLmluaXQoMTczMTQwNTQxNSw0MjkwNzc1ODU3KSxuZXcgbi5pbml0KDIzOTQxODAyMzEsMTc1MDYwMzAyNSksbmV3IG4uaW5pdCgzNjc1MDA4NTI1LDE2OTQwNzY4MzkpLG5ldyBuLmluaXQoMTIwMzA2MjgxMywzMjA0MDc1NDI4KV0pfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PWEuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtyZXR1cm4gdC5zaWdCeXRlcy09MTYsdH19KSxlLlNIQTM4ND1hLl9jcmVhdGVIZWxwZXIocyksZS5IbWFjU0hBMzg0PWEuX2NyZWF0ZUhtYWNIZWxwZXIocyksdC5TSEEzODR9LCJvYmplY3QiPT10eXBlb2Ygcj9lLmV4cG9ydHM9cj1vKHQoIi4vY29yZSIpLHQoIi4veDY0LWNvcmUiKSx0KCIuL3NoYTUxMiIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4veDY0LWNvcmUiLCIuL3NoYTUxMiJdLG8pOm8obi5DcnlwdG9KUyl9LHsiLi9jb3JlIjo1MiwiLi9zaGE1MTIiOjgxLCIuL3g2NC1jb3JlIjo4M31dLDgxOltmdW5jdGlvbih0LGUscil7dmFyIG4sbztuPXRoaXMsbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LHI9ZS5saWIuSGFzaGVyLG49ZS54NjQsbz1uLldvcmQsaT1uLldvcmRBcnJheSxhPWUuYWxnbztmdW5jdGlvbiBzKCl7cmV0dXJuIG8uY3JlYXRlLmFwcGx5KG8sYXJndW1lbnRzKX12YXIgYz1bcygxMTE2MzUyNDA4LDM2MDk3Njc0NTgpLHMoMTg5OTQ0NzQ0MSw2MDI4OTE3MjUpLHMoMzA0OTMyMzQ3MSwzOTY0NDg0Mzk5KSxzKDM5MjEwMDk1NzMsMjE3MzI5NTU0OCkscyg5NjE5ODcxNjMsNDA4MTYyODQ3MikscygxNTA4OTcwOTkzLDMwNTM4MzQyNjUpLHMoMjQ1MzYzNTc0OCwyOTM3NjcxNTc5KSxzKDI4NzA3NjMyMjEsMzY2NDYwOTU2MCkscygzNjI0MzgxMDgwLDI3MzQ4ODMzOTQpLHMoMzEwNTk4NDAxLDExNjQ5OTY1NDIpLHMoNjA3MjI1Mjc4LDEzMjM2MTA3NjQpLHMoMTQyNjg4MTk4NywzNTkwMzA0OTk0KSxzKDE5MjUwNzgzODgsNDA2ODE4MjM4MykscygyMTYyMDc4MjA2LDk5MTMzNjExMykscygyNjE0ODg4MTAzLDYzMzgwMzMxNykscygzMjQ4MjIyNTgwLDM0Nzk3NzQ4NjgpLHMoMzgzNTM5MDQwMSwyNjY2NjEzNDU4KSxzKDQwMjIyMjQ3NzQsOTQ0NzExMTM5KSxzKDI2NDM0NzA3OCwyMzQxMjYyNzczKSxzKDYwNDgwNzYyOCwyMDA3ODAwOTMzKSxzKDc3MDI1NTk4MywxNDk1OTkwOTAxKSxzKDEyNDkxNTAxMjIsMTg1NjQzMTIzNSkscygxNTU1MDgxNjkyLDMxNzUyMTgxMzIpLHMoMTk5NjA2NDk4NiwyMTk4OTUwODM3KSxzKDI1NTQyMjA4ODIsMzk5OTcxOTMzOSkscygyODIxODM0MzQ5LDc2Njc4NDAxNikscygyOTUyOTk2ODA4LDI1NjY1OTQ4NzkpLHMoMzIxMDMxMzY3MSwzMjAzMzM3OTU2KSxzKDMzMzY1NzE4OTEsMTAzNDQ1NzAyNikscygzNTg0NTI4NzExLDI0NjY5NDg5MDEpLHMoMTEzOTI2OTkzLDM3NTgzMjYzODMpLHMoMzM4MjQxODk1LDE2ODcxNzkzNikscyg2NjYzMDcyMDUsMTE4ODE3OTk2NCkscyg3NzM1Mjk5MTIsMTU0NjA0NTczNCkscygxMjk0NzU3MzcyLDE1MjI4MDU0ODUpLHMoMTM5NjE4MjI5MSwyNjQzODMzODIzKSxzKDE2OTUxODM3MDAsMjM0MzUyNzM5MCkscygxOTg2NjYxMDUxLDEwMTQ0Nzc0ODApLHMoMjE3NzAyNjM1MCwxMjA2NzU5MTQyKSxzKDI0NTY5NTYwMzcsMzQ0MDc3NjI3KSxzKDI3MzA0ODU5MjEsMTI5MDg2MzQ2MCkscygyODIwMzAyNDExLDMxNTg0NTQyNzMpLHMoMzI1OTczMDgwMCwzNTA1OTUyNjU3KSxzKDMzNDU3NjQ3NzEsMTA2MjE3MDA4KSxzKDM1MTYwNjU4MTcsMzYwNjAwODM0NCkscygzNjAwMzUyODA0LDE0MzI3MjU3NzYpLHMoNDA5NDU3MTkwOSwxNDY3MDMxNTk0KSxzKDI3NTQyMzM0NCw4NTExNjk3MjApLHMoNDMwMjI3NzM0LDMxMDA4MjM3NTIpLHMoNTA2OTQ4NjE2LDEzNjMyNTgxOTUpLHMoNjU5MDYwNTU2LDM3NTA2ODU1OTMpLHMoODgzOTk3ODc3LDM3ODUwNTAyODApLHMoOTU4MTM5NTcxLDMzMTgzMDc0MjcpLHMoMTMyMjgyMjIxOCwzODEyNzIzNDAzKSxzKDE1MzcwMDIwNjMsMjAwMzAzNDk5NSkscygxNzQ3ODczNzc5LDM2MDIwMzY4OTkpLHMoMTk1NTU2MjIyMiwxNTc1OTkwMDEyKSxzKDIwMjQxMDQ4MTUsMTEyNTU5MjkyOCkscygyMjI3NzMwNDUyLDI3MTY5MDQzMDYpLHMoMjM2MTg1MjQyNCw0NDI3NzYwNDQpLHMoMjQyODQzNjQ3NCw1OTM2OTgzNDQpLHMoMjc1NjczNDE4NywzNzMzMTEwMjQ5KSxzKDMyMDQwMzE0NzksMjk5OTM1MTU3MykscygzMzI5MzI1Mjk4LDM4MTU5MjA0MjcpLHMoMzM5MTU2OTYxNCwzOTI4MzgzOTAwKSxzKDM1MTUyNjcyNzEsNTY2MjgwNzExKSxzKDM5NDAxODc2MDYsMzQ1NDA2OTUzNCkscyg0MTE4NjMwMjcxLDQwMDAyMzk5OTIpLHMoMTE2NDE4NDc0LDE5MTQxMzg1NTQpLHMoMTc0MjkyNDIxLDI3MzEwNTUyNzApLHMoMjg5MzgwMzU2LDMyMDM5OTMwMDYpLHMoNDYwMzkzMjY5LDMyMDYyMDMxNSkscyg2ODU0NzE3MzMsNTg3NDk2ODM2KSxzKDg1MjE0Mjk3MSwxMDg2NzkyODUxKSxzKDEwMTcwMzYyOTgsMzY1NTQzMTAwKSxzKDExMjYwMDA1ODAsMjYxODI5NzY3NikscygxMjg4MDMzNDcwLDM0MDk4NTUxNTgpLHMoMTUwMTUwNTk0OCw0MjM0NTA5ODY2KSxzKDE2MDcxNjc5MTUsOTg3MTY3NDY4KSxzKDE4MTY0MDIzMTYsMTI0NjE4OTU5MSldLHU9W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDw4MDt0KyspdVt0XT1zKCl9KCk7dmFyIGY9YS5TSEE1MTI9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgaS5pbml0KFtuZXcgby5pbml0KDE3NzkwMzM3MDMsNDA4OTIzNTcyMCksbmV3IG8uaW5pdCgzMTQ0MTM0Mjc3LDIyMjc4NzM1OTUpLG5ldyBvLmluaXQoMTAxMzkwNDI0Miw0MjcxMTc1NzIzKSxuZXcgby5pbml0KDI3NzM0ODA3NjIsMTU5NTc1MDEyOSksbmV3IG8uaW5pdCgxMzU5ODkzMTE5LDI5MTc1NjUxMzcpLG5ldyBvLmluaXQoMjYwMDgyMjkyNCw3MjU1MTExOTkpLG5ldyBvLmluaXQoNTI4NzM0NjM1LDQyMTUzODk1NDcpLG5ldyBvLmluaXQoMTU0MTQ1OTIyNSwzMjcwMzMyMDkpXSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj10aGlzLl9oYXNoLndvcmRzLG49clswXSxvPXJbMV0saT1yWzJdLGE9clszXSxzPXJbNF0sZj1yWzVdLGw9cls2XSxwPXJbN10saD1uLmhpZ2gsZD1uLmxvdyxtPW8uaGlnaCx5PW8ubG93LGc9aS5oaWdoLHY9aS5sb3csYj1hLmhpZ2gsXz1hLmxvdyx3PXMuaGlnaCx4PXMubG93LGs9Zi5oaWdoLEI9Zi5sb3csUz1sLmhpZ2gsQT1sLmxvdyxDPXAuaGlnaCxGPXAubG93LE89aCxJPWQsTj1tLFQ9eSxQPWcsRD12LFI9YixFPV8sTT13LEg9eCxqPWsscT1CLHo9UyxMPUEsVT1DLFc9RixKPTA7Sjw4MDtKKyspe3ZhciBLPXVbSl07aWYoSjwxNil2YXIgRz1LLmhpZ2g9MHx0W2UrMipKXSxYPUsubG93PTB8dFtlKzIqSisxXTtlbHNle3ZhciAkPXVbSi0xNV0sVj0kLmhpZ2gsWj0kLmxvdyxZPShWPj4+MXxaPDwzMSleKFY+Pj44fFo8PDI0KV5WPj4+NyxRPShaPj4+MXxWPDwzMSleKFo+Pj44fFY8PDI0KV4oWj4+Pjd8Vjw8MjUpLHR0PXVbSi0yXSxldD10dC5oaWdoLHJ0PXR0LmxvdyxudD0oZXQ+Pj4xOXxydDw8MTMpXihldDw8M3xydD4+PjI5KV5ldD4+PjYsb3Q9KHJ0Pj4+MTl8ZXQ8PDEzKV4ocnQ8PDN8ZXQ+Pj4yOSleKHJ0Pj4+NnxldDw8MjYpLGl0PXVbSi03XSxhdD1pdC5oaWdoLHN0PWl0LmxvdyxjdD11W0otMTZdLHV0PWN0LmhpZ2gsZnQ9Y3QubG93O0c9KEc9KEc9WSthdCsoKFg9UStzdCk+Pj4wPFE+Pj4wPzE6MCkpK250KygoWD1YK290KT4+PjA8b3Q+Pj4wPzE6MCkpK3V0KygoWD1YK2Z0KT4+PjA8ZnQ+Pj4wPzE6MCk7Sy5oaWdoPUcsSy5sb3c9WH12YXIgbHQscHQ9TSZqXn5NJnosaHQ9SCZxXn5IJkwsZHQ9TyZOXk8mUF5OJlAsbXQ9SSZUXkkmRF5UJkQseXQ9KE8+Pj4yOHxJPDw0KV4oTzw8MzB8ST4+PjIpXihPPDwyNXxJPj4+NyksZ3Q9KEk+Pj4yOHxPPDw0KV4oSTw8MzB8Tz4+PjIpXihJPDwyNXxPPj4+NyksdnQ9KE0+Pj4xNHxIPDwxOCleKE0+Pj4xOHxIPDwxNCleKE08PDIzfEg+Pj45KSxidD0oSD4+PjE0fE08PDE4KV4oSD4+PjE4fE08PDE0KV4oSDw8MjN8TT4+PjkpLF90PWNbSl0sd3Q9X3QuaGlnaCx4dD1fdC5sb3csa3Q9VSt2dCsoKGx0PVcrYnQpPj4+MDxXPj4+MD8xOjApLEJ0PWd0K210O1U9eixXPUwsej1qLEw9cSxqPU0scT1ILE09Uisoa3Q9KGt0PShrdD1rdCtwdCsoKGx0PWx0K2h0KT4+PjA8aHQ+Pj4wPzE6MCkpK3d0KygobHQ9bHQreHQpPj4+MDx4dD4+PjA/MTowKSkrRysoKGx0PWx0K1gpPj4+MDxYPj4+MD8xOjApKSsoKEg9RStsdHwwKT4+PjA8RT4+PjA/MTowKXwwLFI9UCxFPUQsUD1OLEQ9VCxOPU8sVD1JLE89a3QrKHl0K2R0KyhCdD4+PjA8Z3Q+Pj4wPzE6MCkpKygoST1sdCtCdHwwKT4+PjA8bHQ+Pj4wPzE6MCl8MH1kPW4ubG93PWQrSSxuLmhpZ2g9aCtPKyhkPj4+MDxJPj4+MD8xOjApLHk9by5sb3c9eStULG8uaGlnaD1tK04rKHk+Pj4wPFQ+Pj4wPzE6MCksdj1pLmxvdz12K0QsaS5oaWdoPWcrUCsodj4+PjA8RD4+PjA/MTowKSxfPWEubG93PV8rRSxhLmhpZ2g9YitSKyhfPj4+MDxFPj4+MD8xOjApLHg9cy5sb3c9eCtILHMuaGlnaD13K00rKHg+Pj4wPEg+Pj4wPzE6MCksQj1mLmxvdz1CK3EsZi5oaWdoPWsraisoQj4+PjA8cT4+PjA/MTowKSxBPWwubG93PUErTCxsLmhpZ2g9Uyt6KyhBPj4+MDxMPj4+MD8xOjApLEY9cC5sb3c9RitXLHAuaGlnaD1DK1UrKEY+Pj4wPFc+Pj4wPzE6MCl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxlPXQud29yZHMscj04KnRoaXMuX25EYXRhQnl0ZXMsbj04KnQuc2lnQnl0ZXM7cmV0dXJuIGVbbj4+PjVdfD0xMjg8PDI0LW4lMzIsZVszMCsobisxMjg+Pj4xMDw8NSldPU1hdGguZmxvb3Ioci80Mjk0OTY3Mjk2KSxlWzMxKyhuKzEyOD4+PjEwPDw1KV09cix0LnNpZ0J5dGVzPTQqZS5sZW5ndGgsdGhpcy5fcHJvY2VzcygpLHRoaXMuX2hhc2gudG9YMzIoKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1yLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9LGJsb2NrU2l6ZTozMn0pO2UuU0hBNTEyPXIuX2NyZWF0ZUhlbHBlcihmKSxlLkhtYWNTSEE1MTI9ci5fY3JlYXRlSG1hY0hlbHBlcihmKX0oKSx0LlNIQTUxMn0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIiksdCgiLi94NjQtY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4veDY0LWNvcmUiXSxvKTpvKG4uQ3J5cHRvSlMpfSx7Ii4vY29yZSI6NTIsIi4veDY0LWNvcmUiOjgzfV0sODI6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbixvO249dGhpcyxvPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQscj1lLmxpYixuPXIuV29yZEFycmF5LG89ci5CbG9ja0NpcGhlcixpPWUuYWxnbyxhPVs1Nyw0OSw0MSwzMywyNSwxNyw5LDEsNTgsNTAsNDIsMzQsMjYsMTgsMTAsMiw1OSw1MSw0MywzNSwyNywxOSwxMSwzLDYwLDUyLDQ0LDM2LDYzLDU1LDQ3LDM5LDMxLDIzLDE1LDcsNjIsNTQsNDYsMzgsMzAsMjIsMTQsNiw2MSw1Myw0NSwzNywyOSwyMSwxMyw1LDI4LDIwLDEyLDRdLHM9WzE0LDE3LDExLDI0LDEsNSwzLDI4LDE1LDYsMjEsMTAsMjMsMTksMTIsNCwyNiw4LDE2LDcsMjcsMjAsMTMsMiw0MSw1MiwzMSwzNyw0Nyw1NSwzMCw0MCw1MSw0NSwzMyw0OCw0NCw0OSwzOSw1NiwzNCw1Myw0Niw0Miw1MCwzNiwyOSwzMl0sYz1bMSwyLDQsNiw4LDEwLDEyLDE0LDE1LDE3LDE5LDIxLDIzLDI1LDI3LDI4XSx1PVt7MDo4NDIxODg4LDI2ODQzNTQ1NjozMjc2OCw1MzY4NzA5MTI6ODQyMTM3OCw4MDUzMDYzNjg6MiwxMDczNzQxODI0OjUxMiwxMzQyMTc3MjgwOjg0MjE4OTAsMTYxMDYxMjczNjo4Mzg5MTIyLDE4NzkwNDgxOTI6ODM4ODYwOCwyMTQ3NDgzNjQ4OjUxNCwyNDE1OTE5MTA0OjgzODkxMjAsMjY4NDM1NDU2MDozMzI4MCwyOTUyNzkwMDE2Ojg0MjEzNzYsMzIyMTIyNTQ3MjozMjc3MCwzNDg5NjYwOTI4OjgzODg2MTAsMzc1ODA5NjM4NDowLDQwMjY1MzE4NDA6MzMyODIsMTM0MjE3NzI4OjAsNDAyNjUzMTg0Ojg0MjE4OTAsNjcxMDg4NjQwOjMzMjgyLDkzOTUyNDA5NjozMjc2OCwxMjA3OTU5NTUyOjg0MjE4ODgsMTQ3NjM5NTAwODo1MTIsMTc0NDgzMDQ2NDo4NDIxMzc4LDIwMTMyNjU5MjA6MiwyMjgxNzAxMzc2OjgzODkxMjAsMjU1MDEzNjgzMjozMzI4MCwyODE4NTcyMjg4Ojg0MjEzNzYsMzA4NzAwNzc0NDo4Mzg5MTIyLDMzNTU0NDMyMDA6ODM4ODYxMCwzNjIzODc4NjU2OjMyNzcwLDM4OTIzMTQxMTI6NTE0LDQxNjA3NDk1Njg6ODM4ODYwOCwxOjMyNzY4LDI2ODQzNTQ1NzoyLDUzNjg3MDkxMzo4NDIxODg4LDgwNTMwNjM2OTo4Mzg4NjA4LDEwNzM3NDE4MjU6ODQyMTM3OCwxMzQyMTc3MjgxOjMzMjgwLDE2MTA2MTI3Mzc6NTEyLDE4NzkwNDgxOTM6ODM4OTEyMiwyMTQ3NDgzNjQ5Ojg0MjE4OTAsMjQxNTkxOTEwNTo4NDIxMzc2LDI2ODQzNTQ1NjE6ODM4ODYxMCwyOTUyNzkwMDE3OjMzMjgyLDMyMjEyMjU0NzM6NTE0LDM0ODk2NjA5Mjk6ODM4OTEyMCwzNzU4MDk2Mzg1OjMyNzcwLDQwMjY1MzE4NDE6MCwxMzQyMTc3Mjk6ODQyMTg5MCw0MDI2NTMxODU6ODQyMTM3Niw2NzEwODg2NDE6ODM4ODYwOCw5Mzk1MjQwOTc6NTEyLDEyMDc5NTk1NTM6MzI3NjgsMTQ3NjM5NTAwOTo4Mzg4NjEwLDE3NDQ4MzA0NjU6MiwyMDEzMjY1OTIxOjMzMjgyLDIyODE3MDEzNzc6MzI3NzAsMjU1MDEzNjgzMzo4Mzg5MTIyLDI4MTg1NzIyODk6NTE0LDMwODcwMDc3NDU6ODQyMTg4OCwzMzU1NDQzMjAxOjgzODkxMjAsMzYyMzg3ODY1NzowLDM4OTIzMTQxMTM6MzMyODAsNDE2MDc0OTU2OTo4NDIxMzc4fSx7MDoxMDc0MjgyNTEyLDE2Nzc3MjE2OjE2Mzg0LDMzNTU0NDMyOjUyNDI4OCw1MDMzMTY0ODoxMDc0MjY2MTI4LDY3MTA4ODY0OjEwNzM3NDE4NDAsODM4ODYwODA6MTA3NDI4MjQ5NiwxMDA2NjMyOTY6MTA3Mzc1ODIwOCwxMTc0NDA1MTI6MTYsMTM0MjE3NzI4OjU0MDY3MiwxNTA5OTQ5NDQ6MTA3Mzc1ODIyNCwxNjc3NzIxNjA6MTA3Mzc0MTgyNCwxODQ1NDkzNzY6NTQwNjg4LDIwMTMyNjU5Mjo1MjQzMDQsMjE4MTAzODA4OjAsMjM0ODgxMDI0OjE2NDAwLDI1MTY1ODI0MDoxMDc0MjY2MTEyLDgzODg2MDg6MTA3Mzc1ODIwOCwyNTE2NTgyNDo1NDA2ODgsNDE5NDMwNDA6MTYsNTg3MjAyNTY6MTA3Mzc1ODIyNCw3NTQ5NzQ3MjoxMDc0MjgyNTEyLDkyMjc0Njg4OjEwNzM3NDE4MjQsMTA5MDUxOTA0OjUyNDI4OCwxMjU4MjkxMjA6MTA3NDI2NjEyOCwxNDI2MDYzMzY6NTI0MzA0LDE1OTM4MzU1MjowLDE3NjE2MDc2ODoxNjM4NCwxOTI5Mzc5ODQ6MTA3NDI2NjExMiwyMDk3MTUyMDA6MTA3Mzc0MTg0MCwyMjY0OTI0MTY6NTQwNjcyLDI0MzI2OTYzMjoxMDc0MjgyNDk2LDI2MDA0Njg0ODoxNjQwMCwyNjg0MzU0NTY6MCwyODUyMTI2NzI6MTA3NDI2NjEyOCwzMDE5ODk4ODg6MTA3Mzc1ODIyNCwzMTg3NjcxMDQ6MTA3NDI4MjQ5NiwzMzU1NDQzMjA6MTA3NDI2NjExMiwzNTIzMjE1MzY6MTYsMzY5MDk4NzUyOjU0MDY4OCwzODU4NzU5Njg6MTYzODQsNDAyNjUzMTg0OjE2NDAwLDQxOTQzMDQwMDo1MjQyODgsNDM2MjA3NjE2OjUyNDMwNCw0NTI5ODQ4MzI6MTA3Mzc0MTg0MCw0Njk3NjIwNDg6NTQwNjcyLDQ4NjUzOTI2NDoxMDczNzU4MjA4LDUwMzMxNjQ4MDoxMDczNzQxODI0LDUyMDA5MzY5NjoxMDc0MjgyNTEyLDI3NjgyNDA2NDo1NDA2ODgsMjkzNjAxMjgwOjUyNDI4OCwzMTAzNzg0OTY6MTA3NDI2NjExMiwzMjcxNTU3MTI6MTYzODQsMzQzOTMyOTI4OjEwNzM3NTgyMDgsMzYwNzEwMTQ0OjEwNzQyODI1MTIsMzc3NDg3MzYwOjE2LDM5NDI2NDU3NjoxMDczNzQxODI0LDQxMTA0MTc5MjoxMDc0MjgyNDk2LDQyNzgxOTAwODoxMDczNzQxODQwLDQ0NDU5NjIyNDoxMDczNzU4MjI0LDQ2MTM3MzQ0MDo1MjQzMDQsNDc4MTUwNjU2OjAsNDk0OTI3ODcyOjE2NDAwLDUxMTcwNTA4ODoxMDc0MjY2MTI4LDUyODQ4MjMwNDo1NDA2NzJ9LHswOjI2MCwxMDQ4NTc2OjAsMjA5NzE1Mjo2NzEwOTEyMCwzMTQ1NzI4OjY1Nzk2LDQxOTQzMDQ6NjU1NDAsNTI0Mjg4MDo2NzEwODg2OCw2MjkxNDU2OjY3MTc0NjYwLDczNDAwMzI6NjcxNzQ0MDAsODM4ODYwODo2NzEwODg2NCw5NDM3MTg0OjY3MTc0NjU2LDEwNDg1NzYwOjY1NzkyLDExNTM0MzM2OjY3MTc0NDA0LDEyNTgyOTEyOjY3MTA5MTI0LDEzNjMxNDg4OjY1NTM2LDE0NjgwMDY0OjQsMTU3Mjg2NDA6MjU2LDUyNDI4ODo2NzE3NDY1NiwxNTcyODY0OjY3MTc0NDA0LDI2MjE0NDA6MCwzNjcwMDE2OjY3MTA5MTIwLDQ3MTg1OTI6NjcxMDg4NjgsNTc2NzE2ODo2NTUzNiw2ODE1NzQ0OjY1NTQwLDc4NjQzMjA6MjYwLDg5MTI4OTY6NCw5OTYxNDcyOjI1NiwxMTAxMDA0ODo2NzE3NDQwMCwxMjA1ODYyNDo2NTc5NiwxMzEwNzIwMDo2NTc5MiwxNDE1NTc3Njo2NzEwOTEyNCwxNTIwNDM1Mjo2NzE3NDY2MCwxNjI1MjkyODo2NzEwODg2NCwxNjc3NzIxNjo2NzE3NDY1NiwxNzgyNTc5Mjo2NTU0MCwxODg3NDM2ODo2NTUzNiwxOTkyMjk0NDo2NzEwOTEyMCwyMDk3MTUyMDoyNTYsMjIwMjAwOTY6NjcxNzQ2NjAsMjMwNjg2NzI6NjcxMDg4NjgsMjQxMTcyNDg6MCwyNTE2NTgyNDo2NzEwOTEyNCwyNjIxNDQwMDo2NzEwODg2NCwyNzI2Mjk3Njo0LDI4MzExNTUyOjY1NzkyLDI5MzYwMTI4OjY3MTc0NDAwLDMwNDA4NzA0OjI2MCwzMTQ1NzI4MDo2NTc5NiwzMjUwNTg1Njo2NzE3NDQwNCwxNzMwMTUwNDo2NzEwODg2NCwxODM1MDA4MDoyNjAsMTkzOTg2NTY6NjcxNzQ2NTYsMjA0NDcyMzI6MCwyMTQ5NTgwODo2NTU0MCwyMjU0NDM4NDo2NzEwOTEyMCwyMzU5Mjk2MDoyNTYsMjQ2NDE1MzY6NjcxNzQ0MDQsMjU2OTAxMTI6NjU1MzYsMjY3Mzg2ODg6NjcxNzQ2NjAsMjc3ODcyNjQ6NjU3OTYsMjg4MzU4NDA6NjcxMDg4NjgsMjk4ODQ0MTY6NjcxMDkxMjQsMzA5MzI5OTI6NjcxNzQ0MDAsMzE5ODE1Njg6NCwzMzAzMDE0NDo2NTc5Mn0sezA6MjE1MTY4MjA0OCw2NTUzNjoyMTQ3NDg3ODA4LDEzMTA3Mjo0MTk4NDY0LDE5NjYwODoyMTUxNjc3OTUyLDI2MjE0NDowLDMyNzY4MDo0MTk4NDAwLDM5MzIxNjoyMTQ3NDgzNzEyLDQ1ODc1Mjo0MTk0MzY4LDUyNDI4ODoyMTQ3NDgzNjQ4LDU4OTgyNDo0MTk0MzA0LDY1NTM2MDo2NCw3MjA4OTY6MjE0NzQ4Nzc0NCw3ODY0MzI6MjE1MTY3ODAxNiw4NTE5Njg6NDE2MCw5MTc1MDQ6NDA5Niw5ODMwNDA6MjE1MTY4MjExMiwzMjc2ODoyMTQ3NDg3ODA4LDk4MzA0OjY0LDE2Mzg0MDoyMTUxNjc4MDE2LDIyOTM3NjoyMTQ3NDg3NzQ0LDI5NDkxMjo0MTk4NDAwLDM2MDQ0ODoyMTUxNjgyMTEyLDQyNTk4NDowLDQ5MTUyMDoyMTUxNjc3OTUyLDU1NzA1Njo0MDk2LDYyMjU5MjoyMTUxNjgyMDQ4LDY4ODEyODo0MTk0MzA0LDc1MzY2NDo0MTYwLDgxOTIwMDoyMTQ3NDgzNjQ4LDg4NDczNjo0MTk0MzY4LDk1MDI3Mjo0MTk4NDY0LDEwMTU4MDg6MjE0NzQ4MzcxMiwxMDQ4NTc2OjQxOTQzNjgsMTExNDExMjo0MTk4NDAwLDExNzk2NDg6MjE0NzQ4MzcxMiwxMjQ1MTg0OjAsMTMxMDcyMDo0MTYwLDEzNzYyNTY6MjE1MTY3ODAxNiwxNDQxNzkyOjIxNTE2ODIwNDgsMTUwNzMyODoyMTQ3NDg3ODA4LDE1NzI4NjQ6MjE1MTY4MjExMiwxNjM4NDAwOjIxNDc0ODM2NDgsMTcwMzkzNjoyMTUxNjc3OTUyLDE3Njk0NzI6NDE5ODQ2NCwxODM1MDA4OjIxNDc0ODc3NDQsMTkwMDU0NDo0MTk0MzA0LDE5NjYwODA6NjQsMjAzMTYxNjo0MDk2LDEwODEzNDQ6MjE1MTY3Nzk1MiwxMTQ2ODgwOjIxNTE2ODIxMTIsMTIxMjQxNjowLDEyNzc5NTI6NDE5ODQwMCwxMzQzNDg4OjQxOTQzNjgsMTQwOTAyNDoyMTQ3NDgzNjQ4LDE0NzQ1NjA6MjE0NzQ4NzgwOCwxNTQwMDk2OjY0LDE2MDU2MzI6MjE0NzQ4MzcxMiwxNjcxMTY4OjQwOTYsMTczNjcwNDoyMTQ3NDg3NzQ0LDE4MDIyNDA6MjE1MTY3ODAxNiwxODY3Nzc2OjQxNjAsMTkzMzMxMjoyMTUxNjgyMDQ4LDE5OTg4NDg6NDE5NDMwNCwyMDY0Mzg0OjQxOTg0NjR9LHswOjEyOCw0MDk2OjE3MDM5MzYwLDgxOTI6MjYyMTQ0LDEyMjg4OjUzNjg3MDkxMiwxNjM4NDo1MzcxMzMxODQsMjA0ODA6MTY3NzczNDQsMjQ1NzY6NTUzNjQ4MjU2LDI4NjcyOjI2MjI3MiwzMjc2ODoxNjc3NzIxNiwzNjg2NDo1MzcxMzMwNTYsNDA5NjA6NTM2ODcxMDQwLDQ1MDU2OjU1MzkxMDQwMCw0OTE1Mjo1NTM5MTAyNzIsNTMyNDg6MCw1NzM0NDoxNzAzOTQ4OCw2MTQ0MDo1NTM2NDgxMjgsMjA0ODoxNzAzOTQ4OCw2MTQ0OjU1MzY0ODI1NiwxMDI0MDoxMjgsMTQzMzY6MTcwMzkzNjAsMTg0MzI6MjYyMTQ0LDIyNTI4OjUzNzEzMzE4NCwyNjYyNDo1NTM5MTAyNzIsMzA3MjA6NTM2ODcwOTEyLDM0ODE2OjUzNzEzMzA1NiwzODkxMjowLDQzMDA4OjU1MzkxMDQwMCw0NzEwNDoxNjc3NzM0NCw1MTIwMDo1MzY4NzEwNDAsNTUyOTY6NTUzNjQ4MTI4LDU5MzkyOjE2Nzc3MjE2LDYzNDg4OjI2MjI3Miw2NTUzNjoyNjIxNDQsNjk2MzI6MTI4LDczNzI4OjUzNjg3MDkxMiw3NzgyNDo1NTM2NDgyNTYsODE5MjA6MTY3NzczNDQsODYwMTY6NTUzOTEwMjcyLDkwMTEyOjUzNzEzMzE4NCw5NDIwODoxNjc3NzIxNiw5ODMwNDo1NTM5MTA0MDAsMTAyNDAwOjU1MzY0ODEyOCwxMDY0OTY6MTcwMzkzNjAsMTEwNTkyOjUzNzEzMzA1NiwxMTQ2ODg6MjYyMjcyLDExODc4NDo1MzY4NzEwNDAsMTIyODgwOjAsMTI2OTc2OjE3MDM5NDg4LDY3NTg0OjU1MzY0ODI1Niw3MTY4MDoxNjc3NzIxNiw3NTc3NjoxNzAzOTM2MCw3OTg3Mjo1MzcxMzMxODQsODM5Njg6NTM2ODcwOTEyLDg4MDY0OjE3MDM5NDg4LDkyMTYwOjEyOCw5NjI1Njo1NTM5MTAyNzIsMTAwMzUyOjI2MjI3MiwxMDQ0NDg6NTUzOTEwNDAwLDEwODU0NDowLDExMjY0MDo1NTM2NDgxMjgsMTE2NzM2OjE2Nzc3MzQ0LDEyMDgzMjoyNjIxNDQsMTI0OTI4OjUzNzEzMzA1NiwxMjkwMjQ6NTM2ODcxMDQwfSx7MDoyNjg0MzU0NjQsMjU2OjgxOTIsNTEyOjI3MDUzMjYwOCw3Njg6MjcwNTQwODA4LDEwMjQ6MjY4NDQzNjQ4LDEyODA6MjA5NzE1MiwxNTM2OjIwOTcxNjAsMTc5MjoyNjg0MzU0NTYsMjA0ODowLDIzMDQ6MjY4NDQzNjU2LDI1NjA6MjEwNTM0NCwyODE2OjgsMzA3MjoyNzA1MzI2MTYsMzMyODoyMTA1MzUyLDM1ODQ6ODIwMCwzODQwOjI3MDU0MDgwMCwxMjg6MjcwNTMyNjA4LDM4NDoyNzA1NDA4MDgsNjQwOjgsODk2OjIwOTcxNTIsMTE1MjoyMTA1MzUyLDE0MDg6MjY4NDM1NDY0LDE2NjQ6MjY4NDQzNjQ4LDE5MjA6ODIwMCwyMTc2OjIwOTcxNjAsMjQzMjo4MTkyLDI2ODg6MjY4NDQzNjU2LDI5NDQ6MjcwNTMyNjE2LDMyMDA6MCwzNDU2OjI3MDU0MDgwMCwzNzEyOjIxMDUzNDQsMzk2ODoyNjg0MzU0NTYsNDA5NjoyNjg0NDM2NDgsNDM1MjoyNzA1MzI2MTYsNDYwODoyNzA1NDA4MDgsNDg2NDo4MjAwLDUxMjA6MjA5NzE1Miw1Mzc2OjI2ODQzNTQ1Niw1NjMyOjI2ODQzNTQ2NCw1ODg4OjIxMDUzNDQsNjE0NDoyMTA1MzUyLDY0MDA6MCw2NjU2OjgsNjkxMjoyNzA1MzI2MDgsNzE2ODo4MTkyLDc0MjQ6MjY4NDQzNjU2LDc2ODA6MjcwNTQwODAwLDc5MzY6MjA5NzE2MCw0MjI0OjgsNDQ4MDoyMTA1MzQ0LDQ3MzY6MjA5NzE1Miw0OTkyOjI2ODQzNTQ2NCw1MjQ4OjI2ODQ0MzY0OCw1NTA0OjgyMDAsNTc2MDoyNzA1NDA4MDgsNjAxNjoyNzA1MzI2MDgsNjI3MjoyNzA1NDA4MDAsNjUyODoyNzA1MzI2MTYsNjc4NDo4MTkyLDcwNDA6MjEwNTM1Miw3Mjk2OjIwOTcxNjAsNzU1MjowLDc4MDg6MjY4NDM1NDU2LDgwNjQ6MjY4NDQzNjU2fSx7MDoxMDQ4NTc2LDE2OjMzNTU1NDU3LDMyOjEwMjQsNDg6MTA0OTYwMSw2NDozNDYwNDAzMyw4MDowLDk2OjEsMTEyOjM0NjAzMDA5LDEyODozMzU1NTQ1NiwxNDQ6MTA0ODU3NywxNjA6MzM1NTQ0MzMsMTc2OjM0NjA0MDMyLDE5MjozNDYwMzAwOCwyMDg6MTAyNSwyMjQ6MTA0OTYwMCwyNDA6MzM1NTQ0MzIsODozNDYwMzAwOSwyNDowLDQwOjMzNTU1NDU3LDU2OjM0NjA0MDMyLDcyOjEwNDg1NzYsODg6MzM1NTQ0MzMsMTA0OjMzNTU0NDMyLDEyMDoxMDI1LDEzNjoxMDQ5NjAxLDE1MjozMzU1NTQ1NiwxNjg6MzQ2MDMwMDgsMTg0OjEwNDg1NzcsMjAwOjEwMjQsMjE2OjM0NjA0MDMzLDIzMjoxLDI0ODoxMDQ5NjAwLDI1NjozMzU1NDQzMiwyNzI6MTA0ODU3NiwyODg6MzM1NTU0NTcsMzA0OjM0NjAzMDA5LDMyMDoxMDQ4NTc3LDMzNjozMzU1NTQ1NiwzNTI6MzQ2MDQwMzIsMzY4OjEwNDk2MDEsMzg0OjEwMjUsNDAwOjM0NjA0MDMzLDQxNjoxMDQ5NjAwLDQzMjoxLDQ0ODowLDQ2NDozNDYwMzAwOCw0ODA6MzM1NTQ0MzMsNDk2OjEwMjQsMjY0OjEwNDk2MDAsMjgwOjMzNTU1NDU3LDI5NjozNDYwMzAwOSwzMTI6MSwzMjg6MzM1NTQ0MzIsMzQ0OjEwNDg1NzYsMzYwOjEwMjUsMzc2OjM0NjA0MDMyLDM5MjozMzU1NDQzMyw0MDg6MzQ2MDMwMDgsNDI0OjAsNDQwOjM0NjA0MDMzLDQ1NjoxMDQ5NjAxLDQ3MjoxMDI0LDQ4ODozMzU1NTQ1Niw1MDQ6MTA0ODU3N30sezA6MTM0MjE5ODA4LDE6MTMxMDcyLDI6MTM0MjE3NzI4LDM6MzIsNDoxMzExMDQsNToxMzQzNTA4ODAsNjoxMzQzNTA4NDgsNzoyMDQ4LDg6MTM0MzQ4ODAwLDk6MTM0MjE5Nzc2LDEwOjEzMzEyMCwxMToxMzQzNDg4MzIsMTI6MjA4MCwxMzowLDE0OjEzNDIxNzc2MCwxNToxMzMxNTIsMjE0NzQ4MzY0ODoyMDQ4LDIxNDc0ODM2NDk6MTM0MzUwODgwLDIxNDc0ODM2NTA6MTM0MjE5ODA4LDIxNDc0ODM2NTE6MTM0MjE3NzI4LDIxNDc0ODM2NTI6MTM0MzQ4ODAwLDIxNDc0ODM2NTM6MTMzMTIwLDIxNDc0ODM2NTQ6MTMzMTUyLDIxNDc0ODM2NTU6MzIsMjE0NzQ4MzY1NjoxMzQyMTc3NjAsMjE0NzQ4MzY1NzoyMDgwLDIxNDc0ODM2NTg6MTMxMTA0LDIxNDc0ODM2NTk6MTM0MzUwODQ4LDIxNDc0ODM2NjA6MCwyMTQ3NDgzNjYxOjEzNDM0ODgzMiwyMTQ3NDgzNjYyOjEzNDIxOTc3NiwyMTQ3NDgzNjYzOjEzMTA3MiwxNjoxMzMxNTIsMTc6MTM0MzUwODQ4LDE4OjMyLDE5OjIwNDgsMjA6MTM0MjE5Nzc2LDIxOjEzNDIxNzc2MCwyMjoxMzQzNDg4MzIsMjM6MTMxMDcyLDI0OjAsMjU6MTMxMTA0LDI2OjEzNDM0ODgwMCwyNzoxMzQyMTk4MDgsMjg6MTM0MzUwODgwLDI5OjEzMzEyMCwzMDoyMDgwLDMxOjEzNDIxNzcyOCwyMTQ3NDgzNjY0OjEzMTA3MiwyMTQ3NDgzNjY1OjIwNDgsMjE0NzQ4MzY2NjoxMzQzNDg4MzIsMjE0NzQ4MzY2NzoxMzMxNTIsMjE0NzQ4MzY2ODozMiwyMTQ3NDgzNjY5OjEzNDM0ODgwMCwyMTQ3NDgzNjcwOjEzNDIxNzcyOCwyMTQ3NDgzNjcxOjEzNDIxOTgwOCwyMTQ3NDgzNjcyOjEzNDM1MDg4MCwyMTQ3NDgzNjczOjEzNDIxNzc2MCwyMTQ3NDgzNjc0OjEzNDIxOTc3NiwyMTQ3NDgzNjc1OjAsMjE0NzQ4MzY3NjoxMzMxMjAsMjE0NzQ4MzY3NzoyMDgwLDIxNDc0ODM2Nzg6MTMxMTA0LDIxNDc0ODM2Nzk6MTM0MzUwODQ4fV0sZj1bNDE2MDc0OTU2OSw1Mjg0ODIzMDQsMzMwMzAxNDQsMjA2NDM4NCwxMjkwMjQsODA2NCw1MDQsMjE0NzQ4MzY3OV0sbD1pLkRFUz1vLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5fa2V5LndvcmRzLGU9W10scj0wO3I8NTY7cisrKXt2YXIgbj1hW3JdLTE7ZVtyXT10W24+Pj41XT4+PjMxLW4lMzImMX1mb3IodmFyIG89dGhpcy5fc3ViS2V5cz1bXSxpPTA7aTwxNjtpKyspe3ZhciB1PW9baV09W10sZj1jW2ldO2ZvcihyPTA7cjwyNDtyKyspdVtyLzZ8MF18PWVbKHNbcl0tMStmKSUyOF08PDMxLXIlNix1WzQrKHIvNnwwKV18PWVbMjgrKHNbcisyNF0tMStmKSUyOF08PDMxLXIlNjt1WzBdPXVbMF08PDF8dVswXT4+PjMxO2ZvcihyPTE7cjw3O3IrKyl1W3JdPXVbcl0+Pj40KihyLTEpKzM7dVs3XT11WzddPDw1fHVbN10+Pj4yN312YXIgbD10aGlzLl9pbnZTdWJLZXlzPVtdO2ZvcihyPTA7cjwxNjtyKyspbFtyXT1vWzE1LXJdfSxlbmNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9kb0NyeXB0QmxvY2sodCxlLHRoaXMuX3N1YktleXMpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9kb0NyeXB0QmxvY2sodCxlLHRoaXMuX2ludlN1YktleXMpfSxfZG9DcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSxyKXt0aGlzLl9sQmxvY2s9dFtlXSx0aGlzLl9yQmxvY2s9dFtlKzFdLHAuY2FsbCh0aGlzLDQsMjUyNjQ1MTM1KSxwLmNhbGwodGhpcywxNiw2NTUzNSksaC5jYWxsKHRoaXMsMiw4NTg5OTM0NTkpLGguY2FsbCh0aGlzLDgsMTY3MTE5MzUpLHAuY2FsbCh0aGlzLDEsMTQzMTY1NTc2NSk7Zm9yKHZhciBuPTA7bjwxNjtuKyspe2Zvcih2YXIgbz1yW25dLGk9dGhpcy5fbEJsb2NrLGE9dGhpcy5fckJsb2NrLHM9MCxjPTA7Yzw4O2MrKylzfD11W2NdWygoYV5vW2NdKSZmW2NdKT4+PjBdO3RoaXMuX2xCbG9jaz1hLHRoaXMuX3JCbG9jaz1pXnN9dmFyIGw9dGhpcy5fbEJsb2NrO3RoaXMuX2xCbG9jaz10aGlzLl9yQmxvY2ssdGhpcy5fckJsb2NrPWwscC5jYWxsKHRoaXMsMSwxNDMxNjU1NzY1KSxoLmNhbGwodGhpcyw4LDE2NzExOTM1KSxoLmNhbGwodGhpcywyLDg1ODk5MzQ1OSkscC5jYWxsKHRoaXMsMTYsNjU1MzUpLHAuY2FsbCh0aGlzLDQsMjUyNjQ1MTM1KSx0W2VdPXRoaXMuX2xCbG9jayx0W2UrMV09dGhpcy5fckJsb2NrfSxrZXlTaXplOjIsaXZTaXplOjIsYmxvY2tTaXplOjJ9KTtmdW5jdGlvbiBwKHQsZSl7dmFyIHI9KHRoaXMuX2xCbG9jaz4+PnRedGhpcy5fckJsb2NrKSZlO3RoaXMuX3JCbG9ja149cix0aGlzLl9sQmxvY2tePXI8PHR9ZnVuY3Rpb24gaCh0LGUpe3ZhciByPSh0aGlzLl9yQmxvY2s+Pj50XnRoaXMuX2xCbG9jaykmZTt0aGlzLl9sQmxvY2tePXIsdGhpcy5fckJsb2NrXj1yPDx0fWUuREVTPW8uX2NyZWF0ZUhlbHBlcihsKTt2YXIgZD1pLlRyaXBsZURFUz1vLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9rZXkud29yZHM7dGhpcy5fZGVzMT1sLmNyZWF0ZUVuY3J5cHRvcihuLmNyZWF0ZSh0LnNsaWNlKDAsMikpKSx0aGlzLl9kZXMyPWwuY3JlYXRlRW5jcnlwdG9yKG4uY3JlYXRlKHQuc2xpY2UoMiw0KSkpLHRoaXMuX2RlczM9bC5jcmVhdGVFbmNyeXB0b3Iobi5jcmVhdGUodC5zbGljZSg0LDYpKSl9LGVuY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RlczEuZW5jcnlwdEJsb2NrKHQsZSksdGhpcy5fZGVzMi5kZWNyeXB0QmxvY2sodCxlKSx0aGlzLl9kZXMzLmVuY3J5cHRCbG9jayh0LGUpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayh0LGUpLHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKHQsZSksdGhpcy5fZGVzMS5kZWNyeXB0QmxvY2sodCxlKX0sa2V5U2l6ZTo2LGl2U2l6ZToyLGJsb2NrU2l6ZToyfSk7ZS5UcmlwbGVERVM9by5fY3JlYXRlSGVscGVyKGQpfSgpLHQuVHJpcGxlREVTfSwib2JqZWN0Ij09dHlwZW9mIHI/ZS5leHBvcnRzPXI9byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1MiwiLi9lbmMtYmFzZTY0Ijo1MywiLi9ldnBrZGYiOjU1LCIuL21kNSI6NjB9XSw4MzpbZnVuY3Rpb24odCxlLHIpe3ZhciBuLG87bj10aGlzLG89ZnVuY3Rpb24odCl7dmFyIGUscixuLG8saTtyZXR1cm4gcj0oZT10KS5saWIsbj1yLkJhc2Usbz1yLldvcmRBcnJheSwoaT1lLng2ND17fSkuV29yZD1uLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3RoaXMuaGlnaD10LHRoaXMubG93PWV9fSksaS5Xb3JkQXJyYXk9bi5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMud29yZHM9dHx8W10sdGhpcy5zaWdCeXRlcz1udWxsIT1lP2U6OCp0Lmxlbmd0aH0sdG9YMzI6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy53b3JkcyxlPXQubGVuZ3RoLHI9W10sbj0wO248ZTtuKyspe3ZhciBpPXRbbl07ci5wdXNoKGkuaGlnaCksci5wdXNoKGkubG93KX1yZXR1cm4gby5jcmVhdGUocix0aGlzLnNpZ0J5dGVzKX0sY2xvbmU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bi5jbG9uZS5jYWxsKHRoaXMpLGU9dC53b3Jkcz10aGlzLndvcmRzLnNsaWNlKDApLHI9ZS5sZW5ndGgsbz0wO288cjtvKyspZVtvXT1lW29dLmNsb25lKCk7cmV0dXJuIHR9fSksdH0sIm9iamVjdCI9PXR5cGVvZiByP2UuZXhwb3J0cz1yPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhuLkNyeXB0b0pTKX0seyIuL2NvcmUiOjUyfV0sODQ6W2Z1bmN0aW9uKHQsZSxyKXshZnVuY3Rpb24odCl7dmFyIG49Im9iamVjdCI9PXR5cGVvZiByJiZyLG89Im9iamVjdCI9PXR5cGVvZiBlJiZlJiZlLmV4cG9ydHM9PW4mJmUsaT0ib2JqZWN0Ij09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsO2kuZ2xvYmFsIT09aSYmaS53aW5kb3chPT1pfHwodD1pKTt2YXIgYSxzLGMsdT1TdHJpbmcuZnJvbUNoYXJDb2RlO2Z1bmN0aW9uIGYodCl7Zm9yKHZhciBlLHIsbj1bXSxvPTAsaT10Lmxlbmd0aDtvPGk7KShlPXQuY2hhckNvZGVBdChvKyspKT49NTUyOTYmJmU8PTU2MzE5JiZvPGk/NTYzMjA9PSg2NDUxMiYocj10LmNoYXJDb2RlQXQobysrKSkpP24ucHVzaCgoKDEwMjMmZSk8PDEwKSsoMTAyMyZyKSs2NTUzNik6KG4ucHVzaChlKSxvLS0pOm4ucHVzaChlKTtyZXR1cm4gbn1mdW5jdGlvbiBsKHQpe2lmKHQ+PTU1Mjk2JiZ0PD01NzM0Myl0aHJvdyBFcnJvcigiTG9uZSBzdXJyb2dhdGUgVSsiK3QudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrIiBpcyBub3QgYSBzY2FsYXIgdmFsdWUiKX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuIHUodD4+ZSY2M3wxMjgpfWZ1bmN0aW9uIGgodCl7aWYoMD09KDQyOTQ5NjcxNjgmdCkpcmV0dXJuIHUodCk7dmFyIGU9IiI7cmV0dXJuIDA9PSg0Mjk0OTY1MjQ4JnQpP2U9dSh0Pj42JjMxfDE5Mik6MD09KDQyOTQ5MDE3NjAmdCk/KGwodCksZT11KHQ+PjEyJjE1fDIyNCksZSs9cCh0LDYpKTowPT0oNDI5Mjg3MDE0NCZ0KSYmKGU9dSh0Pj4xOCY3fDI0MCksZSs9cCh0LDEyKSxlKz1wKHQsNikpLGUrPXUoNjMmdHwxMjgpfWZ1bmN0aW9uIGQoKXtpZihjPj1zKXRocm93IEVycm9yKCJJbnZhbGlkIGJ5dGUgaW5kZXgiKTt2YXIgdD0yNTUmYVtjXTtpZihjKyssMTI4PT0oMTkyJnQpKXJldHVybiA2MyZ0O3Rocm93IEVycm9yKCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlIil9ZnVuY3Rpb24gbSgpe3ZhciB0LGU7aWYoYz5zKXRocm93IEVycm9yKCJJbnZhbGlkIGJ5dGUgaW5kZXgiKTtpZihjPT1zKXJldHVybiExO2lmKHQ9MjU1JmFbY10sYysrLDA9PSgxMjgmdCkpcmV0dXJuIHQ7aWYoMTkyPT0oMjI0JnQpKXtpZigoZT0oMzEmdCk8PDZ8ZCgpKT49MTI4KXJldHVybiBlO3Rocm93IEVycm9yKCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlIil9aWYoMjI0PT0oMjQwJnQpKXtpZigoZT0oMTUmdCk8PDEyfGQoKTw8NnxkKCkpPj0yMDQ4KXJldHVybiBsKGUpLGU7dGhyb3cgRXJyb3IoIkludmFsaWQgY29udGludWF0aW9uIGJ5dGUiKX1pZigyNDA9PSgyNDgmdCkmJihlPSg3JnQpPDwxOHxkKCk8PDEyfGQoKTw8NnxkKCkpPj02NTUzNiYmZTw9MTExNDExMSlyZXR1cm4gZTt0aHJvdyBFcnJvcigiSW52YWxpZCBVVEYtOCBkZXRlY3RlZCIpfXZhciB5PXt2ZXJzaW9uOiIyLjEuMiIsZW5jb2RlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1mKHQpLHI9ZS5sZW5ndGgsbj0tMSxvPSIiOysrbjxyOylvKz1oKGVbbl0pO3JldHVybiBvfSxkZWNvZGU6ZnVuY3Rpb24odCl7YT1mKHQpLHM9YS5sZW5ndGgsYz0wO2Zvcih2YXIgZSxyPVtdOyExIT09KGU9bSgpKTspci5wdXNoKGUpO3JldHVybiBmdW5jdGlvbih0KXtmb3IodmFyIGUscj10Lmxlbmd0aCxuPS0xLG89IiI7KytuPHI7KShlPXRbbl0pPjY1NTM1JiYobys9dSgoZS09NjU1MzYpPj4+MTAmMTAyM3w1NTI5NiksZT01NjMyMHwxMDIzJmUpLG8rPXUoZSk7cmV0dXJuIG99KHIpfX07aWYoImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmIm9iamVjdCI9PXR5cGVvZiBkZWZpbmUuYW1kJiZkZWZpbmUuYW1kKWRlZmluZShmdW5jdGlvbigpe3JldHVybiB5fSk7ZWxzZSBpZihuJiYhbi5ub2RlVHlwZSlpZihvKW8uZXhwb3J0cz15O2Vsc2V7dmFyIGc9e30uaGFzT3duUHJvcGVydHk7Zm9yKHZhciB2IGluIHkpZy5jYWxsKHksdikmJihuW3ZdPXlbdl0pfWVsc2UgdC51dGY4PXl9KHRoaXMpfSx7fV0sODU6W2Z1bmN0aW9uKHQsZSxyKXtlLmV4cG9ydHM9WE1MSHR0cFJlcXVlc3R9LHt9XSwiYmlnbnVtYmVyLmpzIjpbZnVuY3Rpb24odCxlLHIpeyFmdW5jdGlvbih0KXsidXNlIHN0cmljdCI7dmFyIHIsbj0vXi0/KFxkKyhcLlxkKik/fFwuXGQrKShlWystXT9cZCspPyQvaSxvPU1hdGguY2VpbCxpPU1hdGguZmxvb3IsYT0iIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0IixzPSJyb3VuZGluZyBtb2RlIixjPSJudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0cyIsdT0iMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXyIsZj0xZTE0LGw9MTQscD05MDA3MTk5MjU0NzQwOTkxLGg9WzEsMTAsMTAwLDFlMywxZTQsMWU1LDFlNiwxZTcsMWU4LDFlOSwxZTEwLDFlMTEsMWUxMiwxZTEzXSxkPTFlNyxtPTFlOTtmdW5jdGlvbiB5KHQpe3ZhciBlPTB8dDtyZXR1cm4gdD4wfHx0PT09ZT9lOmUtMX1mdW5jdGlvbiBnKHQpe2Zvcih2YXIgZSxyLG49MSxvPXQubGVuZ3RoLGk9dFswXSsiIjtuPG87KXtmb3IoZT10W24rK10rIiIscj1sLWUubGVuZ3RoO3ItLTtlPSIwIitlKTtpKz1lfWZvcihvPWkubGVuZ3RoOzQ4PT09aS5jaGFyQ29kZUF0KC0tbyk7KTtyZXR1cm4gaS5zbGljZSgwLG8rMXx8MSl9ZnVuY3Rpb24gdih0LGUpe3ZhciByLG4sbz10LmMsaT1lLmMsYT10LnMscz1lLnMsYz10LmUsdT1lLmU7aWYoIWF8fCFzKXJldHVybiBudWxsO2lmKHI9byYmIW9bMF0sbj1pJiYhaVswXSxyfHxuKXJldHVybiByP24/MDotczphO2lmKGEhPXMpcmV0dXJuIGE7aWYocj1hPDAsbj1jPT11LCFvfHwhaSlyZXR1cm4gbj8wOiFvXnI/MTotMTtpZighbilyZXR1cm4gYz51XnI/MTotMTtmb3Iocz0oYz1vLmxlbmd0aCk8KHU9aS5sZW5ndGgpP2M6dSxhPTA7YTxzO2ErKylpZihvW2FdIT1pW2FdKXJldHVybiBvW2FdPmlbYV1ecj8xOi0xO3JldHVybiBjPT11PzA6Yz51XnI/MTotMX1mdW5jdGlvbiBiKHQsZSxyKXtyZXR1cm4odD1CKHQpKT49ZSYmdDw9cn1mdW5jdGlvbiBfKHQpe3JldHVybiJbb2JqZWN0IEFycmF5XSI9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1mdW5jdGlvbiB3KHQsZSxyKXtmb3IodmFyIG4sbyxpPVswXSxhPTAscz10Lmxlbmd0aDthPHM7KXtmb3Iobz1pLmxlbmd0aDtvLS07aVtvXSo9ZSk7Zm9yKGlbbj0wXSs9dS5pbmRleE9mKHQuY2hhckF0KGErKykpO248aS5sZW5ndGg7bisrKWlbbl0+ci0xJiYobnVsbD09aVtuKzFdJiYoaVtuKzFdPTApLGlbbisxXSs9aVtuXS9yfDAsaVtuXSU9cil9cmV0dXJuIGkucmV2ZXJzZSgpfWZ1bmN0aW9uIHgodCxlKXtyZXR1cm4odC5sZW5ndGg+MT90LmNoYXJBdCgwKSsiLiIrdC5zbGljZSgxKTp0KSsoZTwwPyJlIjoiZSsiKStlfWZ1bmN0aW9uIGsodCxlKXt2YXIgcixuO2lmKGU8MCl7Zm9yKG49IjAuIjsrK2U7bis9IjAiKTt0PW4rdH1lbHNlIGlmKCsrZT4ocj10Lmxlbmd0aCkpe2ZvcihuPSIwIixlLT1yOy0tZTtuKz0iMCIpO3QrPW59ZWxzZSBlPHImJih0PXQuc2xpY2UoMCxlKSsiLiIrdC5zbGljZShlKSk7cmV0dXJuIHR9ZnVuY3Rpb24gQih0KXtyZXR1cm4odD1wYXJzZUZsb2F0KHQpKTwwP28odCk6aSh0KX0ocj1mdW5jdGlvbiB0KGUpe3ZhciByLFMsQSxDLEYsTyxJLE4sVCxQPTAsRD1YLnByb3RvdHlwZSxSPW5ldyBYKDEpLEU9MjAsTT00LEg9LTcsaj0yMSxxPS0xZTcsej0xZTcsTD0hMCxVPVksVz0hMSxKPTEsSz0wLEc9e2RlY2ltYWxTZXBhcmF0b3I6Ii4iLGdyb3VwU2VwYXJhdG9yOiIsIixncm91cFNpemU6MyxzZWNvbmRhcnlHcm91cFNpemU6MCxmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiLCoCIsZnJhY3Rpb25Hcm91cFNpemU6MH07ZnVuY3Rpb24gWCh0LGUpe3ZhciByLG8sYSxzLGYsaCxkPXRoaXM7aWYoIShkIGluc3RhbmNlb2YgWCkpcmV0dXJuIEwmJnR0KDI2LCJjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgbmV3Iix0KSxuZXcgWCh0LGUpO2lmKG51bGwhPWUmJlUoZSwyLDY0LFAsImJhc2UiKSl7aWYoaD10KyIiLDEwPT0oZXw9MCkpcmV0dXJuIGV0KGQ9bmV3IFgodCBpbnN0YW5jZW9mIFg/dDpoKSxFK2QuZSsxLE0pO2lmKChzPSJudW1iZXIiPT10eXBlb2YgdCkmJjAqdCE9MHx8IW5ldyBSZWdFeHAoIl4tPyIrKHI9IlsiK3Uuc2xpY2UoMCxlKSsiXSsiKSsiKD86XFwuIityKyIpPyQiLGU8Mzc/ImkiOiIiKS50ZXN0KGgpKXJldHVybiBTKGQsaCxzLGUpO3M/KGQucz0xL3Q8MD8oaD1oLnNsaWNlKDEpLC0xKToxLEwmJmgucmVwbGFjZSgvXjBcLjAqfFwuLywiIikubGVuZ3RoPjE1JiZ0dChQLGMsdCkscz0hMSk6ZC5zPTQ1PT09aC5jaGFyQ29kZUF0KDApPyhoPWguc2xpY2UoMSksLTEpOjEsaD0kKGgsMTAsZSxkLnMpfWVsc2V7aWYodCBpbnN0YW5jZW9mIFgpcmV0dXJuIGQucz10LnMsZC5lPXQuZSxkLmM9KHQ9dC5jKT90LnNsaWNlKCk6dCx2b2lkKFA9MCk7aWYoKHM9Im51bWJlciI9PXR5cGVvZiB0KSYmMCp0PT0wKXtpZihkLnM9MS90PDA/KHQ9LXQsLTEpOjEsdD09PX5+dCl7Zm9yKG89MCxhPXQ7YT49MTA7YS89MTAsbysrKTtyZXR1cm4gZC5lPW8sZC5jPVt0XSx2b2lkKFA9MCl9aD10KyIifWVsc2V7aWYoIW4udGVzdChoPXQrIiIpKXJldHVybiBTKGQsaCxzKTtkLnM9NDU9PT1oLmNoYXJDb2RlQXQoMCk/KGg9aC5zbGljZSgxKSwtMSk6MX19Zm9yKChvPWguaW5kZXhPZigiLiIpKT4tMSYmKGg9aC5yZXBsYWNlKCIuIiwiIikpLChhPWguc2VhcmNoKC9lL2kpKT4wPyhvPDAmJihvPWEpLG8rPStoLnNsaWNlKGErMSksaD1oLnN1YnN0cmluZygwLGEpKTpvPDAmJihvPWgubGVuZ3RoKSxhPTA7NDg9PT1oLmNoYXJDb2RlQXQoYSk7YSsrKTtmb3IoZj1oLmxlbmd0aDs0OD09PWguY2hhckNvZGVBdCgtLWYpOyk7aWYoaD1oLnNsaWNlKGEsZisxKSlpZihmPWgubGVuZ3RoLHMmJkwmJmY+MTUmJih0PnB8fHQhPT1pKHQpKSYmdHQoUCxjLGQucyp0KSwobz1vLWEtMSk+eilkLmM9ZC5lPW51bGw7ZWxzZSBpZihvPHEpZC5jPVtkLmU9MF07ZWxzZXtpZihkLmU9byxkLmM9W10sYT0obysxKSVsLG88MCYmKGErPWwpLGE8Zil7Zm9yKGEmJmQuYy5wdXNoKCtoLnNsaWNlKDAsYSkpLGYtPWw7YTxmOylkLmMucHVzaCgraC5zbGljZShhLGErPWwpKTtoPWguc2xpY2UoYSksYT1sLWgubGVuZ3RofWVsc2UgYS09Zjtmb3IoO2EtLTtoKz0iMCIpO2QuYy5wdXNoKCtoKX1lbHNlIGQuYz1bZC5lPTBdO1A9MH1mdW5jdGlvbiAkKHQsZSxuLG8pe3ZhciBpLGEscyxjLGYsbCxwLGg9dC5pbmRleE9mKCIuIiksZD1FLG09TTtmb3IobjwzNyYmKHQ9dC50b0xvd2VyQ2FzZSgpKSxoPj0wJiYocz1LLEs9MCx0PXQucmVwbGFjZSgiLiIsIiIpLGY9KHA9bmV3IFgobikpLnBvdyh0Lmxlbmd0aC1oKSxLPXMscC5jPXcoayhnKGYuYyksZi5lKSwxMCxlKSxwLmU9cC5jLmxlbmd0aCksYT1zPShsPXcodCxuLGUpKS5sZW5ndGg7MD09bFstLXNdO2wucG9wKCkpO2lmKCFsWzBdKXJldHVybiIwIjtpZihoPDA/LS1hOihmLmM9bCxmLmU9YSxmLnM9byxsPShmPXIoZixwLGQsbSxlKSkuYyxjPWYucixhPWYuZSksaD1sW2k9YStkKzFdLHM9ZS8yLGM9Y3x8aTwwfHxudWxsIT1sW2krMV0sYz1tPDQ/KG51bGwhPWh8fGMpJiYoMD09bXx8bT09KGYuczwwPzM6MikpOmg+c3x8aD09cyYmKDQ9PW18fGN8fDY9PW0mJjEmbFtpLTFdfHxtPT0oZi5zPDA/ODo3KSksaTwxfHwhbFswXSl0PWM/aygiMSIsLWQpOiIwIjtlbHNle2lmKGwubGVuZ3RoPWksYylmb3IoLS1lOysrbFstLWldPmU7KWxbaV09MCxpfHwoKythLGw9WzFdLmNvbmNhdChsKSk7Zm9yKHM9bC5sZW5ndGg7IWxbLS1zXTspO2ZvcihoPTAsdD0iIjtoPD1zO3QrPXUuY2hhckF0KGxbaCsrXSkpO3Q9ayh0LGEpfXJldHVybiB0fWZ1bmN0aW9uIFYodCxlLHIsbil7dmFyIG8saSxhLGMsdTtpZihyPW51bGwhPXImJlUociwwLDgsbixzKT8wfHI6TSwhdC5jKXJldHVybiB0LnRvU3RyaW5nKCk7aWYobz10LmNbMF0sYT10LmUsbnVsbD09ZSl1PWcodC5jKSx1PTE5PT1ufHwyND09biYmYTw9SD94KHUsYSk6ayh1LGEpO2Vsc2UgaWYoaT0odD1ldChuZXcgWCh0KSxlLHIpKS5lLGM9KHU9Zyh0LmMpKS5sZW5ndGgsMTk9PW58fDI0PT1uJiYoZTw9aXx8aTw9SCkpe2Zvcig7YzxlO3UrPSIwIixjKyspO3U9eCh1LGkpfWVsc2UgaWYoZS09YSx1PWsodSxpKSxpKzE+Yyl7aWYoLS1lPjApZm9yKHUrPSIuIjtlLS07dSs9IjAiKTt9ZWxzZSBpZigoZSs9aS1jKT4wKWZvcihpKzE9PWMmJih1Kz0iLiIpO2UtLTt1Kz0iMCIpO3JldHVybiB0LnM8MCYmbz8iLSIrdTp1fWZ1bmN0aW9uIFoodCxlKXt2YXIgcixuLG89MDtmb3IoXyh0WzBdKSYmKHQ9dFswXSkscj1uZXcgWCh0WzBdKTsrK288dC5sZW5ndGg7KXtpZighKG49bmV3IFgodFtvXSkpLnMpe3I9bjticmVha31lLmNhbGwocixuKSYmKHI9bil9cmV0dXJuIHJ9ZnVuY3Rpb24gWSh0LGUscixuLG8pe3JldHVybih0PGV8fHQ+cnx8dCE9Qih0KSkmJnR0KG4sKG98fCJkZWNpbWFsIHBsYWNlcyIpKyh0PGV8fHQ+cj8iIG91dCBvZiByYW5nZSI6IiBub3QgYW4gaW50ZWdlciIpLHQpLCEwfWZ1bmN0aW9uIFEodCxlLHIpe2Zvcih2YXIgbj0xLG89ZS5sZW5ndGg7IWVbLS1vXTtlLnBvcCgpKTtmb3Iobz1lWzBdO28+PTEwO28vPTEwLG4rKyk7cmV0dXJuKHI9bityKmwtMSk+ej90LmM9dC5lPW51bGw6cjxxP3QuYz1bdC5lPTBdOih0LmU9cix0LmM9ZSksdH1mdW5jdGlvbiB0dCh0LGUscil7dmFyIG49bmV3IEVycm9yKFsibmV3IEJpZ051bWJlciIsImNtcCIsImNvbmZpZyIsImRpdiIsImRpdlRvSW50IiwiZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibWludXMiLCJtb2QiLCJwbHVzIiwicHJlY2lzaW9uIiwicmFuZG9tIiwicm91bmQiLCJzaGlmdCIsInRpbWVzIiwidG9EaWdpdHMiLCJ0b0V4cG9uZW50aWFsIiwidG9GaXhlZCIsInRvRm9ybWF0IiwidG9GcmFjdGlvbiIsInBvdyIsInRvUHJlY2lzaW9uIiwidG9TdHJpbmciLCJCaWdOdW1iZXIiXVt0XSsiKCkgIitlKyI6ICIrcik7dGhyb3cgbi5uYW1lPSJCaWdOdW1iZXIgRXJyb3IiLFA9MCxufWZ1bmN0aW9uIGV0KHQsZSxyLG4pe3ZhciBhLHMsYyx1LHAsZCxtLHk9dC5jLGc9aDtpZih5KXt0Ontmb3IoYT0xLHU9eVswXTt1Pj0xMDt1Lz0xMCxhKyspO2lmKChzPWUtYSk8MClzKz1sLGM9ZSxtPShwPXlbZD0wXSkvZ1thLWMtMV0lMTB8MDtlbHNlIGlmKChkPW8oKHMrMSkvbCkpPj15Lmxlbmd0aCl7aWYoIW4pYnJlYWsgdDtmb3IoO3kubGVuZ3RoPD1kO3kucHVzaCgwKSk7cD1tPTAsYT0xLGM9KHMlPWwpLWwrMX1lbHNle2ZvcihwPXU9eVtkXSxhPTE7dT49MTA7dS89MTAsYSsrKTttPShjPShzJT1sKS1sK2EpPDA/MDpwL2dbYS1jLTFdJTEwfDB9aWYobj1ufHxlPDB8fG51bGwhPXlbZCsxXXx8KGM8MD9wOnAlZ1thLWMtMV0pLG49cjw0PyhtfHxuKSYmKDA9PXJ8fHI9PSh0LnM8MD8zOjIpKTptPjV8fDU9PW0mJig0PT1yfHxufHw2PT1yJiYocz4wP2M+MD9wL2dbYS1jXTowOnlbZC0xXSklMTAmMXx8cj09KHQuczwwPzg6NykpLGU8MXx8IXlbMF0pcmV0dXJuIHkubGVuZ3RoPTAsbj8oZS09dC5lKzEseVswXT1nWyhsLWUlbCklbF0sdC5lPS1lfHwwKTp5WzBdPXQuZT0wLHQ7aWYoMD09cz8oeS5sZW5ndGg9ZCx1PTEsZC0tKTooeS5sZW5ndGg9ZCsxLHU9Z1tsLXNdLHlbZF09Yz4wP2kocC9nW2EtY10lZ1tjXSkqdTowKSxuKWZvcig7Oyl7aWYoMD09ZCl7Zm9yKHM9MSxjPXlbMF07Yz49MTA7Yy89MTAscysrKTtmb3IoYz15WzBdKz11LHU9MTtjPj0xMDtjLz0xMCx1KyspO3MhPXUmJih0LmUrKyx5WzBdPT1mJiYoeVswXT0xKSk7YnJlYWt9aWYoeVtkXSs9dSx5W2RdIT1mKWJyZWFrO3lbZC0tXT0wLHU9MX1mb3Iocz15Lmxlbmd0aDswPT09eVstLXNdO3kucG9wKCkpO310LmU+ej90LmM9dC5lPW51bGw6dC5lPHEmJih0LmM9W3QuZT0wXSl9cmV0dXJuIHR9cmV0dXJuIFguYW5vdGhlcj10LFguUk9VTkRfVVA9MCxYLlJPVU5EX0RPV049MSxYLlJPVU5EX0NFSUw9MixYLlJPVU5EX0ZMT09SPTMsWC5ST1VORF9IQUxGX1VQPTQsWC5ST1VORF9IQUxGX0RPV049NSxYLlJPVU5EX0hBTEZfRVZFTj02LFguUk9VTkRfSEFMRl9DRUlMPTcsWC5ST1VORF9IQUxGX0ZMT09SPTgsWC5FVUNMSUQ9OSxYLmNvbmZpZz1YLnNldD1mdW5jdGlvbigpe3ZhciB0LGUscj0wLG49e30sbz1hcmd1bWVudHMsaT1vWzBdLHM9aSYmIm9iamVjdCI9PXR5cGVvZiBpP2Z1bmN0aW9uKCl7aWYoaS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gbnVsbCE9KHQ9aVtlXSl9OmZ1bmN0aW9uKCl7aWYoby5sZW5ndGg+cilyZXR1cm4gbnVsbCE9KHQ9b1tyKytdKX07cmV0dXJuIHMoZT0iREVDSU1BTF9QTEFDRVMiKSYmVSh0LDAsbSwyLGUpJiYoRT0wfHQpLG5bZV09RSxzKGU9IlJPVU5ESU5HX01PREUiKSYmVSh0LDAsOCwyLGUpJiYoTT0wfHQpLG5bZV09TSxzKGU9IkVYUE9ORU5USUFMX0FUIikmJihfKHQpP1UodFswXSwtbSwwLDIsZSkmJlUodFsxXSwwLG0sMixlKSYmKEg9MHx0WzBdLGo9MHx0WzFdKTpVKHQsLW0sbSwyLGUpJiYoSD0tKGo9MHwodDwwPy10OnQpKSkpLG5bZV09W0gsal0scyhlPSJSQU5HRSIpJiYoXyh0KT9VKHRbMF0sLW0sLTEsMixlKSYmVSh0WzFdLDEsbSwyLGUpJiYocT0wfHRbMF0sej0wfHRbMV0pOlUodCwtbSxtLDIsZSkmJigwfHQ/cT0tKHo9MHwodDwwPy10OnQpKTpMJiZ0dCgyLGUrIiBjYW5ub3QgYmUgemVybyIsdCkpKSxuW2VdPVtxLHpdLHMoZT0iRVJST1JTIikmJih0PT09ISF0fHwxPT09dHx8MD09PXQ/KFA9MCxVPShMPSEhdCk/WTpiKTpMJiZ0dCgyLGUrYSx0KSksbltlXT1MLHMoZT0iQ1JZUFRPIikmJighMD09PXR8fCExPT09dHx8MT09PXR8fDA9PT10P3Q/ISh0PSJ1bmRlZmluZWQiPT10eXBlb2YgY3J5cHRvKSYmY3J5cHRvJiYoY3J5cHRvLmdldFJhbmRvbVZhbHVlc3x8Y3J5cHRvLnJhbmRvbUJ5dGVzKT9XPSEwOkw/dHQoMiwiY3J5cHRvIHVuYXZhaWxhYmxlIix0P3ZvaWQgMDpjcnlwdG8pOlc9ITE6Vz0hMTpMJiZ0dCgyLGUrYSx0KSksbltlXT1XLHMoZT0iTU9EVUxPX01PREUiKSYmVSh0LDAsOSwyLGUpJiYoSj0wfHQpLG5bZV09SixzKGU9IlBPV19QUkVDSVNJT04iKSYmVSh0LDAsbSwyLGUpJiYoSz0wfHQpLG5bZV09SyxzKGU9IkZPUk1BVCIpJiYoIm9iamVjdCI9PXR5cGVvZiB0P0c9dDpMJiZ0dCgyLGUrIiBub3QgYW4gb2JqZWN0Iix0KSksbltlXT1HLG59LFgubWF4PWZ1bmN0aW9uKCl7cmV0dXJuIFooYXJndW1lbnRzLEQubHQpfSxYLm1pbj1mdW5jdGlvbigpe3JldHVybiBaKGFyZ3VtZW50cyxELmd0KX0sWC5yYW5kb209KEE9OTAwNzE5OTI1NDc0MDk5MixDPU1hdGgucmFuZG9tKCkqQSYyMDk3MTUxP2Z1bmN0aW9uKCl7cmV0dXJuIGkoTWF0aC5yYW5kb20oKSpBKX06ZnVuY3Rpb24oKXtyZXR1cm4gODM4ODYwOCooMTA3Mzc0MTgyNCpNYXRoLnJhbmRvbSgpfDApKyg4Mzg4NjA4Kk1hdGgucmFuZG9tKCl8MCl9LGZ1bmN0aW9uKHQpe3ZhciBlLHIsbixhLHMsYz0wLHU9W10sZj1uZXcgWChSKTtpZih0PW51bGwhPXQmJlUodCwwLG0sMTQpPzB8dDpFLGE9byh0L2wpLFcpaWYoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyl7Zm9yKGU9Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoYSo9MikpO2M8YTspKHM9MTMxMDcyKmVbY10rKGVbYysxXT4+PjExKSk+PTllMTU/KHI9Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpLGVbY109clswXSxlW2MrMV09clsxXSk6KHUucHVzaChzJTFlMTQpLGMrPTIpO2M9YS8yfWVsc2UgaWYoY3J5cHRvLnJhbmRvbUJ5dGVzKXtmb3IoZT1jcnlwdG8ucmFuZG9tQnl0ZXMoYSo9Nyk7YzxhOykocz0yODE0NzQ5NzY3MTA2NTYqKDMxJmVbY10pKzEwOTk1MTE2Mjc3NzYqZVtjKzFdKzQyOTQ5NjcyOTYqZVtjKzJdKzE2Nzc3MjE2KmVbYyszXSsoZVtjKzRdPDwxNikrKGVbYys1XTw8OCkrZVtjKzZdKT49OWUxNT9jcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShlLGMpOih1LnB1c2gocyUxZTE0KSxjKz03KTtjPWEvN31lbHNlIFc9ITEsTCYmdHQoMTQsImNyeXB0byB1bmF2YWlsYWJsZSIsY3J5cHRvKTtpZighVylmb3IoO2M8YTspKHM9QygpKTw5ZTE1JiYodVtjKytdPXMlMWUxNCk7Zm9yKGE9dVstLWNdLHQlPWwsYSYmdCYmKHM9aFtsLXRdLHVbY109aShhL3MpKnMpOzA9PT11W2NdO3UucG9wKCksYy0tKTtpZihjPDApdT1bbj0wXTtlbHNle2ZvcihuPS0xOzA9PT11WzBdO3Uuc3BsaWNlKDAsMSksbi09bCk7Zm9yKGM9MSxzPXVbMF07cz49MTA7cy89MTAsYysrKTtjPGwmJihuLT1sLWMpfXJldHVybiBmLmU9bixmLmM9dSxmfSkscj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIpe3ZhciBuLG8saSxhLHM9MCxjPXQubGVuZ3RoLHU9ZSVkLGY9ZS9kfDA7Zm9yKHQ9dC5zbGljZSgpO2MtLTspcz0oKG89dSooaT10W2NdJWQpKyhuPWYqaSsoYT10W2NdL2R8MCkqdSklZCpkK3MpL3J8MCkrKG4vZHwwKStmKmEsdFtjXT1vJXI7cmV0dXJuIHMmJih0PVtzXS5jb25jYXQodCkpLHR9ZnVuY3Rpb24gZSh0LGUscixuKXt2YXIgbyxpO2lmKHIhPW4paT1yPm4/MTotMTtlbHNlIGZvcihvPWk9MDtvPHI7bysrKWlmKHRbb10hPWVbb10pe2k9dFtvXT5lW29dPzE6LTE7YnJlYWt9cmV0dXJuIGl9ZnVuY3Rpb24gcih0LGUscixuKXtmb3IodmFyIG89MDtyLS07KXRbcl0tPW8sbz10W3JdPGVbcl0/MTowLHRbcl09bypuK3Rbcl0tZVtyXTtmb3IoOyF0WzBdJiZ0Lmxlbmd0aD4xO3Quc3BsaWNlKDAsMSkpO31yZXR1cm4gZnVuY3Rpb24obixvLGEscyxjKXt2YXIgdSxwLGgsZCxtLGcsdixiLF8sdyx4LGssQixTLEEsQyxGLE89bi5zPT1vLnM/MTotMSxJPW4uYyxOPW8uYztpZighKEkmJklbMF0mJk4mJk5bMF0pKXJldHVybiBuZXcgWChuLnMmJm8ucyYmKEk/IU58fElbMF0hPU5bMF06Tik/SSYmMD09SVswXXx8IU4/MCpPOk8vMDpOYU4pO2ZvcihfPShiPW5ldyBYKE8pKS5jPVtdLE89YSsocD1uLmUtby5lKSsxLGN8fChjPWYscD15KG4uZS9sKS15KG8uZS9sKSxPPU8vbHwwKSxoPTA7TltoXT09KElbaF18fDApO2grKyk7aWYoTltoXT4oSVtoXXx8MCkmJnAtLSxPPDApXy5wdXNoKDEpLGQ9ITA7ZWxzZXtmb3IoUz1JLmxlbmd0aCxDPU4ubGVuZ3RoLGg9MCxPKz0yLChtPWkoYy8oTlswXSsxKSkpPjEmJihOPXQoTixtLGMpLEk9dChJLG0sYyksQz1OLmxlbmd0aCxTPUkubGVuZ3RoKSxCPUMseD0odz1JLnNsaWNlKDAsQykpLmxlbmd0aDt4PEM7d1t4KytdPTApO0Y9Ti5zbGljZSgpLEY9WzBdLmNvbmNhdChGKSxBPU5bMF0sTlsxXT49Yy8yJiZBKys7ZG97aWYobT0wLCh1PWUoTix3LEMseCkpPDApe2lmKGs9d1swXSxDIT14JiYoaz1rKmMrKHdbMV18fDApKSwobT1pKGsvQSkpPjEpZm9yKG0+PWMmJihtPWMtMSksdj0oZz10KE4sbSxjKSkubGVuZ3RoLHg9dy5sZW5ndGg7MT09ZShnLHcsdix4KTspbS0tLHIoZyxDPHY/RjpOLHYsYyksdj1nLmxlbmd0aCx1PTE7ZWxzZSAwPT1tJiYodT1tPTEpLHY9KGc9Ti5zbGljZSgpKS5sZW5ndGg7aWYodjx4JiYoZz1bMF0uY29uY2F0KGcpKSxyKHcsZyx4LGMpLHg9dy5sZW5ndGgsLTE9PXUpZm9yKDtlKE4sdyxDLHgpPDE7KW0rKyxyKHcsQzx4P0Y6Tix4LGMpLHg9dy5sZW5ndGh9ZWxzZSAwPT09dSYmKG0rKyx3PVswXSk7X1toKytdPW0sd1swXT93W3grK109SVtCXXx8MDoodz1bSVtCXV0seD0xKX13aGlsZSgoQisrPFN8fG51bGwhPXdbMF0pJiZPLS0pO2Q9bnVsbCE9d1swXSxfWzBdfHxfLnNwbGljZSgwLDEpfWlmKGM9PWYpe2ZvcihoPTEsTz1fWzBdO08+PTEwO08vPTEwLGgrKyk7ZXQoYixhKyhiLmU9aCtwKmwtMSkrMSxzLGQpfWVsc2UgYi5lPXAsYi5yPStkO3JldHVybiBifX0oKSxGPS9eKC0/KTAoW3hib10pKD89XHdbXHcuXSokKS9pLE89L14oW14uXSspXC4kLyxJPS9eXC4oW14uXSspJC8sTj0vXi0/KEluZmluaXR5fE5hTikkLyxUPS9eXHMqXCsoPz1bXHcuXSl8XlxzK3xccyskL2csUz1mdW5jdGlvbih0LGUscixuKXt2YXIgbyxpPXI/ZTplLnJlcGxhY2UoVCwiIik7aWYoTi50ZXN0KGkpKXQucz1pc05hTihpKT9udWxsOmk8MD8tMToxO2Vsc2V7aWYoIXImJihpPWkucmVwbGFjZShGLGZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gbz0ieCI9PShyPXIudG9Mb3dlckNhc2UoKSk/MTY6ImIiPT1yPzI6OCxuJiZuIT1vP3Q6ZX0pLG4mJihvPW4saT1pLnJlcGxhY2UoTywiJDEiKS5yZXBsYWNlKEksIjAuJDEiKSksZSE9aSkpcmV0dXJuIG5ldyBYKGksbyk7TCYmdHQoUCwibm90IGEiKyhuPyIgYmFzZSAiK246IiIpKyIgbnVtYmVyIixlKSx0LnM9bnVsbH10LmM9dC5lPW51bGwsUD0wfSxELmFic29sdXRlVmFsdWU9RC5hYnM9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgWCh0aGlzKTtyZXR1cm4gdC5zPDAmJih0LnM9MSksdH0sRC5jZWlsPWZ1bmN0aW9uKCl7cmV0dXJuIGV0KG5ldyBYKHRoaXMpLHRoaXMuZSsxLDIpfSxELmNvbXBhcmVkVG89RC5jbXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gUD0xLHYodGhpcyxuZXcgWCh0LGUpKX0sRC5kZWNpbWFsUGxhY2VzPUQuZHA9ZnVuY3Rpb24oKXt2YXIgdCxlLHI9dGhpcy5jO2lmKCFyKXJldHVybiBudWxsO2lmKHQ9KChlPXIubGVuZ3RoLTEpLXkodGhpcy5lL2wpKSpsLGU9cltlXSlmb3IoO2UlMTA9PTA7ZS89MTAsdC0tKTtyZXR1cm4gdDwwJiYodD0wKSx0fSxELmRpdmlkZWRCeT1ELmRpdj1mdW5jdGlvbih0LGUpe3JldHVybiBQPTMscih0aGlzLG5ldyBYKHQsZSksRSxNKX0sRC5kaXZpZGVkVG9JbnRlZ2VyQnk9RC5kaXZUb0ludD1mdW5jdGlvbih0LGUpe3JldHVybiBQPTQscih0aGlzLG5ldyBYKHQsZSksMCwxKX0sRC5lcXVhbHM9RC5lcT1mdW5jdGlvbih0LGUpe3JldHVybiBQPTUsMD09PXYodGhpcyxuZXcgWCh0LGUpKX0sRC5mbG9vcj1mdW5jdGlvbigpe3JldHVybiBldChuZXcgWCh0aGlzKSx0aGlzLmUrMSwzKX0sRC5ncmVhdGVyVGhhbj1ELmd0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFA9Nix2KHRoaXMsbmV3IFgodCxlKSk+MH0sRC5ncmVhdGVyVGhhbk9yRXF1YWxUbz1ELmd0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBQPTcsMT09PShlPXYodGhpcyxuZXcgWCh0LGUpKSl8fDA9PT1lfSxELmlzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmN9LEQuaXNJbnRlZ2VyPUQuaXNJbnQ9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmeSh0aGlzLmUvbCk+dGhpcy5jLmxlbmd0aC0yfSxELmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc30sRC5pc05lZ2F0aXZlPUQuaXNOZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zPDB9LEQuaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmMmJjA9PXRoaXMuY1swXX0sRC5sZXNzVGhhbj1ELmx0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFA9OCx2KHRoaXMsbmV3IFgodCxlKSk8MH0sRC5sZXNzVGhhbk9yRXF1YWxUbz1ELmx0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBQPTksLTE9PT0oZT12KHRoaXMsbmV3IFgodCxlKSkpfHwwPT09ZX0sRC5taW51cz1ELnN1Yj1mdW5jdGlvbih0LGUpe3ZhciByLG4sbyxpLGE9dGhpcyxzPWEucztpZihQPTEwLGU9KHQ9bmV3IFgodCxlKSkucywhc3x8IWUpcmV0dXJuIG5ldyBYKE5hTik7aWYocyE9ZSlyZXR1cm4gdC5zPS1lLGEucGx1cyh0KTt2YXIgYz1hLmUvbCx1PXQuZS9sLHA9YS5jLGg9dC5jO2lmKCFjfHwhdSl7aWYoIXB8fCFoKXJldHVybiBwPyh0LnM9LWUsdCk6bmV3IFgoaD9hOk5hTik7aWYoIXBbMF18fCFoWzBdKXJldHVybiBoWzBdPyh0LnM9LWUsdCk6bmV3IFgocFswXT9hOjM9PU0/LTA6MCl9aWYoYz15KGMpLHU9eSh1KSxwPXAuc2xpY2UoKSxzPWMtdSl7Zm9yKChpPXM8MCk/KHM9LXMsbz1wKToodT1jLG89aCksby5yZXZlcnNlKCksZT1zO2UtLTtvLnB1c2goMCkpO28ucmV2ZXJzZSgpfWVsc2UgZm9yKG49KGk9KHM9cC5sZW5ndGgpPChlPWgubGVuZ3RoKSk/czplLHM9ZT0wO2U8bjtlKyspaWYocFtlXSE9aFtlXSl7aT1wW2VdPGhbZV07YnJlYWt9aWYoaSYmKG89cCxwPWgsaD1vLHQucz0tdC5zKSwoZT0obj1oLmxlbmd0aCktKHI9cC5sZW5ndGgpKT4wKWZvcig7ZS0tO3BbcisrXT0wKTtmb3IoZT1mLTE7bj5zOyl7aWYocFstLW5dPGhbbl0pe2ZvcihyPW47ciYmIXBbLS1yXTtwW3JdPWUpOy0tcFtyXSxwW25dKz1mfXBbbl0tPWhbbl19Zm9yKDswPT1wWzBdO3Auc3BsaWNlKDAsMSksLS11KTtyZXR1cm4gcFswXT9RKHQscCx1KToodC5zPTM9PU0/LTE6MSx0LmM9W3QuZT0wXSx0KX0sRC5tb2R1bG89RC5tb2Q9ZnVuY3Rpb24odCxlKXt2YXIgbixvLGk9dGhpcztyZXR1cm4gUD0xMSx0PW5ldyBYKHQsZSksIWkuY3x8IXQuc3x8dC5jJiYhdC5jWzBdP25ldyBYKE5hTik6IXQuY3x8aS5jJiYhaS5jWzBdP25ldyBYKGkpOig5PT1KPyhvPXQucyx0LnM9MSxuPXIoaSx0LDAsMyksdC5zPW8sbi5zKj1vKTpuPXIoaSx0LDAsSiksaS5taW51cyhuLnRpbWVzKHQpKSl9LEQubmVnYXRlZD1ELm5lZz1mdW5jdGlvbigpe3ZhciB0PW5ldyBYKHRoaXMpO3JldHVybiB0LnM9LXQuc3x8bnVsbCx0fSxELnBsdXM9RC5hZGQ9ZnVuY3Rpb24odCxlKXt2YXIgcixuPXRoaXMsbz1uLnM7aWYoUD0xMixlPSh0PW5ldyBYKHQsZSkpLnMsIW98fCFlKXJldHVybiBuZXcgWChOYU4pO2lmKG8hPWUpcmV0dXJuIHQucz0tZSxuLm1pbnVzKHQpO3ZhciBpPW4uZS9sLGE9dC5lL2wscz1uLmMsYz10LmM7aWYoIWl8fCFhKXtpZighc3x8IWMpcmV0dXJuIG5ldyBYKG8vMCk7aWYoIXNbMF18fCFjWzBdKXJldHVybiBjWzBdP3Q6bmV3IFgoc1swXT9uOjAqbyl9aWYoaT15KGkpLGE9eShhKSxzPXMuc2xpY2UoKSxvPWktYSl7Zm9yKG8+MD8oYT1pLHI9Yyk6KG89LW8scj1zKSxyLnJldmVyc2UoKTtvLS07ci5wdXNoKDApKTtyLnJldmVyc2UoKX1mb3IoKG89cy5sZW5ndGgpLShlPWMubGVuZ3RoKTwwJiYocj1jLGM9cyxzPXIsZT1vKSxvPTA7ZTspbz0oc1stLWVdPXNbZV0rY1tlXStvKS9mfDAsc1tlXT1mPT09c1tlXT8wOnNbZV0lZjtyZXR1cm4gbyYmKHM9W29dLmNvbmNhdChzKSwrK2EpLFEodCxzLGEpfSxELnByZWNpc2lvbj1ELnNkPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbj10aGlzLmM7aWYobnVsbCE9dCYmdCE9PSEhdCYmMSE9PXQmJjAhPT10JiYoTCYmdHQoMTMsImFyZ3VtZW50IithLHQpLHQhPSEhdCYmKHQ9bnVsbCkpLCFuKXJldHVybiBudWxsO2lmKGU9KHI9bi5sZW5ndGgtMSkqbCsxLHI9bltyXSl7Zm9yKDtyJTEwPT0wO3IvPTEwLGUtLSk7Zm9yKHI9blswXTtyPj0xMDtyLz0xMCxlKyspO31yZXR1cm4gdCYmdGhpcy5lKzE+ZSYmKGU9dGhpcy5lKzEpLGV9LEQucm91bmQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1uZXcgWCh0aGlzKTtyZXR1cm4obnVsbD09dHx8VSh0LDAsbSwxNSkpJiZldChyLH5+dCt0aGlzLmUrMSxudWxsIT1lJiZVKGUsMCw4LDE1LHMpPzB8ZTpNKSxyfSxELnNoaWZ0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIFUodCwtcCxwLDE2LCJhcmd1bWVudCIpP2UudGltZXMoIjFlIitCKHQpKTpuZXcgWChlLmMmJmUuY1swXSYmKHQ8LXB8fHQ+cCk/ZS5zKih0PDA/MDoxLzApOmUpfSxELnNxdWFyZVJvb3Q9RC5zcXJ0PWZ1bmN0aW9uKCl7dmFyIHQsZSxuLG8saSxhPXRoaXMscz1hLmMsYz1hLnMsdT1hLmUsZj1FKzQsbD1uZXcgWCgiMC41Iik7aWYoMSE9PWN8fCFzfHwhc1swXSlyZXR1cm4gbmV3IFgoIWN8fGM8MCYmKCFzfHxzWzBdKT9OYU46cz9hOjEvMCk7aWYoMD09KGM9TWF0aC5zcXJ0KCthKSl8fGM9PTEvMD8oKChlPWcocykpLmxlbmd0aCt1KSUyPT0wJiYoZSs9IjAiKSxjPU1hdGguc3FydChlKSx1PXkoKHUrMSkvMiktKHU8MHx8dSUyKSxuPW5ldyBYKGU9Yz09MS8wPyIxZSIrdTooZT1jLnRvRXhwb25lbnRpYWwoKSkuc2xpY2UoMCxlLmluZGV4T2YoImUiKSsxKSt1KSk6bj1uZXcgWChjKyIiKSxuLmNbMF0pZm9yKChjPSh1PW4uZSkrZik8MyYmKGM9MCk7OylpZihpPW4sbj1sLnRpbWVzKGkucGx1cyhyKGEsaSxmLDEpKSksZyhpLmMpLnNsaWNlKDAsYyk9PT0oZT1nKG4uYykpLnNsaWNlKDAsYykpe2lmKG4uZTx1JiYtLWMsIjk5OTkiIT0oZT1lLnNsaWNlKGMtMyxjKzEpKSYmKG98fCI0OTk5IiE9ZSkpeytlJiYoK2Uuc2xpY2UoMSl8fCI1IiE9ZS5jaGFyQXQoMCkpfHwoZXQobixuLmUrRSsyLDEpLHQ9IW4udGltZXMobikuZXEoYSkpO2JyZWFrfWlmKCFvJiYoZXQoaSxpLmUrRSsyLDApLGkudGltZXMoaSkuZXEoYSkpKXtuPWk7YnJlYWt9Zis9NCxjKz00LG89MX1yZXR1cm4gZXQobixuLmUrRSsxLE0sdCl9LEQudGltZXM9RC5tdWw9ZnVuY3Rpb24odCxlKXt2YXIgcixuLG8saSxhLHMsYyx1LHAsaCxtLGcsdixiLF8sdz10aGlzLHg9dy5jLGs9KFA9MTcsdD1uZXcgWCh0LGUpKS5jO2lmKCEoeCYmayYmeFswXSYma1swXSkpcmV0dXJuIXcuc3x8IXQuc3x8eCYmIXhbMF0mJiFrfHxrJiYha1swXSYmIXg/dC5jPXQuZT10LnM9bnVsbDoodC5zKj13LnMseCYmaz8odC5jPVswXSx0LmU9MCk6dC5jPXQuZT1udWxsKSx0O2ZvcihuPXkody5lL2wpK3kodC5lL2wpLHQucyo9dy5zLChjPXgubGVuZ3RoKTwoaD1rLmxlbmd0aCkmJih2PXgseD1rLGs9dixvPWMsYz1oLGg9byksbz1jK2gsdj1bXTtvLS07di5wdXNoKDApKTtmb3IoYj1mLF89ZCxvPWg7LS1vPj0wOyl7Zm9yKHI9MCxtPWtbb10lXyxnPWtbb10vX3wwLGk9bysoYT1jKTtpPm87KXI9KCh1PW0qKHU9eFstLWFdJV8pKyhzPWcqdSsocD14W2FdL198MCkqbSklXypfK3ZbaV0rcikvYnwwKSsocy9ffDApK2cqcCx2W2ktLV09dSViO3ZbaV09cn1yZXR1cm4gcj8rK246di5zcGxpY2UoMCwxKSxRKHQsdixuKX0sRC50b0RpZ2l0cz1mdW5jdGlvbih0LGUpe3ZhciByPW5ldyBYKHRoaXMpO3JldHVybiB0PW51bGwhPXQmJlUodCwxLG0sMTgsInByZWNpc2lvbiIpPzB8dDpudWxsLGU9bnVsbCE9ZSYmVShlLDAsOCwxOCxzKT8wfGU6TSx0P2V0KHIsdCxlKTpyfSxELnRvRXhwb25lbnRpYWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gVih0aGlzLG51bGwhPXQmJlUodCwwLG0sMTkpPzErfn50Om51bGwsZSwxOSl9LEQudG9GaXhlZD1mdW5jdGlvbih0LGUpe3JldHVybiBWKHRoaXMsbnVsbCE9dCYmVSh0LDAsbSwyMCk/fn50K3RoaXMuZSsxOm51bGwsZSwyMCl9LEQudG9Gb3JtYXQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1WKHRoaXMsbnVsbCE9dCYmVSh0LDAsbSwyMSk/fn50K3RoaXMuZSsxOm51bGwsZSwyMSk7aWYodGhpcy5jKXt2YXIgbixvPXIuc3BsaXQoIi4iKSxpPStHLmdyb3VwU2l6ZSxhPStHLnNlY29uZGFyeUdyb3VwU2l6ZSxzPUcuZ3JvdXBTZXBhcmF0b3IsYz1vWzBdLHU9b1sxXSxmPXRoaXMuczwwLGw9Zj9jLnNsaWNlKDEpOmMscD1sLmxlbmd0aDtpZihhJiYobj1pLGk9YSxhPW4scC09biksaT4wJiZwPjApe2ZvcihuPXAlaXx8aSxjPWwuc3Vic3RyKDAsbik7bjxwO24rPWkpYys9cytsLnN1YnN0cihuLGkpO2E+MCYmKGMrPXMrbC5zbGljZShuKSksZiYmKGM9Ii0iK2MpfXI9dT9jK0cuZGVjaW1hbFNlcGFyYXRvcisoKGE9K0cuZnJhY3Rpb25Hcm91cFNpemUpP3UucmVwbGFjZShuZXcgUmVnRXhwKCJcXGR7IithKyJ9XFxCIiwiZyIpLCIkJiIrRy5mcmFjdGlvbkdyb3VwU2VwYXJhdG9yKTp1KTpjfXJldHVybiByfSxELnRvRnJhY3Rpb249ZnVuY3Rpb24odCl7dmFyIGUsbixvLGksYSxzLGMsdSxmLHA9TCxkPXRoaXMsbT1kLmMseT1uZXcgWChSKSx2PW49bmV3IFgoUiksYj1jPW5ldyBYKFIpO2lmKG51bGwhPXQmJihMPSExLHM9bmV3IFgodCksTD1wLChwPXMuaXNJbnQoKSkmJiFzLmx0KFIpfHwoTCYmdHQoMjIsIm1heCBkZW5vbWluYXRvciAiKyhwPyJvdXQgb2YgcmFuZ2UiOiJub3QgYW4gaW50ZWdlciIpLHQpLHQ9IXAmJnMuYyYmZXQocyxzLmUrMSwxKS5ndGUoUik/czpudWxsKSksIW0pcmV0dXJuIGQudG9TdHJpbmcoKTtmb3IoZj1nKG0pLGk9eS5lPWYubGVuZ3RoLWQuZS0xLHkuY1swXT1oWyhhPWklbCk8MD9sK2E6YV0sdD0hdHx8cy5jbXAoeSk+MD9pPjA/eTp2OnMsYT16LHo9MS8wLHM9bmV3IFgoZiksYy5jWzBdPTA7dT1yKHMseSwwLDEpLDEhPShvPW4ucGx1cyh1LnRpbWVzKGIpKSkuY21wKHQpOyluPWIsYj1vLHY9Yy5wbHVzKHUudGltZXMobz12KSksYz1vLHk9cy5taW51cyh1LnRpbWVzKG89eSkpLHM9bztyZXR1cm4gbz1yKHQubWludXMobiksYiwwLDEpLGM9Yy5wbHVzKG8udGltZXModikpLG49bi5wbHVzKG8udGltZXMoYikpLGMucz12LnM9ZC5zLGU9cih2LGIsaSo9MixNKS5taW51cyhkKS5hYnMoKS5jbXAocihjLG4saSxNKS5taW51cyhkKS5hYnMoKSk8MT9bdi50b1N0cmluZygpLGIudG9TdHJpbmcoKV06W2MudG9TdHJpbmcoKSxuLnRvU3RyaW5nKCldLHo9YSxlfSxELnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuK3RoaXN9LEQudG9Qb3dlcj1ELnBvdz1mdW5jdGlvbih0LGUpe3ZhciByLG4sYSxzPWkodDwwPy10Oit0KSxjPXRoaXM7aWYobnVsbCE9ZSYmKFA9MjMsZT1uZXcgWChlKSksIVUodCwtcCxwLDIzLCJleHBvbmVudCIpJiYoIWlzRmluaXRlKHQpfHxzPnAmJih0Lz0wKXx8cGFyc2VGbG9hdCh0KSE9dCYmISh0PU5hTikpfHwwPT10KXJldHVybiByPU1hdGgucG93KCtjLHQpLG5ldyBYKGU/ciVlOnIpO2ZvcihlP3Q+MSYmYy5ndChSKSYmYy5pc0ludCgpJiZlLmd0KFIpJiZlLmlzSW50KCk/Yz1jLm1vZChlKTooYT1lLGU9bnVsbCk6SyYmKHI9byhLL2wrMikpLG49bmV3IFgoUik7Oyl7aWYocyUyKXtpZighKG49bi50aW1lcyhjKSkuYylicmVhaztyP24uYy5sZW5ndGg+ciYmKG4uYy5sZW5ndGg9cik6ZSYmKG49bi5tb2QoZSkpfWlmKCEocz1pKHMvMikpKWJyZWFrO2M9Yy50aW1lcyhjKSxyP2MuYyYmYy5jLmxlbmd0aD5yJiYoYy5jLmxlbmd0aD1yKTplJiYoYz1jLm1vZChlKSl9cmV0dXJuIGU/bjoodDwwJiYobj1SLmRpdihuKSksYT9uLm1vZChhKTpyP2V0KG4sSyxNKTpuKX0sRC50b1ByZWNpc2lvbj1mdW5jdGlvbih0LGUpe3JldHVybiBWKHRoaXMsbnVsbCE9dCYmVSh0LDEsbSwyNCwicHJlY2lzaW9uIik/MHx0Om51bGwsZSwyNCl9LEQudG9TdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGUscj10aGlzLnMsbj10aGlzLmU7cmV0dXJuIG51bGw9PT1uP3I/KGU9IkluZmluaXR5IixyPDAmJihlPSItIitlKSk6ZT0iTmFOIjooZT1nKHRoaXMuYyksZT1udWxsIT10JiZVKHQsMiw2NCwyNSwiYmFzZSIpPyQoayhlLG4pLDB8dCwxMCxyKTpuPD1IfHxuPj1qP3goZSxuKTprKGUsbikscjwwJiZ0aGlzLmNbMF0mJihlPSItIitlKSksZX0sRC50cnVuY2F0ZWQ9RC50cnVuYz1mdW5jdGlvbigpe3JldHVybiBldChuZXcgWCh0aGlzKSx0aGlzLmUrMSwxKX0sRC52YWx1ZU9mPUQudG9KU09OPWZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLmU7cmV0dXJuIG51bGw9PT1lP3RoaXMudG9TdHJpbmcoKToodD1nKHRoaXMuYyksdD1lPD1IfHxlPj1qP3godCxlKTprKHQsZSksdGhpcy5zPDA/Ii0iK3Q6dCl9LEQuaXNCaWdOdW1iZXI9ITAsbnVsbCE9ZSYmWC5jb25maWcoZSksWH0oKSkuZGVmYXVsdD1yLkJpZ051bWJlcj1yLCJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIHJ9KTp2b2lkIDAhPT1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPXI6KHR8fCh0PSJ1bmRlZmluZWQiIT10eXBlb2Ygc2VsZj9zZWxmOkZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCkpLHQuQmlnTnVtYmVyPXIpfSh0aGlzKX0se31dLHdlYjM6W2Z1bmN0aW9uKHQsZSxyKXt2YXIgbj10KCIuL2xpYi93ZWIzIik7InVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJnZvaWQgMD09PXdpbmRvdy5XZWIzJiYod2luZG93LldlYjM9biksZS5leHBvcnRzPW59LHsiLi9saWIvd2ViMyI6MjJ9XX0se30sWyJ3ZWIzIl0pOwp9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSxfZGVyZXFfKCJidWZmZXIiKS5CdWZmZXIpCgp9LHsiYnVmZmVyIjoiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svbm9kZV9tb2R1bGVzL19idWZmZXJANS4xLjBAYnVmZmVyL2luZGV4LmpzIn1dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3dyYXBweUAxLjAuMkB3cmFwcHkvd3JhcHB5LmpzIjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2sKLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYQovLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi4KLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0Ci8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5Lgptb2R1bGUuZXhwb3J0cyA9IHdyYXBweQpmdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikgewogIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpCgogIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpCiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKQoKICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykgewogICAgd3JhcHBlcltrXSA9IGZuW2tdCiAgfSkKCiAgcmV0dXJuIHdyYXBwZXIKCiAgZnVuY3Rpb24gd3JhcHBlcigpIHsKICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHsKICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXQogICAgfQogICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpCiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdCiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7CiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7CiAgICAgICAgcmV0W2tdID0gY2Jba10KICAgICAgfSkKICAgIH0KICAgIHJldHVybiByZXQKICB9Cn0KCn0se31dLCIvVXNlcnMvZ2FubGluemhlbi9EZXNrdG9wLzEwLWdpdGh1Yumhueebri9zaGFyZW1ldGFtYXNrL3NoYXJlTWFzay9ub2RlX21vZHVsZXMvX3h0ZW5kQDQuMC4xQHh0ZW5kL2ltbXV0YWJsZS5qcyI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGV4dGVuZAoKdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsKCmZ1bmN0aW9uIGV4dGVuZCgpIHsKICAgIHZhciB0YXJnZXQgPSB7fQoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXQoKICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7CiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgewogICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIHJldHVybiB0YXJnZXQKfQoKfSx7fV19LHt9LFsiL1VzZXJzL2dhbmxpbnpoZW4vRGVza3RvcC8xMC1naXRodWLpobnnm64vc2hhcmVtZXRhbWFzay9zaGFyZU1hc2svYXBwL3NjcmlwdHMvaW5wYWdlLmpzIl0pCgovLyMgc291cmNlTWFwcGluZ1VSTD1pbnBhZ2UuanMubWFwCg==","base64").toString();
var inpageSuffix = '//# sourceURL=' + extension.extension.getURL('inpage.js') + '\n';
var inpageBundle = inpageContent + inpageSuffix;

// Eventually this streaming injection could be replaced with:
// https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.exportFunction
//
// But for now that is only Firefox
// If we create a FireFox-only code path using that API,
// MetaMask will be much faster loading and performant on Firefox.

if (shouldInjectWeb3()) {
  setupInjection();
  setupStreams();
}

/**
 * Creates a script tag that injects inpage.js
 */
function setupInjection() {
  try {
    // inject in-page script
    var scriptTag = document.createElement('script');
    scriptTag.textContent = inpageBundle;
    scriptTag.onload = function () {
      this.parentNode.removeChild(this);
    };
    var container = document.head || document.documentElement;
    // append as first child
    container.insertBefore(scriptTag, container.children[0]);
  } catch (e) {
    console.error('Metamask injection failed.', e);
  }
}

/**
 * Sets up two-way communication streams between the
 * browser extension and local per-page browser context
 */
function setupStreams() {
  // setup communication to page and plugin
  var pageStream = new LocalMessageDuplexStream({
    name: 'contentscript',
    target: 'inpage'
  });
  var pluginPort = extension.runtime.connect({ name: 'contentscript' });
  var pluginStream = new PortStream(pluginPort);

  // forward communication plugin->inpage
  pump(pageStream, pluginStream, pageStream, function (err) {
    return logStreamDisconnectWarning('MetaMask Contentscript Forwarding', err);
  });

  // setup local multistream channels
  var mux = new ObjectMultiplex();
  mux.setMaxListeners(25);

  pump(mux, pageStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask Inpage', err);
  });
  pump(mux, pluginStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask Background', err);
  });

  // connect ping stream
  var pongStream = new PongStream({ objectMode: true });
  pump(mux, pongStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask PingPongStream', err);
  });

  // connect phishing warning stream
  var phishingStream = mux.createStream('phishing');
  phishingStream.once('data', redirectToPhishingWarning);

  // ignore unused channels (handled by background, inpage)
  mux.ignoreStream('provider');
  mux.ignoreStream('publicConfig');
}

/**
 * Error handler for page to plugin stream disconnections
 *
 * @param {string} remoteLabel Remote stream name
 * @param {Error} err Stream connection error
 */
function logStreamDisconnectWarning(remoteLabel, err) {
  var warningMsg = 'MetamaskContentscript - lost connection to ' + remoteLabel;
  if (err) warningMsg += '\n' + err.stack;
  console.warn(warningMsg);
}

/**
 * Determines if Web3 should be injected
 *
 * @returns {boolean} {@code true} if Web3 should be injected
 */
function shouldInjectWeb3() {
  return doctypeCheck() && suffixCheck() && documentElementCheck() && !blacklistedDomainCheck();
}

/**
 * Checks the doctype of the current document if it exists
 *
 * @returns {boolean} {@code true} if the doctype is html or if none exists
 */
function doctypeCheck() {
  var doctype = window.document.doctype;
  if (doctype) {
    return doctype.name === 'html';
  } else {
    return true;
  }
}

/**
 * Checks the current document extension
 *
 * @returns {boolean} {@code true} if the current extension is not prohibited
 */
function suffixCheck() {
  var prohibitedTypes = ['xml', 'pdf'];
  var currentUrl = window.location.href;
  var currentRegex;
  for (var i = 0; i < prohibitedTypes.length; i++) {
    currentRegex = new RegExp('\\.' + prohibitedTypes[i] + '$');
    if (currentRegex.test(currentUrl)) {
      return false;
    }
  }
  return true;
}

/**
 * Checks the documentElement of the current document
 *
 * @returns {boolean} {@code true} if the documentElement is an html node or if none exists
 */
function documentElementCheck() {
  var documentElement = document.documentElement.nodeName;
  if (documentElement) {
    return documentElement.toLowerCase() === 'html';
  }
  return true;
}

/**
 * Checks if the current domain is blacklisted
 *
 * @returns {boolean} {@code true} if the current domain is blacklisted
 */
function blacklistedDomainCheck() {
  var blacklistedDomains = ['uscourts.gov', 'dropbox.com', 'webbyawards.com', 'cdn.shopify.com/s/javascripts/tricorder/xtld-read-only-frame.html', 'adyen.com'];
  var currentUrl = window.location.href;
  var currentRegex;
  for (var i = 0; i < blacklistedDomains.length; i++) {
    var blacklistedDomain = blacklistedDomains[i].replace('.', '\\.');
    currentRegex = new RegExp('(?:https?:\\/\\/)(?:(?!' + blacklistedDomain + ').)*$');
    if (!currentRegex.test(currentUrl)) {
      return true;
    }
  }
  return false;
}

/**
 * Redirects the current page to a phishing information page
 */
function redirectToPhishingWarning() {
  console.log('MetaMask - redirecting to phishing warning');
  window.location.href = 'https://metamask.io/phishing.html';
}


}).call(this,_dereq_("buffer").Buffer)

},{"./lib/port-stream.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/app/scripts/lib/port-stream.js","buffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_buffer@5.1.0@buffer/index.js","extensionizer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_extensionizer@1.0.1@extensionizer/index.js","obj-multiplex":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_obj-multiplex@1.0.0@obj-multiplex/index.js","path":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_path-browserify@0.0.0@path-browserify/index.js","ping-pong-stream/pong":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_ping-pong-stream@1.0.0@ping-pong-stream/pong.js","post-message-stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_post-message-stream@3.0.0@post-message-stream/index.js","pump":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_pump@3.0.0@pump/index.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/app/scripts/lib/port-stream.js":[function(_dereq_,module,exports){
(function (Buffer){
'use strict';

var Duplex = _dereq_('readable-stream').Duplex;
var inherits = _dereq_('util').inherits;
var noop = function noop() {};

module.exports = PortDuplexStream;

inherits(PortDuplexStream, Duplex);

/**
 * Creates a stream that's both readable and writable.
 * The stream supports arbitrary objects.
 *
 * @class
 * @param {Object} port Remote Port object
 */
function PortDuplexStream(port) {
  Duplex.call(this, {
    objectMode: true
  });
  this._port = port;
  port.onMessage.addListener(this._onMessage.bind(this));
  port.onDisconnect.addListener(this._onDisconnect.bind(this));
}

/**
 * Callback triggered when a message is received from
 * the remote Port associated with this Stream.
 *
 * @private
 * @param {Object} msg - Payload from the onMessage listener of Port
 */
PortDuplexStream.prototype._onMessage = function (msg) {
  if (Buffer.isBuffer(msg)) {
    delete msg._isBuffer;
    var data = new Buffer(msg);
    this.push(data);
  } else {
    this.push(msg);
  }
};

/**
 * Callback triggered when the remote Port
 * associated with this Stream disconnects.
 *
 * @private
 */
PortDuplexStream.prototype._onDisconnect = function () {
  this.destroy();
};

/**
 * Explicitly sets read operations to a no-op
 */
PortDuplexStream.prototype._read = noop;

/**
 * Called internally when data should be written to
 * this writable stream.
 * 
 * @private
 * @param {*} msg Arbitrary object to write
 * @param {string} encoding Encoding to use when writing payload
 * @param {Function} cb Called when writing is complete or an error occurs
 */
PortDuplexStream.prototype._write = function (msg, encoding, cb) {
  try {
    if (Buffer.isBuffer(msg)) {
      var data = msg.toJSON();
      data._isBuffer = true;
      this._port.postMessage(data);
    } else {
      this._port.postMessage(msg);
    }
  } catch (err) {
    return cb(new Error('PortDuplexStream - disconnected'));
  }
  cb();
};


}).call(this,_dereq_("buffer").Buffer)

},{"buffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_buffer@5.1.0@buffer/index.js","readable-stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/readable-browser.js","util":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util@0.10.3@util/util.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_base64-js@1.3.0@base64-js/index.js":[function(_dereq_,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_browser-resolve@1.11.2@browser-resolve/empty.js":[function(_dereq_,module,exports){

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_buffer@5.1.0@buffer/index.js":[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_base64-js@1.3.0@base64-js/index.js","ieee754":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_ieee754@1.1.11@ieee754/index.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_core-util-is@1.0.2@core-util-is/lib/util.js":[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":_dereq_("../../../../_is-buffer@1.1.6@is-buffer/index.js")})

},{"../../../../_is-buffer@1.1.6@is-buffer/index.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/_is-buffer@1.1.6@is-buffer/index.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_end-of-stream@1.4.1@end-of-stream/index.js":[function(_dereq_,module,exports){
var once = _dereq_('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

},{"once":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_once@1.4.0@once/once.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_events@2.1.0@events/events.js":[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_extensionizer@1.0.1@extensionizer/extension-instance.js":[function(_dereq_,module,exports){
const apis = [
  'alarms',
  'bookmarks',
  'browserAction',
  'commands',
  'contextMenus',
  'cookies',
  'downloads',
  'events',
  'extension',
  'extensionTypes',
  'history',
  'i18n',
  'idle',
  'notifications',
  'pageAction',
  'runtime',
  'storage',
  'tabs',
  'webNavigation',
  'webRequest',
  'windows',
]

const hasChrome = typeof chrome !== 'undefined'
const hasWindow = typeof window !== 'undefined'
const hasBrowser = typeof browser !== 'undefined'

function Extension () {
  const _this = this

  apis.forEach(function (api) {

    _this[api] = null

    if (hasChrome) {
      try {
        if (chrome[api]) {
          _this[api] = chrome[api]
        }
      } catch (e) {
      }
    }

    if (hasWindow) {
      try {
        if (window[api]) {
          _this[api] = window[api]
        }
      } catch (e) {
      }
    }

    if (hasBrowser) {
      try {
        if (browser[api]) {
          _this[api] = browser[api]
        }
      } catch (e) {
      }
      try {
        _this.api = browser.extension[api]
      } catch (e) {
      }
    }
  })

  if (hasBrowser) {
    try {
      if (browser && browser.runtime) {
        this.runtime = browser.runtime
      }
    } catch (e) {
    }

    try {
      if (browser && browser.browserAction) {
        this.browserAction = browser.browserAction
      }
    } catch (e) {
    }
  }

}

module.exports = Extension

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_extensionizer@1.0.1@extensionizer/index.js":[function(_dereq_,module,exports){
/* Extension.js
 *
 * A module for unifying browser differences in the WebExtension API.
 *
 * Initially implemented because Chrome hides all of their WebExtension API
 * behind a global `chrome` variable, but we'd like to start grooming
 * the code-base for cross-browser extension support.
 *
 * You can read more about the WebExtension API here:
 * https://developer.mozilla.org/en-US/Add-ons/WebExtensions
 */

const Extension = _dereq_('./extension-instance')
module.exports = new Extension()

},{"./extension-instance":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_extensionizer@1.0.1@extensionizer/extension-instance.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_ieee754@1.1.11@ieee754/index.js":[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.1@inherits/inherits_browser.js":[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.3@inherits/inherits_browser.js":[function(_dereq_,module,exports){
arguments[4]["/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.1@inherits/inherits_browser.js"][0].apply(exports,arguments)
},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_isarray@1.0.0@isarray/index.js":[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_obj-multiplex@1.0.0@obj-multiplex/index.js":[function(_dereq_,module,exports){
const { Duplex } = _dereq_('readable-stream')
const endOfStream = _dereq_('end-of-stream')
const once = _dereq_('once')
const noop = () => {}

const IGNORE_SUBSTREAM = {}


class ObjectMultiplex extends Duplex {

  constructor(_opts = {}) {
    const opts = Object.assign({}, _opts, {
      objectMode: true,
    })
    super(opts)

    this._substreams = {}
  }

  createStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')

    // create substream
    const substream = new Substream({ parent: this, name: name })
    this._substreams[name] = substream

    // listen for parent stream to end
    anyStreamEnd(this, (err) => {
      substream.destroy(err)
    })

    return substream
  }

  // ignore streams (dont display orphaned data warning)
  ignoreStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')
    // set
    this._substreams[name] = IGNORE_SUBSTREAM
  }

  // stream plumbing

  _read () {}

  _write(chunk, encoding, callback) {
    // parse message
    const name = chunk.name
    const data = chunk.data
    if (!name) {
      console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`)
      return callback()
    }

    // get corresponding substream
    const substream = this._substreams[name]
    if (!substream) {
      console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`)
      return callback()
    }

    // push data into substream
    if (substream !== IGNORE_SUBSTREAM) {
      substream.push(data)
    }

    callback()
  }

}


class Substream extends Duplex {

  constructor ({ parent, name }) {
    super({
      objectMode: true,
    })

    this._parent = parent
    this._name = name
  }

  _read () {}

  _write (chunk, enc, callback) {
    this._parent.push({
      name: this._name,
      data: chunk,
    })
    callback()
  }

}

module.exports = ObjectMultiplex

// util

function anyStreamEnd(stream, _cb) {
  const cb = once(_cb)
  endOfStream(stream, { readable: false }, cb)
  endOfStream(stream, { writable: false }, cb)
}
},{"end-of-stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_end-of-stream@1.4.1@end-of-stream/index.js","once":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_once@1.4.0@once/once.js","readable-stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/readable-browser.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_once@1.4.0@once/once.js":[function(_dereq_,module,exports){
var wrappy = _dereq_('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_wrappy@1.0.2@wrappy/wrappy.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_path-browserify@0.0.0@path-browserify/index.js":[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,_dereq_('_process'))

},{"_process":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_ping-pong-stream@1.0.0@ping-pong-stream/pong.js":[function(_dereq_,module,exports){
const Duplex = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PongStream

inherits(PongStream, Duplex)

function PongStream (opts) {
  const self = this
  opts = opts || {}
  Duplex.call(this, opts)
  self._heartbeatRequest = opts.heartbeatRequest || 'ping'
  self._heartbeatResponse = opts.heartbeatResponse || 'pong'
}

// private

PongStream.prototype._sendResponse = function (msg) {
  const self = this
  self.push(self._heartbeatResponse)
}

// stream plumbing

PongStream.prototype._read = noop

PongStream.prototype._write = function (msg, encoding, cb) {
  const self = this
  if (msg.toString() === self._heartbeatRequest.toString()) {
    // heartbeat heard
    self._sendResponse()
    cb()
  } else {
    // unknown message
    cb(new Error('PongStream - unknown request'))
  }
  
}

// util

function noop() {}
},{"readable-stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/readable-browser.js","util":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util@0.10.3@util/util.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_post-message-stream@3.0.0@post-message-stream/index.js":[function(_dereq_,module,exports){
const DuplexStream = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PostMessageStream

inherits(PostMessageStream, DuplexStream)

function PostMessageStream (opts) {
  DuplexStream.call(this, {
    objectMode: true,
  })

  this._name = opts.name
  this._target = opts.target
  this._targetWindow = opts.targetWindow || window
  this._origin = (opts.targetWindow ? '*' : location.origin)

  // initialization flags
  this._init = false
  this._haveSyn = false

  window.addEventListener('message', this._onMessage.bind(this), false)
  // send syncorization message
  this._write('SYN', null, noop)
  this.cork()
}

// private
PostMessageStream.prototype._onMessage = function (event) {
  var msg = event.data

  // validate message
  if (this._origin !== '*' && event.origin !== this._origin) return
  if (event.source !== this._targetWindow) return
  if (typeof msg !== 'object') return
  if (msg.target !== this._name) return
  if (!msg.data) return

  if (!this._init) {
    if (msg.data === 'SYN') {
      this._haveSyn = true
      this._write('ACK', null, noop)
    } else if (msg.data === 'ACK') {
      this._init = true
      if (!this._haveSyn) {
        this._write('ACK', null, noop)
      }
      this.uncork()
    }
  } else {
    // forward message
    try {
      this.push(msg.data)
    } catch (err) {
      this.emit('error', err)
    }
  }
}

// stream plumbing
PostMessageStream.prototype._read = noop

PostMessageStream.prototype._write = function (data, encoding, cb) {
  var message = {
    target: this._target,
    data: data,
  }
  this._targetWindow.postMessage(message, this._origin)
  cb()
}

// util

function noop () {}

},{"readable-stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/readable-browser.js","util":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util@0.10.3@util/util.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process-nextick-args@2.0.0@process-nextick-args/index.js":[function(_dereq_,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,_dereq_('_process'))

},{"_process":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js":[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_pump@3.0.0@pump/index.js":[function(_dereq_,module,exports){
(function (process){
var once = _dereq_('once')
var eos = _dereq_('end-of-stream')
var fs = _dereq_('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

}).call(this,_dereq_('_process'))

},{"_process":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js","end-of-stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_end-of-stream@1.4.1@end-of-stream/index.js","fs":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_browser-resolve@1.11.2@browser-resolve/empty.js","once":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_once@1.4.0@once/once.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_duplex.js":[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_readable.js","./_stream_writable":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_writable.js","core-util-is":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_core-util-is@1.0.2@core-util-is/lib/util.js","inherits":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.3@inherits/inherits_browser.js","process-nextick-args":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process-nextick-args@2.0.0@process-nextick-args/index.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_passthrough.js":[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_transform.js","core-util-is":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_core-util-is@1.0.2@core-util-is/lib/util.js","inherits":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.3@inherits/inherits_browser.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_readable.js":[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = _dereq_('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = _dereq_('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = _dereq_('./internal/streams/BufferList');
var destroyImpl = _dereq_('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_duplex.js","./internal/streams/BufferList":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/BufferList.js","./internal/streams/destroy":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/destroy.js","./internal/streams/stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/stream-browser.js","_process":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js","core-util-is":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_core-util-is@1.0.2@core-util-is/lib/util.js","events":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_events@2.1.0@events/events.js","inherits":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.3@inherits/inherits_browser.js","isarray":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_isarray@1.0.0@isarray/index.js","process-nextick-args":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process-nextick-args@2.0.0@process-nextick-args/index.js","safe-buffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_safe-buffer@5.1.2@safe-buffer/index.js","string_decoder/":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_string_decoder@1.1.1@string_decoder/lib/string_decoder.js","util":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_browser-resolve@1.11.2@browser-resolve/empty.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_transform.js":[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_duplex.js","core-util-is":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_core-util-is@1.0.2@core-util-is/lib/util.js","inherits":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.3@inherits/inherits_browser.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_writable.js":[function(_dereq_,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: _dereq_('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = _dereq_('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},_dereq_("timers").setImmediate)

},{"./_stream_duplex":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_duplex.js","./internal/streams/destroy":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/destroy.js","./internal/streams/stream":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/stream-browser.js","_process":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js","core-util-is":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_core-util-is@1.0.2@core-util-is/lib/util.js","inherits":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.3@inherits/inherits_browser.js","process-nextick-args":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process-nextick-args@2.0.0@process-nextick-args/index.js","safe-buffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_safe-buffer@5.1.2@safe-buffer/index.js","timers":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_timers-browserify@1.4.2@timers-browserify/main.js","util-deprecate":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util-deprecate@1.0.2@util-deprecate/browser.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/BufferList.js":[function(_dereq_,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = _dereq_('safe-buffer').Buffer;
var util = _dereq_('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_safe-buffer@5.1.2@safe-buffer/index.js","util":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_browser-resolve@1.11.2@browser-resolve/empty.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/destroy.js":[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

var pna = _dereq_('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process-nextick-args@2.0.0@process-nextick-args/index.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/internal/streams/stream-browser.js":[function(_dereq_,module,exports){
module.exports = _dereq_('events').EventEmitter;

},{"events":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_events@2.1.0@events/events.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/readable-browser.js":[function(_dereq_,module,exports){
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_duplex.js","./lib/_stream_passthrough.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_passthrough.js","./lib/_stream_readable.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_readable.js","./lib/_stream_transform.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_transform.js","./lib/_stream_writable.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_readable-stream@2.3.6@readable-stream/lib/_stream_writable.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_safe-buffer@5.1.2@safe-buffer/index.js":[function(_dereq_,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = _dereq_('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_buffer@5.1.0@buffer/index.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_string_decoder@1.1.1@string_decoder/lib/string_decoder.js":[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = _dereq_('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_safe-buffer@5.1.2@safe-buffer/index.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_timers-browserify@1.4.2@timers-browserify/main.js":[function(_dereq_,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = _dereq_('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,_dereq_("timers").setImmediate,_dereq_("timers").clearImmediate)

},{"process/browser.js":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js","timers":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_timers-browserify@1.4.2@timers-browserify/main.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util-deprecate@1.0.2@util-deprecate/browser.js":[function(_dereq_,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util@0.10.3@util/support/isBufferBrowser.js":[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util@0.10.3@util/util.js":[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_util@0.10.3@util/support/isBufferBrowser.js","_process":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_process@0.11.10@process/browser.js","inherits":"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_inherits@2.0.1@inherits/inherits_browser.js"}],"/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/node_modules/_wrappy@1.0.2@wrappy/wrappy.js":[function(_dereq_,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}]},{},["/Users/ganlinzhen/Desktop/10-github项目/sharemetamask/shareMask/app/scripts/contentscript.js"])

//# sourceMappingURL=contentscript.js.map
